{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A Curious Python Course # Warning Work in progress - this site is under construction and unfinished business. Training material for your quest to become a snake charmer . This course intends to get you acquainted with Python's essentials. You should be able to read & understand a good part of Python code & write your own with the information provided here. Deals with the 3.x generation of the species only . 1 >>> import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those! Take a look at what this is all about first . Or, dive right into the tutorial . Well, apart from the occasional nostalgic comment or reference, that is. \u21a9","title":"Home"},{"location":"#a-curious-python-course","text":"Warning Work in progress - this site is under construction and unfinished business. Training material for your quest to become a snake charmer . This course intends to get you acquainted with Python's essentials. You should be able to read & understand a good part of Python code & write your own with the information provided here. Deals with the 3.x generation of the species only . 1 >>> import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those! Take a look at what this is all about first . Or, dive right into the tutorial . Well, apart from the occasional nostalgic comment or reference, that is. \u21a9","title":"A Curious Python Course"},{"location":"about/cpycourse-contributors/","text":"The Curious Python Course Contributors # https://github.com/hjoukl https://github.com/rkluger68","title":"Contributors"},{"location":"about/cpycourse-contributors/#the-curious-python-course-contributors","text":"https://github.com/hjoukl https://github.com/rkluger68","title":"The Curious Python Course Contributors"},{"location":"about/curious-python-course/","text":"About # A curious Python course. Practical Python learning material as we see fit.","title":"Curious Python Course"},{"location":"about/curious-python-course/#about","text":"A curious Python course. Practical Python learning material as we see fit.","title":"About"},{"location":"about/legal/","text":"Legal # All original content of this website is governed by its license . Snippets from Python documentation output e.g. in examples from interactive interpreter sessions represented here are subject to Python's license . Python and PyCon are trademarks or registered trademarks of the Python Software Foundation . All other trademarks mentioned on this website are the property of their respective owners. External Links # External links are being provided as a convenience and for informational purposes only; they do not constitute an endorsement or an approval by the cpycourse contributors of any of the products, services or opinions of the corporation or organization or individual. The cpycourse contributors bear no responsibility for the accuracy, legality or content of the external site or for that of its subsequent links. Contact the external site for answers to questions regarding its content.","title":"Legal"},{"location":"about/legal/#legal","text":"All original content of this website is governed by its license . Snippets from Python documentation output e.g. in examples from interactive interpreter sessions represented here are subject to Python's license . Python and PyCon are trademarks or registered trademarks of the Python Software Foundation . All other trademarks mentioned on this website are the property of their respective owners.","title":"Legal"},{"location":"about/legal/#external-links","text":"External links are being provided as a convenience and for informational purposes only; they do not constitute an endorsement or an approval by the cpycourse contributors of any of the products, services or opinions of the corporation or organization or individual. The cpycourse contributors bear no responsibility for the accuracy, legality or content of the external site or for that of its subsequent links. Contact the external site for answers to questions regarding its content.","title":"External Links"},{"location":"about/license/","text":"Mozilla Public License Version 2.0 # 1. Definitions # 1.1. \"Contributor\" means each individual or legal entity that creates, contributes to the creation of, or owns Covered Software. 1.2. \"Contributor Version\" means the combination of the Contributions of others (if any) used by a Contributor and that particular Contributor's Contribution. 1.3. \"Contribution\" means Covered Software of a particular Contributor. 1.4. \"Covered Software\" means Source Code Form to which the initial Contributor has attached the notice in Exhibit A, the Executable Form of such Source Code Form, and Modifications of such Source Code Form, in each case including portions thereof. 1.5. \"Incompatible With Secondary Licenses\" means (a) that the initial Contributor has attached the notice described in Exhibit B to the Covered Software; or (b) that the Covered Software was made available under the terms of version 1.1 or earlier of the License, but not also under the terms of a Secondary License. 1.6. \"Executable Form\" means any form of the work other than Source Code Form. 1.7. \"Larger Work\" means a work that combines Covered Software with other material, in a separate file or files, that is not Covered Software. 1.8. \"License\" means this document. 1.9. \"Licensable\" means having the right to grant, to the maximum extent possible, whether at the time of the initial grant or subsequently, any and all of the rights conveyed by this License. 1.10. \"Modifications\" means any of the following: (a) any file in Source Code Form that results from an addition to, deletion from, or modification of the contents of Covered Software; or (b) any new file in Source Code Form that contains any Covered Software. 1.11. \"Patent Claims\" of a Contributor means any patent claim(s), including without limitation, method, process, and apparatus claims, in any patent Licensable by such Contributor that would be infringed, but for the grant of the License, by the making, using, selling, offering for sale, having made, import, or transfer of either its Contributions or its Contributor Version. 1.12. \"Secondary License\" means either the GNU General Public License, Version 2.0, the GNU Lesser General Public License, Version 2.1, the GNU Affero General Public License, Version 3.0, or any later versions of those licenses. 1.13. \"Source Code Form\" means the form of the work preferred for making modifications. 1.14. \"You\" (or \"Your\") means an individual or a legal entity exercising rights under this License. For legal entities, \"You\" includes any entity that controls, is controlled by, or is under common control with You. For purposes of this definition, \"control\" means (a) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (b) ownership of more than fifty percent (50%) of the outstanding shares or beneficial ownership of such entity. 2. License Grants and Conditions # 2.1. Grants Each Contributor hereby grants You a world-wide, royalty-free, non-exclusive license: (a) under intellectual property rights (other than patent or trademark) Licensable by such Contributor to use, reproduce, make available, modify, display, perform, distribute, and otherwise exploit its Contributions, either on an unmodified basis, with Modifications, or as part of a Larger Work; and (b) under Patent Claims of such Contributor to make, use, sell, offer for sale, have made, import, and otherwise transfer either its Contributions or its Contributor Version. 2.2. Effective Date The licenses granted in Section 2.1 with respect to any Contribution become effective for each Contribution on the date the Contributor first distributes such Contribution. 2.3. Limitations on Grant Scope The licenses granted in this Section 2 are the only rights granted under this License. No additional rights or licenses will be implied from the distribution or licensing of Covered Software under this License. Notwithstanding Section 2.1(b) above, no patent license is granted by a Contributor: (a) for any code that a Contributor has removed from Covered Software; or (b) for infringements caused by: (i) Your and any other third party's modifications of Covered Software, or (ii) the combination of its Contributions with other software (except as part of its Contributor Version); or \u00a9 under Patent Claims infringed by Covered Software in the absence of its Contributions. This License does not grant any rights in the trademarks, service marks, or logos of any Contributor (except as may be necessary to comply with the notice requirements in Section 3.4). 2.4. Subsequent Licenses No Contributor makes additional grants as a result of Your choice to distribute the Covered Software under a subsequent version of this License (see Section 10.2) or under the terms of a Secondary License (if permitted under the terms of Section 3.3). 2.5. Representation Each Contributor represents that the Contributor believes its Contributions are its original creation(s) or it has sufficient rights to grant the rights to its Contributions conveyed by this License. 2.6. Fair Use This License is not intended to limit any rights You have under applicable copyright doctrines of fair use, fair dealing, or other equivalents. 2.7. Conditions Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted in Section 2.1. 3. Responsibilities # 3.1. Distribution of Source Form All distribution of Covered Software in Source Code Form, including any Modifications that You create or to which You contribute, must be under the terms of this License. You must inform recipients that the Source Code Form of the Covered Software is governed by the terms of this License, and how they can obtain a copy of this License. You may not attempt to alter or restrict the recipients' rights in the Source Code Form. 3.2. Distribution of Executable Form If You distribute Covered Software in Executable Form then: (a) such Covered Software must also be made available in Source Code Form, as described in Section 3.1, and You must inform recipients of the Executable Form how they can obtain a copy of such Source Code Form by reasonable means in a timely manner, at a charge no more than the cost of distribution to the recipient; and (b) You may distribute such Executable Form under the terms of this License, or sublicense it under different terms, provided that the license for the Executable Form does not attempt to limit or alter the recipients' rights in the Source Code Form under this License. 3.3. Distribution of a Larger Work You may create and distribute a Larger Work under terms of Your choice, provided that You also comply with the requirements of this License for the Covered Software. If the Larger Work is a combination of Covered Software with a work governed by one or more Secondary Licenses, and the Covered Software is not Incompatible With Secondary Licenses, this License permits You to additionally distribute such Covered Software under the terms of such Secondary License(s), so that the recipient of the Larger Work may, at their option, further distribute the Covered Software under the terms of either this License or such Secondary License(s). 3.4. Notices You may not remove or alter the substance of any license notices (including copyright notices, patent notices, disclaimers of warranty, or limitations of liability) contained within the Source Code Form of the Covered Software, except that You may alter any license notices to the extent required to remedy known factual inaccuracies. 3.5. Application of Additional Terms You may choose to offer, and to charge a fee for, warranty, support, indemnity or liability obligations to one or more recipients of Covered Software. However, You may do so only on Your own behalf, and not on behalf of any Contributor. You must make it absolutely clear that any such warranty, support, indemnity, or liability obligation is offered by You alone, and You hereby agree to indemnify every Contributor for any liability incurred by such Contributor as a result of warranty, support, indemnity or liability terms You offer. You may include additional disclaimers of warranty and limitations of liability specific to any jurisdiction. 4. Inability to Comply Due to Statute or Regulation # If it is impossible for You to comply with any of the terms of this License with respect to some or all of the Covered Software due to statute, judicial order, or regulation then You must: (a) comply with the terms of this License to the maximum extent possible; and (b) describe the limitations and the code they affect. Such description must be placed in a text file included with all distributions of the Covered Software under this License. Except to the extent prohibited by statute or regulation, such description must be sufficiently detailed for a recipient of ordinary skill to be able to understand it. 5. Termination # 5.1. The rights granted under this License will terminate automatically if You fail to comply with any of its terms. However, if You become compliant, then the rights granted under this License from a particular Contributor are reinstated (a) provisionally, unless and until such Contributor explicitly and finally terminates Your grants, and (b) on an ongoing basis, if such Contributor fails to notify You of the non-compliance by some reasonable means prior to 60 days after You have come back into compliance. Moreover, Your grants from a particular Contributor are reinstated on an ongoing basis if such Contributor notifies You of the non-compliance by some reasonable means, this is the first time You have received notice of non-compliance with this License from such Contributor, and You become compliant prior to 30 days after Your receipt of the notice. 5.2. If You initiate litigation against any entity by asserting a patent infringement claim (excluding declaratory judgment actions, counter-claims, and cross-claims) alleging that a Contributor Version directly or indirectly infringes any patent, then the rights granted to You by any and all Contributors for the Covered Software under Section 2.1 of this License shall terminate. 5.3. In the event of termination under Sections 5.1 or 5.2 above, all end user license agreements (excluding distributors and resellers) which have been validly granted by You or Your distributors under this License prior to termination shall survive termination. * Disclaimer of Warranty * ------------------------- * * Covered Software is provided under this License on an \"as is\" * basis, without warranty of any kind, either expressed, implied, or * statutory, including, without limitation, warranties that the * Covered Software is free of defects, merchantable, fit for a * particular purpose or non-infringing. The entire risk as to the * quality and performance of the Covered Software is with You. * Should any Covered Software prove defective in any respect, You * (not any Contributor) assume the cost of any necessary servicing, * repair, or correction. This disclaimer of warranty constitutes an * essential part of this License. No use of any Covered Software is * authorized under this License except under this disclaimer. * * * Limitation of Liability * -------------------------- * * Under no circumstances and under no legal theory, whether tort * (including negligence), contract, or otherwise, shall any * Contributor, or anyone who distributes Covered Software as * permitted above, be liable to You for any direct, indirect, * special, incidental, or consequential damages of any character * including, without limitation, damages for lost profits, loss of * goodwill, work stoppage, computer failure or malfunction, or any * and all other commercial damages or losses, even if such party * shall have been informed of the possibility of such damages. This * limitation of liability shall not apply to liability for death or * personal injury resulting from such party's negligence to the * extent applicable law prohibits such limitation. Some * jurisdictions do not allow the exclusion or limitation of * incidental or consequential damages, so this exclusion and * limitation may not apply to You. * * 8. Litigation # Any litigation relating to this License may be brought only in the courts of a jurisdiction where the defendant maintains its principal place of business and such litigation shall be governed by laws of that jurisdiction, without reference to its conflict-of-law provisions. Nothing in this Section shall prevent a party's ability to bring cross-claims or counter-claims. 9. Miscellaneous # This License represents the complete agreement concerning the subject matter hereof. If any provision of this License is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable. Any law or regulation which provides that the language of a contract shall be construed against the drafter shall not be used to construe this License against a Contributor. 10. Versions of the License # 10.1. New Versions Mozilla Foundation is the license steward. Except as provided in Section 10.3, no one other than the license steward has the right to modify or publish new versions of this License. Each version will be given a distinguishing version number. 10.2. Effect of New Versions You may distribute the Covered Software under the terms of the version of the License under which You originally received the Covered Software, or under the terms of any subsequent version published by the license steward. 10.3. Modified Versions If you create software not governed by this License, and you want to create a new license for such software, you may create and use a modified version of this License if you rename the license and remove any references to the name of the license steward (except to note that such modified license differs from this License). 10.4. Distributing Source Code Form that is Incompatible With Secondary Licenses If You choose to distribute Source Code Form that is Incompatible With Secondary Licenses under the terms of this version of the License, the notice described in Exhibit B of this License must be attached. Exhibit A - Source Code Form License Notice # This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/ . If it is not possible or desirable to put the notice in a particular file, then You may include the notice in a location (such as a LICENSE file in a relevant directory) where a recipient would be likely to look for such a notice. You may add additional accurate notices of copyright ownership. Exhibit B - \"Incompatible With Secondary Licenses\" Notice # This Source Code Form is \"Incompatible With Secondary Licenses\", as defined by the Mozilla Public License, v. 2.0.","title":"License"},{"location":"about/license/#mozilla-public-license-version-20","text":"","title":"Mozilla Public License Version 2.0"},{"location":"about/license/#1-definitions","text":"1.1. \"Contributor\" means each individual or legal entity that creates, contributes to the creation of, or owns Covered Software. 1.2. \"Contributor Version\" means the combination of the Contributions of others (if any) used by a Contributor and that particular Contributor's Contribution. 1.3. \"Contribution\" means Covered Software of a particular Contributor. 1.4. \"Covered Software\" means Source Code Form to which the initial Contributor has attached the notice in Exhibit A, the Executable Form of such Source Code Form, and Modifications of such Source Code Form, in each case including portions thereof. 1.5. \"Incompatible With Secondary Licenses\" means (a) that the initial Contributor has attached the notice described in Exhibit B to the Covered Software; or (b) that the Covered Software was made available under the terms of version 1.1 or earlier of the License, but not also under the terms of a Secondary License. 1.6. \"Executable Form\" means any form of the work other than Source Code Form. 1.7. \"Larger Work\" means a work that combines Covered Software with other material, in a separate file or files, that is not Covered Software. 1.8. \"License\" means this document. 1.9. \"Licensable\" means having the right to grant, to the maximum extent possible, whether at the time of the initial grant or subsequently, any and all of the rights conveyed by this License. 1.10. \"Modifications\" means any of the following: (a) any file in Source Code Form that results from an addition to, deletion from, or modification of the contents of Covered Software; or (b) any new file in Source Code Form that contains any Covered Software. 1.11. \"Patent Claims\" of a Contributor means any patent claim(s), including without limitation, method, process, and apparatus claims, in any patent Licensable by such Contributor that would be infringed, but for the grant of the License, by the making, using, selling, offering for sale, having made, import, or transfer of either its Contributions or its Contributor Version. 1.12. \"Secondary License\" means either the GNU General Public License, Version 2.0, the GNU Lesser General Public License, Version 2.1, the GNU Affero General Public License, Version 3.0, or any later versions of those licenses. 1.13. \"Source Code Form\" means the form of the work preferred for making modifications. 1.14. \"You\" (or \"Your\") means an individual or a legal entity exercising rights under this License. For legal entities, \"You\" includes any entity that controls, is controlled by, or is under common control with You. For purposes of this definition, \"control\" means (a) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (b) ownership of more than fifty percent (50%) of the outstanding shares or beneficial ownership of such entity.","title":"1. Definitions"},{"location":"about/license/#2-license-grants-and-conditions","text":"2.1. Grants Each Contributor hereby grants You a world-wide, royalty-free, non-exclusive license: (a) under intellectual property rights (other than patent or trademark) Licensable by such Contributor to use, reproduce, make available, modify, display, perform, distribute, and otherwise exploit its Contributions, either on an unmodified basis, with Modifications, or as part of a Larger Work; and (b) under Patent Claims of such Contributor to make, use, sell, offer for sale, have made, import, and otherwise transfer either its Contributions or its Contributor Version. 2.2. Effective Date The licenses granted in Section 2.1 with respect to any Contribution become effective for each Contribution on the date the Contributor first distributes such Contribution. 2.3. Limitations on Grant Scope The licenses granted in this Section 2 are the only rights granted under this License. No additional rights or licenses will be implied from the distribution or licensing of Covered Software under this License. Notwithstanding Section 2.1(b) above, no patent license is granted by a Contributor: (a) for any code that a Contributor has removed from Covered Software; or (b) for infringements caused by: (i) Your and any other third party's modifications of Covered Software, or (ii) the combination of its Contributions with other software (except as part of its Contributor Version); or \u00a9 under Patent Claims infringed by Covered Software in the absence of its Contributions. This License does not grant any rights in the trademarks, service marks, or logos of any Contributor (except as may be necessary to comply with the notice requirements in Section 3.4). 2.4. Subsequent Licenses No Contributor makes additional grants as a result of Your choice to distribute the Covered Software under a subsequent version of this License (see Section 10.2) or under the terms of a Secondary License (if permitted under the terms of Section 3.3). 2.5. Representation Each Contributor represents that the Contributor believes its Contributions are its original creation(s) or it has sufficient rights to grant the rights to its Contributions conveyed by this License. 2.6. Fair Use This License is not intended to limit any rights You have under applicable copyright doctrines of fair use, fair dealing, or other equivalents. 2.7. Conditions Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted in Section 2.1.","title":"2. License Grants and Conditions"},{"location":"about/license/#3-responsibilities","text":"3.1. Distribution of Source Form All distribution of Covered Software in Source Code Form, including any Modifications that You create or to which You contribute, must be under the terms of this License. You must inform recipients that the Source Code Form of the Covered Software is governed by the terms of this License, and how they can obtain a copy of this License. You may not attempt to alter or restrict the recipients' rights in the Source Code Form. 3.2. Distribution of Executable Form If You distribute Covered Software in Executable Form then: (a) such Covered Software must also be made available in Source Code Form, as described in Section 3.1, and You must inform recipients of the Executable Form how they can obtain a copy of such Source Code Form by reasonable means in a timely manner, at a charge no more than the cost of distribution to the recipient; and (b) You may distribute such Executable Form under the terms of this License, or sublicense it under different terms, provided that the license for the Executable Form does not attempt to limit or alter the recipients' rights in the Source Code Form under this License. 3.3. Distribution of a Larger Work You may create and distribute a Larger Work under terms of Your choice, provided that You also comply with the requirements of this License for the Covered Software. If the Larger Work is a combination of Covered Software with a work governed by one or more Secondary Licenses, and the Covered Software is not Incompatible With Secondary Licenses, this License permits You to additionally distribute such Covered Software under the terms of such Secondary License(s), so that the recipient of the Larger Work may, at their option, further distribute the Covered Software under the terms of either this License or such Secondary License(s). 3.4. Notices You may not remove or alter the substance of any license notices (including copyright notices, patent notices, disclaimers of warranty, or limitations of liability) contained within the Source Code Form of the Covered Software, except that You may alter any license notices to the extent required to remedy known factual inaccuracies. 3.5. Application of Additional Terms You may choose to offer, and to charge a fee for, warranty, support, indemnity or liability obligations to one or more recipients of Covered Software. However, You may do so only on Your own behalf, and not on behalf of any Contributor. You must make it absolutely clear that any such warranty, support, indemnity, or liability obligation is offered by You alone, and You hereby agree to indemnify every Contributor for any liability incurred by such Contributor as a result of warranty, support, indemnity or liability terms You offer. You may include additional disclaimers of warranty and limitations of liability specific to any jurisdiction.","title":"3. Responsibilities"},{"location":"about/license/#4-inability-to-comply-due-to-statute-or-regulation","text":"If it is impossible for You to comply with any of the terms of this License with respect to some or all of the Covered Software due to statute, judicial order, or regulation then You must: (a) comply with the terms of this License to the maximum extent possible; and (b) describe the limitations and the code they affect. Such description must be placed in a text file included with all distributions of the Covered Software under this License. Except to the extent prohibited by statute or regulation, such description must be sufficiently detailed for a recipient of ordinary skill to be able to understand it.","title":"4. Inability to Comply Due to Statute or Regulation"},{"location":"about/license/#5-termination","text":"5.1. The rights granted under this License will terminate automatically if You fail to comply with any of its terms. However, if You become compliant, then the rights granted under this License from a particular Contributor are reinstated (a) provisionally, unless and until such Contributor explicitly and finally terminates Your grants, and (b) on an ongoing basis, if such Contributor fails to notify You of the non-compliance by some reasonable means prior to 60 days after You have come back into compliance. Moreover, Your grants from a particular Contributor are reinstated on an ongoing basis if such Contributor notifies You of the non-compliance by some reasonable means, this is the first time You have received notice of non-compliance with this License from such Contributor, and You become compliant prior to 30 days after Your receipt of the notice. 5.2. If You initiate litigation against any entity by asserting a patent infringement claim (excluding declaratory judgment actions, counter-claims, and cross-claims) alleging that a Contributor Version directly or indirectly infringes any patent, then the rights granted to You by any and all Contributors for the Covered Software under Section 2.1 of this License shall terminate. 5.3. In the event of termination under Sections 5.1 or 5.2 above, all end user license agreements (excluding distributors and resellers) which have been validly granted by You or Your distributors under this License prior to termination shall survive termination. * Disclaimer of Warranty * ------------------------- * * Covered Software is provided under this License on an \"as is\" * basis, without warranty of any kind, either expressed, implied, or * statutory, including, without limitation, warranties that the * Covered Software is free of defects, merchantable, fit for a * particular purpose or non-infringing. The entire risk as to the * quality and performance of the Covered Software is with You. * Should any Covered Software prove defective in any respect, You * (not any Contributor) assume the cost of any necessary servicing, * repair, or correction. This disclaimer of warranty constitutes an * essential part of this License. No use of any Covered Software is * authorized under this License except under this disclaimer. * * * Limitation of Liability * -------------------------- * * Under no circumstances and under no legal theory, whether tort * (including negligence), contract, or otherwise, shall any * Contributor, or anyone who distributes Covered Software as * permitted above, be liable to You for any direct, indirect, * special, incidental, or consequential damages of any character * including, without limitation, damages for lost profits, loss of * goodwill, work stoppage, computer failure or malfunction, or any * and all other commercial damages or losses, even if such party * shall have been informed of the possibility of such damages. This * limitation of liability shall not apply to liability for death or * personal injury resulting from such party's negligence to the * extent applicable law prohibits such limitation. Some * jurisdictions do not allow the exclusion or limitation of * incidental or consequential damages, so this exclusion and * limitation may not apply to You. * *","title":"5. Termination"},{"location":"about/license/#8-litigation","text":"Any litigation relating to this License may be brought only in the courts of a jurisdiction where the defendant maintains its principal place of business and such litigation shall be governed by laws of that jurisdiction, without reference to its conflict-of-law provisions. Nothing in this Section shall prevent a party's ability to bring cross-claims or counter-claims.","title":"8. Litigation"},{"location":"about/license/#9-miscellaneous","text":"This License represents the complete agreement concerning the subject matter hereof. If any provision of this License is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable. Any law or regulation which provides that the language of a contract shall be construed against the drafter shall not be used to construe this License against a Contributor.","title":"9. Miscellaneous"},{"location":"about/license/#10-versions-of-the-license","text":"10.1. New Versions Mozilla Foundation is the license steward. Except as provided in Section 10.3, no one other than the license steward has the right to modify or publish new versions of this License. Each version will be given a distinguishing version number. 10.2. Effect of New Versions You may distribute the Covered Software under the terms of the version of the License under which You originally received the Covered Software, or under the terms of any subsequent version published by the license steward. 10.3. Modified Versions If you create software not governed by this License, and you want to create a new license for such software, you may create and use a modified version of this License if you rename the license and remove any references to the name of the license steward (except to note that such modified license differs from this License). 10.4. Distributing Source Code Form that is Incompatible With Secondary Licenses If You choose to distribute Source Code Form that is Incompatible With Secondary Licenses under the terms of this version of the License, the notice described in Exhibit B of this License must be attached.","title":"10. Versions of the License"},{"location":"about/license/#exhibit-a-source-code-form-license-notice","text":"This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/ . If it is not possible or desirable to put the notice in a particular file, then You may include the notice in a location (such as a LICENSE file in a relevant directory) where a recipient would be likely to look for such a notice. You may add additional accurate notices of copyright ownership.","title":"Exhibit A - Source Code Form License Notice"},{"location":"about/license/#exhibit-b-incompatible-with-secondary-licenses-notice","text":"This Source Code Form is \"Incompatible With Secondary Licenses\", as defined by the Mozilla Public License, v. 2.0.","title":"Exhibit B - \"Incompatible With Secondary Licenses\" Notice"},{"location":"lessons/check-user-input-even/","text":"Lesson: Check User Input Evenness Create small Python program that reads an integer value from user input and prints if the input value is even or odd. Hint: Find out about the divmod(...) built-in function or the modulo operator.","title":"Check User Input Evenness"},{"location":"lessons/cmdline-calc/","text":"Lesson: Command Line Calculation Use Python as a \"command line calculator\" to calculate repayment plus compounded interest for - a yearly interest of 3%, - a duration of 3 years and - an investment of 91515 \u20ac.","title":"Command Line Calculation"},{"location":"lessons/customer/","text":"Lesson: Customers Class Create a class-hierarchy: Class Customer class-attribute: number of customers (which should increment with every new class-instance) class constructor with parameter: 'email', 'employees' instance-attribute: 'id' (number of the current value of 'number of customers') instance-attribute: 'email' instance-attribute: 'employees' (number of employees)) instance-method: 'getEmployees' (returning 'employees') Class Retail(Customer) private class attribute: '__type' initialized to 'Retail' class constructor with parameters: 'name', 'email', 'employees' private instance-attribute: '__retailname' (initialized with 'name'-parameter) instance-method: 'getRetailName' (returning private instance-attribute '__retailname') instance-method: 'getType' (returning private class attribute ' _type') Class Wholesale(Customer) private class attribute: '__type' initialized to 'Wholesale' class constructor with parameters: 'name', 'email', 'employees' private instance-attribute: '__wholesalename' (initialized with 'name'-parameter) instance-method: 'geWholesaleName' (returning private instance-attribute '__wholesalename') instance-method: 'getType' (returning private class attribute ' _type') 1.) Create a list of Customers of different types ('Retail'-customers and 'Wholesale'-customers) 2.) Iterate the list and output 'name', 'type', 'id' and 'employees' of each customer Hint: provide a callable interface __call__()","title":"Customer Class"},{"location":"lessons/gen-even-odd/","text":"Lesson: Generate even and odd numbers Write a generator that yields even natural numbers (infinitely, i.e. until interrupted with <Ctrl>-C ) Optionally, write a generator that yields even or uneven numbers, depending on a parameter that switches even/uneven behaviour. Optionall, write a generator that yields even or uneven numbers (switchable) up to an upper limit.","title":"Generate (Un)Even Numbers"},{"location":"lessons/hello-world/","text":"Lesson: Hello, world Starting out with >>> name = 'Ada' modiify print(\"Hello, world!\") so that it additionally writes out the name, in uppercase letters. Expected result: `Hello, world ADA!'","title":"Hello World"},{"location":"lessons/iter-file/","text":"Lesson: Iterate file Create a Python script that takes a file name/path as a command line argument opens a file using the built-in open() function uses a generator to iterate over the file's lines and yields these lines split by the ','-separator character and prints them to stdout (i.e. the console) Optional: Add a command line option that allows for setting the separator to another character. Optional 2: Add command line options to set an output file path and write the processed lines to this output file, joining the split lines with another \"target separator\" (also set with a command line option). Hint: Use the argparse stdlib library to parse the command line (see https://docs.python.org/3/howto/argparse.html ).","title":"Iterate File"},{"location":"lessons/list-modify/","text":"Lesson: List Modification Starting out with >>> l = [ 'Agathe' , 'Bauer' ] modify l by changing the 1 st element to \"I've\" changing the 2 nd lement to \"got\" extending l with a 3 rd element \"the power\" in-place, i.e. not by creating a new list object from l. Hint: You can use help([]) to see extensive documentation on list operations.","title":"List Modification"},{"location":"lessons/palindroms/","text":"Lesson: Check palindromes Create a function that takes a single string argument returns True if string is a palindrome, False otherwise (1) Use a loop for implementation (2) Try an alternative implementation using \"extended slicing\": Check word == word[::-1] test the function by calling it with a palindrome-word and a Optionally: Create a python script check_palindrom.py that asks the user to enter a word to be checked to be a palindrom python3 check_palindrom.py Please enter a word: abba word: abba - reversed-word: abba # optional output is_palindrom: abba ==> True python3 check_palindrom.py Please enter a word: foo word: foo - reversed-word: oof # optional output is_palindrom: foo ==> False Hint: use input() -builtin for user-input Optionally: Instead of user input provide a command line argument to your python script. Hint: Command line argument can be accessed using sys.argv .","title":"Check Palindromes"},{"location":"lessons/reverse-words/","text":"Lesson: Reverse Words Create a function that takes a single string argument and returns a string with the words of the original argument in reversed order E.g. when given \"Mary says hi\" the function returns \"hi says Mary\" . Optionally: Create a Python script reverse_words.py that takes a string command line argument and prints the words of this argument in reversed order. E.g. when executed as python3 reverse_words.py \"Mary says hi\" the program prints \"hi says Mary\" . Hint 1: You can access the command line arguments through sys.argv . Hint 2: Python features an extensive command line parsing library in the stlib: argparse . Optionally: Add options to the function and the script that allow for returning/printing the result string reversed or unreversed and that in all-uppercase, all-lowercase, titlecase or capitalized. Hint 3: Use help(\"\") or help(str) to learn useful string methods.","title":"Reverse Word Order"},{"location":"lessons/rewrite-dict-comp/","text":"Lesson: Rewrite dict comprehension Rewrite the dict comprehension d = { entry : 'dir' if os . path . isdir ( entry ) else 'file' if os . path . isfile ( entry ) else 'link' if os . path . islink ( entry ) else 'other' for entry in os . listdir ()} using a \"traditional\" for loop and if-else statements.","title":"Rewrite Dict Comprehension"},{"location":"python/python-history/","text":"A (very) brief selective history of Python # Python was first published in February 1991 by Dutch programmer Guido van Rossum . From the get-go Python had a focus on clean syntax, emphasized readability and was designed to be extensible. Early versions already show many of the core Python capabilities available in modern Python. In fact, looking at code running on really ancient Python doesn't actually feel very different . With its permissive F(L)OSS license and Guido turning out to be a highly competent Python community lead - lovingly and jokingly dubbed the \"Benevolent dictator for life\" (BDFL) , a role from which he stepped down in 2018 - Python found evolutionary language development, steady growth and application in very many domains. Since around 2012-2014 Python gained massive adoption in the scientific and data analytics world, boosting its popularity to unprecedented heights . For some historical perspective, here's the first public releases of other popular programming languages: C : 1972 C++ : 1985 JavaScript : 1995 Java : 1996 Go : 2009 Rust : 2010 Some subjectively selected Python milestones # Python 0.9.0 (1991) # 1 st public release ever, already with classes, exception handling, functions, basic types, modules. Python 1.0.0 (1994) # Python reaches 1.0! Selected highlights: double quotes allowed for strings as well as single quotes, lambda anonymous functions, map() , filter() , reduce() functions for functional programming support, range objects. Zope (1998) # Open source web application and content manager framework. Pioneers web object publishing and object database. Python 1.5.2 (1999) # Fondly remembered by some author(s) as their 1 st ever personally used Python version. Extremely stable run in production for many years. Python 1.6 (2000) # Unicode support: new unicode datatype. Python 2.0 (2000) # \"Python Enhancements Proposal\" (PEP) process established, list comprehensions. Python 2.2 (2001) # Unification of types (written in C) and classes (written in Python), \"new style classes\", generators. NumPy 1.0 (2006) # Python library for multi-dimensional array and matrix calculations. Previously Numeric, part/basis of SciPy . Python 2.7 (2010) # The last Python 2 minor release line. Python 3.0 (2008) # Aka \"Python 3000\" or \"Py3k\": Backward compatibility-breaking new major version: print is now a function, all text strings are unicode objects, function annotations (and many many more changes). Anaconda 0.8.0 (2012) # Data science Python distribution, package & environment manager. Python 2.7.18 (2020) # The last release of Python 2. Python 3.8.3 (2020) # The latest and greatest Python (at the time of writing).","title":"A brief history of Python"},{"location":"python/python-history/#a-very-brief-selective-history-of-python","text":"Python was first published in February 1991 by Dutch programmer Guido van Rossum . From the get-go Python had a focus on clean syntax, emphasized readability and was designed to be extensible. Early versions already show many of the core Python capabilities available in modern Python. In fact, looking at code running on really ancient Python doesn't actually feel very different . With its permissive F(L)OSS license and Guido turning out to be a highly competent Python community lead - lovingly and jokingly dubbed the \"Benevolent dictator for life\" (BDFL) , a role from which he stepped down in 2018 - Python found evolutionary language development, steady growth and application in very many domains. Since around 2012-2014 Python gained massive adoption in the scientific and data analytics world, boosting its popularity to unprecedented heights . For some historical perspective, here's the first public releases of other popular programming languages: C : 1972 C++ : 1985 JavaScript : 1995 Java : 1996 Go : 2009 Rust : 2010","title":"A (very) brief selective history of Python"},{"location":"python/python-history/#some-subjectively-selected-python-milestones","text":"","title":"Some subjectively selected Python milestones"},{"location":"python/python-history/#python-090-1991","text":"1 st public release ever, already with classes, exception handling, functions, basic types, modules.","title":"Python 0.9.0 (1991)"},{"location":"python/python-history/#python-100-1994","text":"Python reaches 1.0! Selected highlights: double quotes allowed for strings as well as single quotes, lambda anonymous functions, map() , filter() , reduce() functions for functional programming support, range objects.","title":"Python 1.0.0 (1994)"},{"location":"python/python-history/#zope-1998","text":"Open source web application and content manager framework. Pioneers web object publishing and object database.","title":"Zope (1998)"},{"location":"python/python-history/#python-152-1999","text":"Fondly remembered by some author(s) as their 1 st ever personally used Python version. Extremely stable run in production for many years.","title":"Python 1.5.2 (1999)"},{"location":"python/python-history/#python-16-2000","text":"Unicode support: new unicode datatype.","title":"Python 1.6 (2000)"},{"location":"python/python-history/#python-20-2000","text":"\"Python Enhancements Proposal\" (PEP) process established, list comprehensions.","title":"Python 2.0 (2000)"},{"location":"python/python-history/#python-22-2001","text":"Unification of types (written in C) and classes (written in Python), \"new style classes\", generators.","title":"Python 2.2 (2001)"},{"location":"python/python-history/#numpy-10-2006","text":"Python library for multi-dimensional array and matrix calculations. Previously Numeric, part/basis of SciPy .","title":"NumPy 1.0 (2006)"},{"location":"python/python-history/#python-27-2010","text":"The last Python 2 minor release line.","title":"Python 2.7 (2010)"},{"location":"python/python-history/#python-30-2008","text":"Aka \"Python 3000\" or \"Py3k\": Backward compatibility-breaking new major version: print is now a function, all text strings are unicode objects, function annotations (and many many more changes).","title":"Python 3.0 (2008)"},{"location":"python/python-history/#anaconda-080-2012","text":"Data science Python distribution, package & environment manager.","title":"Anaconda 0.8.0 (2012)"},{"location":"python/python-history/#python-2718-2020","text":"The last release of Python 2.","title":"Python 2.7.18 (2020)"},{"location":"python/python-history/#python-383-2020","text":"The latest and greatest Python (at the time of writing).","title":"Python 3.8.3 (2020)"},{"location":"python/python/","text":"Python? # The programming language - not the animal, not (quite) the Monty . But these days it uses a cute little \"two snakes\" logo , anyway. What is Python? # From the Python homepage ( www.python.org ): \"Python is an interpreted, interactive, object-oriented programming language.\" A bit more in-depth information # Hello world in Python # >>> print ( 'Hello, World!' ) Hello , World ! Python is interpreted # An interpreter is a computer program that directly/immediately executes programming language instructions. I.e. there's no such thing as an explicit separate compilation (to machine code step before program instructions can be run. 1 Python is interactive # Python has a so-called \" R ead- E val- P rint- L oop\" ( REPL ). That means that you can start the Python interpreter, type Python commands at its prompt and immediately see the results: Python 3.8 . 2 ( default , Feb 26 2020 , 02 : 56 : 10 ) >>> 1 + 1 2 Python is object-oriented # According to https://de.wikipedia.org/wiki/Objektorientierte_Programmierung : Alan Kay, inventor of Smalltalk and the term \u201eobject oriented\u201c, defined object-oriented in the context of Smalltalk as: \" 1. Everything is an object, 2. Objects communicate by sending and receiving messages (in terms of objects), 3. Objects have their own memory (in terms of objects), 4. Every object is an instance of a class (which must be an object), 5. The class holds the shared behavior for its instances (in the form of objects in a program list), 6. To eval a program list, control is passed to the first object and the remainder is treated as its message \" Python is also dynamic # The term \"dynamic\" isn't actually defined all too clearly. With regard to Python one could describe it with these capabilities: you can evaluate source code (e.g. from text strings) at runtime you can create new types or extend existing types (and use them) at runtime you can inspect (or \"introspect\") objects at runtime, i.e. get information about their type, data, operations and metadata Python is dynamically typed, not statically typed but strongly typed: >>> \"3\" + 5 Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : can only concatenate str ( not \"int\" ) to str The dynamic nature of Python makes it very flexible. 2 Python is multi-paradigm # Python supports multiple programming paradigms: Imperative (+ procedural) programming in Python # Programs are lists of instructions for the computer for processing the program's input (and alter program state) to achieve a program's goal; reusable units are defined as procedures. Object oriented programming # The program is modelled as objects that bundle data and possible operations (methods) on that data (that alter object and program state). Functional programming # Functions that take input and produce output are combined to solve a program's goal. Ideally, such functions do not maintain internal state or manipulate outer state; in pure(ly) functional languages (which Python is not!) the language enforces this no-side-effects approach. Who invented it? # See a brief history of Python . Do I need it? # See why should I use Python . Where to get it # Python is Free/Libre Open Source Software (F(L)OSS) and can be obtained here: www.python.org There is \"Python the lanuage\" and \"Python the implementation: Aside from the predominant reference implementation dubbed \"CPython\" several other implementations of Python the language exist, with varying degrees of version compatibility and adoption: PyPy Jython IronPython ...and probably others Furthermore, several Python distributions bundle Python, Python packages, external dependencies and additional tooling. A very prominent one is Anaconda , with major adoption in the data science world. As often, the lines are blurred though. Interpreters often implicitly \"compile\" to some form of intermediate \"bytecode\" or use \"just-in-time compilation\" to compile (parts of) the code, e.g. for performance reasons. \u21a9 But comes at a price: reasoning about Python code before runtime i.e. execution is hard which makes it difficult to apply optimizations like just-in-time compilation or transpile to less dynamic languages. \u21a9","title":"Python"},{"location":"python/python/#python","text":"The programming language - not the animal, not (quite) the Monty . But these days it uses a cute little \"two snakes\" logo , anyway.","title":"Python?"},{"location":"python/python/#what-is-python","text":"From the Python homepage ( www.python.org ): \"Python is an interpreted, interactive, object-oriented programming language.\"","title":"What is Python?"},{"location":"python/python/#a-bit-more-in-depth-information","text":"","title":"A bit more in-depth information"},{"location":"python/python/#hello-world-in-python","text":">>> print ( 'Hello, World!' ) Hello , World !","title":"Hello world in Python"},{"location":"python/python/#python-is-interpreted","text":"An interpreter is a computer program that directly/immediately executes programming language instructions. I.e. there's no such thing as an explicit separate compilation (to machine code step before program instructions can be run. 1","title":"Python is interpreted"},{"location":"python/python/#python-is-interactive","text":"Python has a so-called \" R ead- E val- P rint- L oop\" ( REPL ). That means that you can start the Python interpreter, type Python commands at its prompt and immediately see the results: Python 3.8 . 2 ( default , Feb 26 2020 , 02 : 56 : 10 ) >>> 1 + 1 2","title":"Python is interactive"},{"location":"python/python/#python-is-object-oriented","text":"According to https://de.wikipedia.org/wiki/Objektorientierte_Programmierung : Alan Kay, inventor of Smalltalk and the term \u201eobject oriented\u201c, defined object-oriented in the context of Smalltalk as: \" 1. Everything is an object, 2. Objects communicate by sending and receiving messages (in terms of objects), 3. Objects have their own memory (in terms of objects), 4. Every object is an instance of a class (which must be an object), 5. The class holds the shared behavior for its instances (in the form of objects in a program list), 6. To eval a program list, control is passed to the first object and the remainder is treated as its message \"","title":"Python is object-oriented"},{"location":"python/python/#python-is-also-dynamic","text":"The term \"dynamic\" isn't actually defined all too clearly. With regard to Python one could describe it with these capabilities: you can evaluate source code (e.g. from text strings) at runtime you can create new types or extend existing types (and use them) at runtime you can inspect (or \"introspect\") objects at runtime, i.e. get information about their type, data, operations and metadata Python is dynamically typed, not statically typed but strongly typed: >>> \"3\" + 5 Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : can only concatenate str ( not \"int\" ) to str The dynamic nature of Python makes it very flexible. 2","title":"Python is also dynamic"},{"location":"python/python/#python-is-multi-paradigm","text":"Python supports multiple programming paradigms:","title":"Python is multi-paradigm"},{"location":"python/python/#imperative-procedural-programming-in-python","text":"Programs are lists of instructions for the computer for processing the program's input (and alter program state) to achieve a program's goal; reusable units are defined as procedures.","title":"Imperative (+ procedural) programming in Python"},{"location":"python/python/#object-oriented-programming","text":"The program is modelled as objects that bundle data and possible operations (methods) on that data (that alter object and program state).","title":"Object oriented programming"},{"location":"python/python/#functional-programming","text":"Functions that take input and produce output are combined to solve a program's goal. Ideally, such functions do not maintain internal state or manipulate outer state; in pure(ly) functional languages (which Python is not!) the language enforces this no-side-effects approach.","title":"Functional programming"},{"location":"python/python/#who-invented-it","text":"See a brief history of Python .","title":"Who invented it?"},{"location":"python/python/#do-i-need-it","text":"See why should I use Python .","title":"Do I need it?"},{"location":"python/python/#where-to-get-it","text":"Python is Free/Libre Open Source Software (F(L)OSS) and can be obtained here: www.python.org There is \"Python the lanuage\" and \"Python the implementation: Aside from the predominant reference implementation dubbed \"CPython\" several other implementations of Python the language exist, with varying degrees of version compatibility and adoption: PyPy Jython IronPython ...and probably others Furthermore, several Python distributions bundle Python, Python packages, external dependencies and additional tooling. A very prominent one is Anaconda , with major adoption in the data science world. As often, the lines are blurred though. Interpreters often implicitly \"compile\" to some form of intermediate \"bytecode\" or use \"just-in-time compilation\" to compile (parts of) the code, e.g. for performance reasons. \u21a9 But comes at a price: reasoning about Python code before runtime i.e. execution is hard which makes it difficult to apply optimizations like just-in-time compilation or transpile to less dynamic languages. \u21a9","title":"Where to get it"},{"location":"python/why-python/","text":"Why should I learn (+ use) Python? # It's easy to use # Use the power of the REPL and try away: >>> print ( 'Python is easy to learn' ) Python is easy to learn Get built-in help: >>> help () Welcome to Python 3.6 's help utility! If this is your first time using Python , you should definitely check out the tutorial on the Internet at https : // docs . python . org / 3.6 / tutorial /. Enter the name of any module , keyword , or topic to get help on writing Python programs and using Python modules . To quit this help utility and return to the interpreter , just type \"quit\" . To get a list of available modules , keywords , symbols , or topics , type \"modules\" , \"keywords\" , \"symbols\" , or \"topics\" . Each module also comes with a one - line summary of what it does ; to list the modules whose name or summary contain a given string such as \"spam\" , type \"modules spam\" . help > Scale from simple, one-off scripts or even command line one-liners to world-class applications : python - c 'import math; print(math.sqrt(2))' 1.4142135623730951 Amongst many others, Dropbox, Google, Instagram, Spotify and YouTube have been known to run parts of their stack with Python , sometimes primarily using Python. Python also played an important role in getting the 1 st ever black hole image in 2019. It has many applications # Python is useful in many domains, from simple scripts to building web applications to image processing, number crunching and data science (and many many more) an excellent \"glue language\": easy integration of C/C++ code (or Rust, Go, Fortran, ...) a great rapid prototyping language: succinct no lengthy compilation a lot of \"batteries included\" (i.e. extensive standard library) extensible, i.e. in the need for speed you can write performance critical code as e.g. a C extension (but more often than not Python is just fast enough, anyway) It has excellent documentation & a great community # Simply take at look at https://docs.python.org/ and https://www.python.org/community/ . It is widely used & usage is growing rapidly # Currently the fastest growing / dominant language? Python ranks no. 1 on the PYPL PopularitY of Programming Language index (06/2020) ranks no. 2 (behind JavaScript) on the Redmonk Programming Language Rankings (01/2020) ranks no. 2 (behind JavaScript) in the GitHub octoverse report top languages (2019) huge uptake since around 2012-2014 in the scientific community and data science: machine learning AI statistical computing known to e.g. replace R and Matlab applications due to being user friendly and easy to learn, more flexible, extensible & general-purpose (i.e. apart from the data science-specific necessities the huge Python ecosystem of standard library and 3 rd party libraries is at your hands) used by a large and growing community may soon be the primary language of choice in the data science field (if it isn't already) It is (arguably) the most readable programming language (for many) # (Take this with more than a grain of salt - beauty is all in the eye of the beholder ) Readability is key: source code is read way more often than written (as in: reading other people's code for learning or review, reading your own code for refactoring/debugging/understanding what you did last month, ...) Python is \"executable pseudocode\" (to some): # pseudocode x := 1 IF x > 0 THEN print \"positive\" ELSE print \"negative or 0\" END IF # python x = 1 if x > 0 : print ( \"positive\" ) else : print ( \"negative or 0\" ) Python uses significant whitespace (indentation) for grouping code blocks (rather than {} braces), which makes it very readable for most people 1 Some \"Hello, world!\" examples # To each their own... Python print ( \"Hello, world!\" ) C #include <stdio.h> int main ( void ) { printf ( \"Hello, world! \\n \" ); return 0 ; } C++ #include <iostream> int main ( void ) { std :: cout << \"Hello, world!\" << std :: endl ; return 0 ; } Java class Hello { public static void main ( String [] args ) { System . out . print ( \"Hello, world!\" ); } } Go package main import \"fmt\" func main () { fmt . Println ( \"Hello, world!\" ) } Rust fn main () { println ! ( \"Hello, world\" ); } Though there's die-hard non-believers that will always hate this \u21a9","title":"Why Python?"},{"location":"python/why-python/#why-should-i-learn-use-python","text":"","title":"Why should I learn (+ use) Python?"},{"location":"python/why-python/#its-easy-to-use","text":"Use the power of the REPL and try away: >>> print ( 'Python is easy to learn' ) Python is easy to learn Get built-in help: >>> help () Welcome to Python 3.6 's help utility! If this is your first time using Python , you should definitely check out the tutorial on the Internet at https : // docs . python . org / 3.6 / tutorial /. Enter the name of any module , keyword , or topic to get help on writing Python programs and using Python modules . To quit this help utility and return to the interpreter , just type \"quit\" . To get a list of available modules , keywords , symbols , or topics , type \"modules\" , \"keywords\" , \"symbols\" , or \"topics\" . Each module also comes with a one - line summary of what it does ; to list the modules whose name or summary contain a given string such as \"spam\" , type \"modules spam\" . help > Scale from simple, one-off scripts or even command line one-liners to world-class applications : python - c 'import math; print(math.sqrt(2))' 1.4142135623730951 Amongst many others, Dropbox, Google, Instagram, Spotify and YouTube have been known to run parts of their stack with Python , sometimes primarily using Python. Python also played an important role in getting the 1 st ever black hole image in 2019.","title":"It's easy to use"},{"location":"python/why-python/#it-has-many-applications","text":"Python is useful in many domains, from simple scripts to building web applications to image processing, number crunching and data science (and many many more) an excellent \"glue language\": easy integration of C/C++ code (or Rust, Go, Fortran, ...) a great rapid prototyping language: succinct no lengthy compilation a lot of \"batteries included\" (i.e. extensive standard library) extensible, i.e. in the need for speed you can write performance critical code as e.g. a C extension (but more often than not Python is just fast enough, anyway)","title":"It has many applications"},{"location":"python/why-python/#it-has-excellent-documentation-a-great-community","text":"Simply take at look at https://docs.python.org/ and https://www.python.org/community/ .","title":"It has excellent documentation &amp; a great community"},{"location":"python/why-python/#it-is-widely-used-usage-is-growing-rapidly","text":"Currently the fastest growing / dominant language? Python ranks no. 1 on the PYPL PopularitY of Programming Language index (06/2020) ranks no. 2 (behind JavaScript) on the Redmonk Programming Language Rankings (01/2020) ranks no. 2 (behind JavaScript) in the GitHub octoverse report top languages (2019) huge uptake since around 2012-2014 in the scientific community and data science: machine learning AI statistical computing known to e.g. replace R and Matlab applications due to being user friendly and easy to learn, more flexible, extensible & general-purpose (i.e. apart from the data science-specific necessities the huge Python ecosystem of standard library and 3 rd party libraries is at your hands) used by a large and growing community may soon be the primary language of choice in the data science field (if it isn't already)","title":"It is widely used &amp; usage is growing rapidly"},{"location":"python/why-python/#it-is-arguably-the-most-readable-programming-language-for-many","text":"(Take this with more than a grain of salt - beauty is all in the eye of the beholder ) Readability is key: source code is read way more often than written (as in: reading other people's code for learning or review, reading your own code for refactoring/debugging/understanding what you did last month, ...) Python is \"executable pseudocode\" (to some): # pseudocode x := 1 IF x > 0 THEN print \"positive\" ELSE print \"negative or 0\" END IF # python x = 1 if x > 0 : print ( \"positive\" ) else : print ( \"negative or 0\" ) Python uses significant whitespace (indentation) for grouping code blocks (rather than {} braces), which makes it very readable for most people 1","title":"It is (arguably) the most readable programming language (for many)"},{"location":"python/why-python/#some-hello-world-examples","text":"To each their own... Python print ( \"Hello, world!\" ) C #include <stdio.h> int main ( void ) { printf ( \"Hello, world! \\n \" ); return 0 ; } C++ #include <iostream> int main ( void ) { std :: cout << \"Hello, world!\" << std :: endl ; return 0 ; } Java class Hello { public static void main ( String [] args ) { System . out . print ( \"Hello, world!\" ); } } Go package main import \"fmt\" func main () { fmt . Println ( \"Hello, world!\" ) } Rust fn main () { println ! ( \"Hello, world\" ); } Though there's die-hard non-believers that will always hate this \u21a9","title":"Some \"Hello, world!\" examples"},{"location":"training/cheatsheet/","text":"Curious Python Course: Cheatsheet #","title":"Curious Python Course: Cheatsheet"},{"location":"training/cheatsheet/#curious-python-course-cheatsheet","text":"","title":"Curious Python Course: Cheatsheet"},{"location":"training/oddjob/","text":"Oddjob - Oddities, Stumbling Blocks & \"Warts\" # Mutable Function Arguments # This is something that bytes practically all Python developers at least once in their ventures. A not too ingeniouse example for this (as you obviously wouldn't really need that function in the first place) that illustrates the behaviour: >>> def append ( elem , sequence = []): ... \"\"\"Append elem to sequence and return the sequence. ... \"\"\" ... sequence . append ( elem ) ... return sequence >>> append ( 1 ) [ 1 ] >>> append ( 2 ) [ 1 , 2 ] >>> append ( 3 ) [ 1 , 2 , 3 ] >>> Note how the mutable default sequence=[] list argument is created at function definition time , not each time the function gets called. This can be counter-intuitive at the beginning but isn't really difficult to grasp. It can be annoying (linters actually often warn you if you do s.th. like it in a function definition) but it can also be (ab)used as a feature in cornercases, for keeping a certain state. To steer clear of unexpected results, mutable default arguments are usually best avoided. This can be done e.g. like so: >>> def append ( elem , sequence = None ): ... \"\"\"Append elem to sequence and return the sequence. ... \"\"\" ... sequence = [] if sequence is None else sequence ... sequence . append ( elem ) ... return sequence >>>","title":"Oddjob"},{"location":"training/oddjob/#oddjob-oddities-stumbling-blocks-warts","text":"","title":"Oddjob - Oddities, Stumbling Blocks &amp; \"Warts\""},{"location":"training/oddjob/#mutable-function-arguments","text":"This is something that bytes practically all Python developers at least once in their ventures. A not too ingeniouse example for this (as you obviously wouldn't really need that function in the first place) that illustrates the behaviour: >>> def append ( elem , sequence = []): ... \"\"\"Append elem to sequence and return the sequence. ... \"\"\" ... sequence . append ( elem ) ... return sequence >>> append ( 1 ) [ 1 ] >>> append ( 2 ) [ 1 , 2 ] >>> append ( 3 ) [ 1 , 2 , 3 ] >>> Note how the mutable default sequence=[] list argument is created at function definition time , not each time the function gets called. This can be counter-intuitive at the beginning but isn't really difficult to grasp. It can be annoying (linters actually often warn you if you do s.th. like it in a function definition) but it can also be (ab)used as a feature in cornercases, for keeping a certain state. To steer clear of unexpected results, mutable default arguments are usually best avoided. This can be done e.g. like so: >>> def append ( elem , sequence = None ): ... \"\"\"Append elem to sequence and return the sequence. ... \"\"\" ... sequence = [] if sequence is None else sequence ... sequence . append ( elem ) ... return sequence >>>","title":"Mutable Function Arguments"},{"location":"training/tutorial/","text":"A Curious Python Course: Tutorial # A little introduction to the language mainly by example, to show (some of) Python's main features. This tutorial refers to Python version 3. Python Documentation # If you need information way beyond what we can show you here, the (great!) official Python documentation can be found here: https://docs.python.org/3/index.html Getting a Python # See here for hints on Python installation . Starting the Python interpreter # For an interactive session simply type python or python3 in a console/shell of your computer ( $ -shell prompt on *nix-based systems): $ python Python 3 .6.5 ( default, Jun 28 2018 , 16 :00:48 ) [ GCC 4 .8.5 ] on linux Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information. >>> The first lines show the interpreter version, some information about the build environment of the interpreter (compiler version and platform) and the copyright information. The Python prompt >>> is signaling that the interpreter awaits user input. The version and copyright information on startup can be suppressed using the quiet-option -q . $ python -q >>> Note: From now on, whenever you see >>> ... -lines this means an example in an interactive Python session. Type in your 1.st Python statement. After pressing the <Enter> -key the interpreter will execute the statement, and in this case will show the result. >>> print ( \"Hello, world!\" ) Hello , world ! >>> After finishing the execution of the statement, the interpreter comes back to the prompt, awaiting the next input. If you enter a simple expression at the prompt (e.g. an integer or string literal and press <Enter> a string representation of the result gets printed: >>> \"Hello, world!\" 'Hello, world!' >>> 42 42 >>> An interactive session can be stopped by pressing <Ctrl>-D (Linux) or <Ctrl>-Z (Windows). A summary of the Python interpreter's commandline options can be listed with its help option -h . This will display the usage , the available commandline options and environment variables controlling the interpreter. Here's the output of a Python 3 interpreter on Linux: $python3 -h usage: python3 [option] ... [-c cmd | -m mod | file | -] [arg] ... Options and arguments (and corresponding environment variables): -b : issue warnings about str(bytes_instance), str(bytearray_instance) and comparing bytes/bytearray with str. (-bb: issue errors) -B : don't write .pyc files on import; also PYTHONDONTWRITEBYTECODE=x -c cmd : program passed in as string (terminates option list) -d : debug output from parser; also PYTHONDEBUG=x -E : ignore PYTHON* environment variables (such as PYTHONPATH) -h : print this help message and exit (also --help) -i : inspect interactively after running script; forces a prompt even if stdin does not appear to be a terminal; also PYTHONINSPECT=x -I : isolate Python from the user's environment (implies -E and -s) -m mod : run library module as a script (terminates option list) -O : remove assert and __debug__-dependent statements; add .opt-1 before .pyc extension; also PYTHONOPTIMIZE=x -OO : do -O changes and also discard docstrings; add .opt-2 before .pyc extension -q : don't print version and copyright messages on interactive startup -s : don't add user site directory to sys.path; also PYTHONNOUSERSITE -S : don't imply 'import site' on initialization -u : force the binary I/O layers of stdout and stderr to be unbuffered; stdin is always buffered; text I/O layer will be line-buffered; also PYTHONUNBUFFERED=x -v : verbose (trace import statements); also PYTHONVERBOSE=x can be supplied multiple times to increase verbosity -V : print the Python version number and exit (also --version) when given twice, print more information about the build -W arg : warning control; arg is action:message:category:module:lineno also PYTHONWARNINGS=arg -x : skip first line of source, allowing use of non-Unix forms of #!cmd -X opt : set implementation-specific option file : program read from script file - : program read from stdin (default; interactive mode if a tty) arg ...: arguments passed to program in sys.argv[1:] Other environment variables: PYTHONSTARTUP: file executed on interactive startup (no default) PYTHONPATH : ':'-separated list of directories prefixed to the default module search path. The result is sys.path. PYTHONHOME : alternate <prefix> directory (or <prefix>:<exec_prefix>). The default module search path uses <prefix>/lib/pythonX.X. PYTHONCASEOK : ignore case in 'import' statements (Windows). PYTHONIOENCODING: Encoding[:errors] used for stdin/stdout/stderr. PYTHONFAULTHANDLER: dump the Python traceback on fatal errors. PYTHONHASHSEED: if this variable is set to 'random', a random value is used to seed the hashes of str, bytes and datetime objects. It can also be set to an integer in the range [0,4294967295] to get hash values with a predictable seed. PYTHONMALLOC: set the Python memory allocators and/or install debug hooks on Python memory allocators. Use PYTHONMALLOC=debug to install debug hooks. Running a Python program # A program is built up of a sequence of python statements (i.e. the \"program code\" or \"code\"). This code can be entered at the Python prompt, in interactive mode, provided as a command line argument or stored in module files with the .py -extension. For simple, short ad-hoc one-liners it can be very handy to use command line string arguments: $ python -c \"print('Hello'); print('World')\" Hello World $ As shown you can use the semicolon to separate multiple statements. But typically, code is placed into Python source files named <module name>.py , in our case helloworld.py : print ( 'Hello, world!' ) The code can then be executed running the following command: $ python helloworld.py Hello, world! $ A Sample Python Program # This is a simple Python program that calculates the present value of a series of cashflows: \"\"\"Calculate the present value for a list of cash flows. \"\"\" cashflows = [ - 100 , - 2 , 3 , 6 , 8 , 110 ] rate = 0.03 # interest rate q = 1 + rate # discount factor present_value = 0 for ( i , cf ) in enumerate ( cashflows ): present_value += cf * q ** ( - i ) print ( 'Present value for {} and interest rate {} : \\n pv = {} ' . format ( cashflows , rate , present_value )) Running this program yields the following output: $ python3 src/present_value.py Present value for [-100, -2, 3, 6, 8, 110] and interest rate 0.03: pv = 8.371752776288233 This program exhibits the main building blocks of a Python program. Lesson: Command Line Calculation Use Python as a \"command line calculator\" to calculate repayment plus compounded interest for - a yearly interest of 3%, - a duration of 3 years and - an investment of 91515 \u20ac. Python Program Building Blocks # A program is built as a sequence of instructions. The basic building blocks of a Python program are: Expressions Operands and Operators Statements Comments So a program is a sequence of comments and statements a statement is either an 'executable instruction' ( do-something ) or an 'evaluable expression' ( compute-something ) an expression is built up from operands and operators Program Execution # Running a program can be described as a top-down line-by-line processing: evaluation of expressions and execution of statements. Variables and Assignments # Variables are one of the the key elements of programming languages. Allthough the implementation may differ, the key concept is the same: Providing named access to an area in memory holding data, which can be changed during program execution. In Python a variable is a name referencing an object in memory. You can create a variable with an assignment-statement: >>> a = 5 Python variables can be rebound by further assignments. At different points in time, the variable may refer to different objects, with different values and types of value. This makes Python a dynamically typed language. >>> a = 5 # create variable 'a' which is bound to integer object 5 >>> a # named access to object 5 >>> type ( a ) # the object named 'a' is of type 'int' < class ' int '> >>> a = 'foo' # rebind the variable to a different object >>> a 'foo' >>> type ( a ) # 'a' is now the name for an object of type 'str' < class ' str '> >>> It's all about data: Python Data Types and Python Objects # Python provides a bunch of popular data types. All data is represented as an object and has a type: >>> 'foo' 'foo' >>> type ( 'foo' ) # type built-in function returns an object's type < class ' str '> >>> isinstance ( 'foo' , str ) # isinstance tests if an object is of a certain type True >>> Strings - str # Strings are essential for handling text data: >>> 'Python knows text' 'Python knows text' >>> \"Python knows text\" # double-quoted is also allowed 'Python knows text' >>> # triple quoted text can span lines >>> \"\"\"Python ... knows ... text\"\"\" 'Python \\n knows \\n text' >>> Strings conveniently support many useful operations: >>> '' . join (( 'foo' , 'bar' )) # string concatenation using builtin method 'join()' 'foobar' >>> 'foo' + 'bar' # string concatenation using '+' operator 'foobar' >>> 'foobar' . upper () # copy of string in all-uppercase letters 'FOOBAR' >>> 'foo bar' . title () # copy of string in \"title case\" 'Foo Bar' Strings are sequences of characters indexed by integer values . You can use the indexes to access the individual characters : >>> 'foo bar' [ 0 ] # 1st character 'f' >>> 'foo bar' [ - 1 ] # last character 'r' >>> 'foo bar' [ 2 : 5 ] # slice of characters 'o b' >>> Strings have powerful formatting support: Using str.format : >>> ' {} says {} ' . format ( 'Peter' , 'hi' ) 'Peter says hi' >>> ' {person} says {statement} ' . format ( person = 'Mary' , statement = 'hey' ) 'Mary says hey' >>> A bit more oldschool: >>> ' %s says %s ' % ( 'Paul' , 'ho' ) 'Paul says ho' See https://pyformat.info/ for concise information on these topics. \"f-strings\" allow embedding expressions that get replaced with their values: >>> name , says = 'Patti' , 'yo' >>> f ' { name } says { says } ' 'Patti says yo' >>> Lesson: Hello, world Starting out with >>> name = 'Ada' modiify print(\"Hello, world!\") so that it additionally writes out the name, in uppercase letters. Expected result: `Hello, world ADA!' Numeric Data Types # Numeric data types represent numeric values. Python has the built-in numeric data types int and float that support the usual arithmetic operations. int is used for integers or \"whole\" numbers: >>> 1 1 >>> type ( 1 ) < class ' int '> Some basic integer operations: >>> 1 + 2 3 >>> ( 1 + 2 ) * 3 9 >>> 2 ** 5 32 >>> Fractional numbers are represented by float : >>> 1.2 1.2 >>> type ( 1.2 ) < class ' float '> Example float operations: >>> 1.1 + 1.2 2.3 >>> ( 1.1 + 1.2 ) * 3.0 6.8999999999999995 >>> 1.1 ** 2 1.2100000000000002 >>> As you'll have noticed float is not an exact data type . If you need more accuracy than float arithmetic supports the Python standard library also features a Decimal data type . Since Python 3.0 Python uses \"true division\". That means that integer division will result in float values: >>> 4 / 2 2.0 >>> 3 / 2 1.5 Depending on your needs you can also use \"floor\" division: >>> 4 // 2 2 >>> 3 // 2 1 >>> Lists - list # A Python list is an array of unnamed objects of (potentially) different types. >>> [ 1 , 'foo' , 3.14 ] [ 1 , 'foo' , 3.14 ] >>> type ([ 1 , 'foo' , 3.14 ]) < class ' list '> Similar to str list supports many useful sequence operations: >>> [ 1 , 'foo' , 3.14 ] # list of 3 elements [ 1 , 'foo' , 3.14 ] >>> [ 1 , 'foo' , 3.14 ] + [ 'bar' ] [ 1 , 'foo' , 3.14 , 'bar' ] >>> type ([ 1 , 'foo' , 3.14 ] + [ 'bar' ]) < class ' list '> >>> len ([ 1 , 'foo' , 3.14 ]) # get length of a list 3 >>> l = [ 1 , 'foo' , 3.14 ] >>> l [ 0 ] 1 >>> l [ - 1 ] 3.14 >>> l [ 0 : 1 ] [ 1 ] >>> l [ 0 : 2 ] [ 1 , 'foo' ] >>> l [ 1 :] [ 'foo' , 3.14 ] >>> l . insert ( 2 , 'bar' ) >>> l [ 1 , 'foo' , 'bar' , 3.14 ] >>> l . pop () 3.14 >>> l . index ( 'foo' ) 1 >>> del l [ 0 ] >>> l [ 'foo' , 'bar' ] >>> l [ 0 ] = 'bea' >>> l [ 'bea' , 'bar' ] >>> Lesson: List Modification Starting out with >>> l = [ 'Agathe' , 'Bauer' ] modify l by changing the 1 st element to \"I've\" changing the 2 nd lement to \"got\" extending l with a 3 rd element \"the power\" in-place, i.e. not by creating a new list object from l. Hint: You can use help([]) to see extensive documentation on list operations. Tuples - tuple # Tuples are pretty similar to lists. They can store unnamed objects of different type but opposed to Python lists, they are unchangeable, i.e elements can't be inserted, substituted or removed: >>> ( 1 , 'foo' , 3.14 ) ( 1 , 'foo' , 3.14 ) >>> type (( 1 , 'foo' , 3.14 )) < class ' tuple '> Example tuple operations: >>> len (( 1 , 'foo' , 3.14 )) # length of a tuple 3 >>> l = ( 1 , 'foo' , 3.14 ) >>> l [ 0 ] 1 >>> l [ - 1 ] 3.14 >>> l [ 0 : 2 ] ( 1 , 'foo' ) >>> l + ( 42 , ) # create a new extended tuple by concatenation ( 1 , 'foo' , 3.14 , 42 ) >>> del l [ 0 ] Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'tuple' object doesn 't support item deletion >>> l [ 0 ] = 'more' Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'tuple' object does not support item assignment >>> Dictionaries - dict # Dictionaries are a nearly ubiquituous data type in Python. Dictionaries are a \"mapping\" data type storing key-value data: >>> { 'name' : 'Paul' , 'age' : 26 , 'profession' : 'author' } { 'name' : 'Paul' , 'age' : 26 , 'profession' : 'author' } >>> type ({ 'name' : 'Paul' , 'age' : 26 , 'profession' : 'author' }) < class ' dict '> >>> Example dict operations: >>> d = { 'name' : 'Paul' , 'age' : 26 , 'profession' : 'author' } >>> d [ 'name' ] 'Paul' >>> d [ 'age' ] = 27 >>> list ( d . items ()) [( 'name' , 'Paul' ), ( 'age' , 27 ), ( 'profession' , 'author' )] >>> list ( d . keys ()) [ 'name' , 'age' , 'profession' ] >>> list ( d . values ()) [ 'Paul' , 27 , 'author' ] >>> del d [ 'age' ] >>> d { 'name' : 'Paul' , 'profession' : 'author' } >>> d . popitem () ( 'profession' , 'author' ) >>> d { 'name' : 'Paul' } >>> Sets - set # The Python set is a datatype similar to a mathematical set. It's a collection of unique objects, (potentially) of different types, and supports set operations like union , intersection and others. >>> { 1 , 2 , 'foo' } { 1 , 2 , 'foo' } >>> set ([ 1 , 2 , 'foo' ]) # create set from a list { 1 , 2 , 'foo' } >>> set (( 1 , 2 , 'foo' )) # create set from a tuple { 1 , 2 , 'foo' } >>> type ({ 1 , 2 , 'foo' }) < class ' set '> >>> set -example >>> set ([ 1 , 2 , 'foo' , 'foo' ]) # set from a list with a duplicate element { 1 , 2 , 'foo' } >>> set ([ 1 , 2 , 'foo' ]) & set ([ 1 , 2 ]) # intersection of 2 sets using '&'-operator { 1 , 2 } >>> >>> { 1 , 2 , 3 } . difference ({ 1 , 2 }) { 3 } >>> { 1 , 2 , 3 } . union ({ 1 , 2 , 4 }) { 1 , 2 , 3 , 4 } >>> { 1 , 2 , 3 } . intersection ({ 1 , 2 , 4 }) { 1 , 2 } >>> None - None # The Python None type is a built-in constant and frequently used as a \"null\"-object to denote the absence of a value. A very common use is as a default function argument. >>> None >>> type ( None ) < class ' NoneType '> >>> Boolean bool # The Python bool type has two built-in constants named False and True : >>> True True >>> type ( True ) >>> < class ' bool '> >>> Historically, bool is derived from int: >>> True + 1 2 >>> Input and Output # Programs serve a purpose, they follow the IPO-model: Input - Processing - Output Programs consume information (input), do some work (based on that input) and produce information (output). The input-side information can be 'raw data' or 'commands' (which tell the program what to do with the data). The output-side information can be 'computed data' or simple 'status information' describing the state of (individual) processing steps. Programs can consume and produce information from and to different channels. One kind of these channels is referred to as 'standard-input'/'standard-output' enabling a user to interactively provide input to and retrieve output from a program. In Python the builtin-functions input() and print() perform these basic tasks. Input-Example >>> # just echo the input >>> input ( 'Please enter your name: ' ) Please enter your name : Donald 'Donald' >>> or: >>> # store the input >>> name = input ( 'Please enter your name: ' ) Please enter your name : Donald >>> Output-Example >>> # print the stored input >>> print ( 'Hello %s ' % name ) Hello Donald >>> Combined Input/Output Example >>> print ( 'Hello %s ' % input ( 'Please enter your name: ' )) Please enter your name : Donald Hello Donald >>> Control Flow # Wikipedia describes control flow as follows: \"In computer science, control flow (or flow of control) is the order in which individual statements, instructions or function calls of an imperative program are executed or evaluated. The emphasis on explicit control flow distinguishes an imperative programming language from a declarative programming language.\" Python provides two kinds of 'explicit controls' affecting the order of execution: Choices Loops Choices # Choices are conditional controls, affecting the branches of execution according to a boolean condition. if-statements # Python provides different variations of if -statements: Simple if - example: >>> a = 1 >>> if a == 1 : ... print ( 'a is 1' ) ... a is 1 >>> if-elif - example: >>> a = 2 >>> if a == 1 : ... print ( 'a is 1' ) ... elif a == 2 : ... print ( 'a is 2' ) ... a is 2 >>> if-elif-else - example: >>> a = 3 >>> if a == 1 : ... print ( 'a is 1' ) ... elif a == 2 : ... print ( 'a is 2' ) ... else : ... print ( 'a is neither 1 nor 2' ) ... a is neither 1 nor 2 >>> Conditional Expressions # Python also supports Conditional expressions : >>> 1 if True else 0 1 >>> Loops # Loops are repetitive controls, affecting the number of iterations a code block is executed. for-statement # The Python for-statement can be viewed as a representative of what Wikipedia calls a count-controlled-loop . The number of repetitions in a for -loop is defined by the number elements of a (probably dynamically generated) sequence. for -loop example: >>> for elem in [ 1 , 2 , 3 ]: # number of elements in the list defines the number of repetitions ... print ( elem ) ... 1 2 3 >>> for -loops operate on iterables . while-statement # The Python while-statement can be viewed as a representative of what Wikipedia calls a condition-controlled-loop . In a while -loop a condition-variable is set before and changed within the while -loop. while -loop example >>> a = 1 >>> while a < 4 : ... print ( a ) ... a += 1 # change the condition-variable ... 1 2 3 >>> Functions # Functions are named code blocks providing a dedicated task (procedure) or \"calculation\" (function). Functions can have input parameters and return values, i.e. result values returned to the caller. A function is defined using the def -statement: >>> # function definition >>> def echo ( text ): # (1) function header ... # (2) function body ... print ( text ) # 1.st statement ... return # 2.nd statement ... >>> A function definition consists of a (1) function-header and a (2) function body. The function header beginning with the def keyword followed by the function name and a (potentially empty) list of comma-separated input parameters in parentheses, followed by a colon : . The function body consists of an indented code-block of statements. In an interactive session the ... ellipsis show that a (multi-line) code block is ongoing. A function is called simply using its function name followed by a list of comma-separated call parameters in parentheses: >>> # function call >>> echo ( \"Hello World\" ) Hello World >>> Functions can also be called using name parameters : >>> # function call >>> echo ( text = \"Hello World\" ) Hello World >>> Functions can be called repeatedly and therefore are a major building block of reusable code in imperative programinmg languages. Classes and Instances # Python allows user-defined data types called classes . Classes are type definitions which include data - so called attributes - and methods - functions that define the type-specific behaviour. Instances are objects created from classes. The following example demonstrates a simple class -definition, class-instantiations and common operations on class instances like attribute access and method call using the . -dot operator. class definition : >>> class MyDog : ... def __init__ ( self , name ): # class constructor ... self . name = name # instance-attribute ... def bark ( self ): # instance-method returning nothing ... print ( \"wuff\" ) ... >>> class instances and attribute/method access : >>> mydog = MyDog ( \"Django\" ) # create class instance >>> mydog . name # access instance-attribute using '.'-dot operator 'Django' >>> mydog . bark () # call instance-method using '.'-dot operator wuff >>> Exceptions # Python uses exceptions to communicate invalid (or impossible) operations aka runtime errors: >>> 1 + \"1\" Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : unsupported operand type ( s ) for + : 'int' and 'str' Such exceptions can be caught and handled: >>> try : ... myfile = open ( 'myfile.txt' , 'r' ) ... except FileNotFoundError as exc : ... print ( 'caught' , exc ) ... # ... (do some sensible handling of this situation here) ... caught [ Errno 2 ] No such file or directory : 'myfile.txt' >>> Modules & Packages # In addition to Python's built-ins, standard library and 3 rd party libraries can be used through Python's import mechanism: >>> import os >>> os . listdir () [ 'README.md' , '.git' , '.gitignore' , 'LICENSE' , 'mkdocs.yml' , 'docs' , '.github' , 'site' ] >>> You can modularize your own code using modules (files) and packages (directories of module files): def myfunc ( arg ): \"\"\"Return the answer to all questions. \"\"\" print ( arg ) return 42 Now you can reuse this functionality: >>> import mymodule >>> mymodule . myfunc ( \"I just called\" ) I just called 42 >>> Generators # A callable that doesn't return a single value but generates - possibly unlimited - values is called a generator. Generators yield values instead of returning values: >>> def gen ( limit =- 1 ): ... if limit < 0 : ... val = 0 ... while True : ... yield val ... val += 1 ... else : ... for val in range ( limit ): ... yield val ... >>> for i in gen ( 5 ): ... print ( i ) ... 0 1 2 3 4 For memory efficiency, these generated values are created on demand, in each iteration step, as opposed to pre-populating e.g. a large list. Lesson: Generate even and odd numbers Write a generator that yields even natural numbers (infinitely, i.e. until interrupted with <Ctrl>-C ) Optionally, write a generator that yields even or uneven numbers, depending on a parameter that switches even/uneven behaviour. Optionall, write a generator that yields even or uneven numbers (switchable) up to an upper limit. Comprehensions and Generator Expressions # List Comprehensions # List comprehensions are an elegant and powerful feature to populate lists using a syntax that very much feels like a mathematical set notation: >>> import os # operating system (OS) routines >>> dirs = [ entry for entry in os . listdir () if os . path . isdir ( entry )] >>> dirs [ '.git' , 'docs' , '.github' , 'site' ] >>> Generator Expressions # Similarly, one can use generator expressions that do not pre-populate a data structure but yield elements on demand: >>> import os >>> generate_dirs = ( entry for entry in os . listdir () if os . path . isdir ( entry )) >>> generate_dirs < generator object < genexpr > at 0x7fc61861de60 > >>> list ( generate_dirs ) [ '.git' , 'docs' , '.github' , 'site' ] >>> list ( generate_dirs ) # watch out: the generator has been \"exhausted\" [] Dict comprehensions # A dict comprehension can be used to create a dictionary: >>> import os >>> { entry : 'dir' if os . path . isdir ( entry ) else ... 'file' if os . path . isfile ( entry ) else ... 'link' if os . path . islink ( entry ) else ... 'other' ... for entry in os . listdir ()} { 'README.md' : 'file' , '.git' : 'dir' , '.gitignore' : 'file' , 'LICENSE' : 'file' , 'mkdocs.yml' : 'file' , 'docs' : 'dir' , '.github' : 'dir' , 'site' : 'dir' } >>> Lesson: Rewrite dict comprehension Rewrite the dict comprehension d = { entry : 'dir' if os . path . isdir ( entry ) else 'file' if os . path . isfile ( entry ) else 'link' if os . path . islink ( entry ) else 'other' for entry in os . listdir ()} using a \"traditional\" for loop and if-else statements.","title":"Tutorial"},{"location":"training/tutorial/#a-curious-python-course-tutorial","text":"A little introduction to the language mainly by example, to show (some of) Python's main features. This tutorial refers to Python version 3.","title":"A Curious Python Course: Tutorial"},{"location":"training/tutorial/#python-documentation","text":"If you need information way beyond what we can show you here, the (great!) official Python documentation can be found here: https://docs.python.org/3/index.html","title":"Python Documentation"},{"location":"training/tutorial/#getting-a-python","text":"See here for hints on Python installation .","title":"Getting a Python"},{"location":"training/tutorial/#starting-the-python-interpreter","text":"For an interactive session simply type python or python3 in a console/shell of your computer ( $ -shell prompt on *nix-based systems): $ python Python 3 .6.5 ( default, Jun 28 2018 , 16 :00:48 ) [ GCC 4 .8.5 ] on linux Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information. >>> The first lines show the interpreter version, some information about the build environment of the interpreter (compiler version and platform) and the copyright information. The Python prompt >>> is signaling that the interpreter awaits user input. The version and copyright information on startup can be suppressed using the quiet-option -q . $ python -q >>> Note: From now on, whenever you see >>> ... -lines this means an example in an interactive Python session. Type in your 1.st Python statement. After pressing the <Enter> -key the interpreter will execute the statement, and in this case will show the result. >>> print ( \"Hello, world!\" ) Hello , world ! >>> After finishing the execution of the statement, the interpreter comes back to the prompt, awaiting the next input. If you enter a simple expression at the prompt (e.g. an integer or string literal and press <Enter> a string representation of the result gets printed: >>> \"Hello, world!\" 'Hello, world!' >>> 42 42 >>> An interactive session can be stopped by pressing <Ctrl>-D (Linux) or <Ctrl>-Z (Windows). A summary of the Python interpreter's commandline options can be listed with its help option -h . This will display the usage , the available commandline options and environment variables controlling the interpreter. Here's the output of a Python 3 interpreter on Linux: $python3 -h usage: python3 [option] ... [-c cmd | -m mod | file | -] [arg] ... Options and arguments (and corresponding environment variables): -b : issue warnings about str(bytes_instance), str(bytearray_instance) and comparing bytes/bytearray with str. (-bb: issue errors) -B : don't write .pyc files on import; also PYTHONDONTWRITEBYTECODE=x -c cmd : program passed in as string (terminates option list) -d : debug output from parser; also PYTHONDEBUG=x -E : ignore PYTHON* environment variables (such as PYTHONPATH) -h : print this help message and exit (also --help) -i : inspect interactively after running script; forces a prompt even if stdin does not appear to be a terminal; also PYTHONINSPECT=x -I : isolate Python from the user's environment (implies -E and -s) -m mod : run library module as a script (terminates option list) -O : remove assert and __debug__-dependent statements; add .opt-1 before .pyc extension; also PYTHONOPTIMIZE=x -OO : do -O changes and also discard docstrings; add .opt-2 before .pyc extension -q : don't print version and copyright messages on interactive startup -s : don't add user site directory to sys.path; also PYTHONNOUSERSITE -S : don't imply 'import site' on initialization -u : force the binary I/O layers of stdout and stderr to be unbuffered; stdin is always buffered; text I/O layer will be line-buffered; also PYTHONUNBUFFERED=x -v : verbose (trace import statements); also PYTHONVERBOSE=x can be supplied multiple times to increase verbosity -V : print the Python version number and exit (also --version) when given twice, print more information about the build -W arg : warning control; arg is action:message:category:module:lineno also PYTHONWARNINGS=arg -x : skip first line of source, allowing use of non-Unix forms of #!cmd -X opt : set implementation-specific option file : program read from script file - : program read from stdin (default; interactive mode if a tty) arg ...: arguments passed to program in sys.argv[1:] Other environment variables: PYTHONSTARTUP: file executed on interactive startup (no default) PYTHONPATH : ':'-separated list of directories prefixed to the default module search path. The result is sys.path. PYTHONHOME : alternate <prefix> directory (or <prefix>:<exec_prefix>). The default module search path uses <prefix>/lib/pythonX.X. PYTHONCASEOK : ignore case in 'import' statements (Windows). PYTHONIOENCODING: Encoding[:errors] used for stdin/stdout/stderr. PYTHONFAULTHANDLER: dump the Python traceback on fatal errors. PYTHONHASHSEED: if this variable is set to 'random', a random value is used to seed the hashes of str, bytes and datetime objects. It can also be set to an integer in the range [0,4294967295] to get hash values with a predictable seed. PYTHONMALLOC: set the Python memory allocators and/or install debug hooks on Python memory allocators. Use PYTHONMALLOC=debug to install debug hooks.","title":"Starting the Python interpreter"},{"location":"training/tutorial/#running-a-python-program","text":"A program is built up of a sequence of python statements (i.e. the \"program code\" or \"code\"). This code can be entered at the Python prompt, in interactive mode, provided as a command line argument or stored in module files with the .py -extension. For simple, short ad-hoc one-liners it can be very handy to use command line string arguments: $ python -c \"print('Hello'); print('World')\" Hello World $ As shown you can use the semicolon to separate multiple statements. But typically, code is placed into Python source files named <module name>.py , in our case helloworld.py : print ( 'Hello, world!' ) The code can then be executed running the following command: $ python helloworld.py Hello, world! $","title":"Running a Python program"},{"location":"training/tutorial/#a-sample-python-program","text":"This is a simple Python program that calculates the present value of a series of cashflows: \"\"\"Calculate the present value for a list of cash flows. \"\"\" cashflows = [ - 100 , - 2 , 3 , 6 , 8 , 110 ] rate = 0.03 # interest rate q = 1 + rate # discount factor present_value = 0 for ( i , cf ) in enumerate ( cashflows ): present_value += cf * q ** ( - i ) print ( 'Present value for {} and interest rate {} : \\n pv = {} ' . format ( cashflows , rate , present_value )) Running this program yields the following output: $ python3 src/present_value.py Present value for [-100, -2, 3, 6, 8, 110] and interest rate 0.03: pv = 8.371752776288233 This program exhibits the main building blocks of a Python program. Lesson: Command Line Calculation Use Python as a \"command line calculator\" to calculate repayment plus compounded interest for - a yearly interest of 3%, - a duration of 3 years and - an investment of 91515 \u20ac.","title":"A Sample Python Program"},{"location":"training/tutorial/#python-program-building-blocks","text":"A program is built as a sequence of instructions. The basic building blocks of a Python program are: Expressions Operands and Operators Statements Comments So a program is a sequence of comments and statements a statement is either an 'executable instruction' ( do-something ) or an 'evaluable expression' ( compute-something ) an expression is built up from operands and operators","title":"Python Program Building Blocks"},{"location":"training/tutorial/#program-execution","text":"Running a program can be described as a top-down line-by-line processing: evaluation of expressions and execution of statements.","title":"Program Execution"},{"location":"training/tutorial/#variables-and-assignments","text":"Variables are one of the the key elements of programming languages. Allthough the implementation may differ, the key concept is the same: Providing named access to an area in memory holding data, which can be changed during program execution. In Python a variable is a name referencing an object in memory. You can create a variable with an assignment-statement: >>> a = 5 Python variables can be rebound by further assignments. At different points in time, the variable may refer to different objects, with different values and types of value. This makes Python a dynamically typed language. >>> a = 5 # create variable 'a' which is bound to integer object 5 >>> a # named access to object 5 >>> type ( a ) # the object named 'a' is of type 'int' < class ' int '> >>> a = 'foo' # rebind the variable to a different object >>> a 'foo' >>> type ( a ) # 'a' is now the name for an object of type 'str' < class ' str '> >>>","title":"Variables and Assignments"},{"location":"training/tutorial/#its-all-about-data-python-data-types-and-python-objects","text":"Python provides a bunch of popular data types. All data is represented as an object and has a type: >>> 'foo' 'foo' >>> type ( 'foo' ) # type built-in function returns an object's type < class ' str '> >>> isinstance ( 'foo' , str ) # isinstance tests if an object is of a certain type True >>>","title":"It's all about data: Python Data Types and Python Objects"},{"location":"training/tutorial/#strings-str","text":"Strings are essential for handling text data: >>> 'Python knows text' 'Python knows text' >>> \"Python knows text\" # double-quoted is also allowed 'Python knows text' >>> # triple quoted text can span lines >>> \"\"\"Python ... knows ... text\"\"\" 'Python \\n knows \\n text' >>> Strings conveniently support many useful operations: >>> '' . join (( 'foo' , 'bar' )) # string concatenation using builtin method 'join()' 'foobar' >>> 'foo' + 'bar' # string concatenation using '+' operator 'foobar' >>> 'foobar' . upper () # copy of string in all-uppercase letters 'FOOBAR' >>> 'foo bar' . title () # copy of string in \"title case\" 'Foo Bar' Strings are sequences of characters indexed by integer values . You can use the indexes to access the individual characters : >>> 'foo bar' [ 0 ] # 1st character 'f' >>> 'foo bar' [ - 1 ] # last character 'r' >>> 'foo bar' [ 2 : 5 ] # slice of characters 'o b' >>> Strings have powerful formatting support: Using str.format : >>> ' {} says {} ' . format ( 'Peter' , 'hi' ) 'Peter says hi' >>> ' {person} says {statement} ' . format ( person = 'Mary' , statement = 'hey' ) 'Mary says hey' >>> A bit more oldschool: >>> ' %s says %s ' % ( 'Paul' , 'ho' ) 'Paul says ho' See https://pyformat.info/ for concise information on these topics. \"f-strings\" allow embedding expressions that get replaced with their values: >>> name , says = 'Patti' , 'yo' >>> f ' { name } says { says } ' 'Patti says yo' >>> Lesson: Hello, world Starting out with >>> name = 'Ada' modiify print(\"Hello, world!\") so that it additionally writes out the name, in uppercase letters. Expected result: `Hello, world ADA!'","title":"Strings - str"},{"location":"training/tutorial/#numeric-data-types","text":"Numeric data types represent numeric values. Python has the built-in numeric data types int and float that support the usual arithmetic operations. int is used for integers or \"whole\" numbers: >>> 1 1 >>> type ( 1 ) < class ' int '> Some basic integer operations: >>> 1 + 2 3 >>> ( 1 + 2 ) * 3 9 >>> 2 ** 5 32 >>> Fractional numbers are represented by float : >>> 1.2 1.2 >>> type ( 1.2 ) < class ' float '> Example float operations: >>> 1.1 + 1.2 2.3 >>> ( 1.1 + 1.2 ) * 3.0 6.8999999999999995 >>> 1.1 ** 2 1.2100000000000002 >>> As you'll have noticed float is not an exact data type . If you need more accuracy than float arithmetic supports the Python standard library also features a Decimal data type . Since Python 3.0 Python uses \"true division\". That means that integer division will result in float values: >>> 4 / 2 2.0 >>> 3 / 2 1.5 Depending on your needs you can also use \"floor\" division: >>> 4 // 2 2 >>> 3 // 2 1 >>>","title":"Numeric Data Types"},{"location":"training/tutorial/#lists-list","text":"A Python list is an array of unnamed objects of (potentially) different types. >>> [ 1 , 'foo' , 3.14 ] [ 1 , 'foo' , 3.14 ] >>> type ([ 1 , 'foo' , 3.14 ]) < class ' list '> Similar to str list supports many useful sequence operations: >>> [ 1 , 'foo' , 3.14 ] # list of 3 elements [ 1 , 'foo' , 3.14 ] >>> [ 1 , 'foo' , 3.14 ] + [ 'bar' ] [ 1 , 'foo' , 3.14 , 'bar' ] >>> type ([ 1 , 'foo' , 3.14 ] + [ 'bar' ]) < class ' list '> >>> len ([ 1 , 'foo' , 3.14 ]) # get length of a list 3 >>> l = [ 1 , 'foo' , 3.14 ] >>> l [ 0 ] 1 >>> l [ - 1 ] 3.14 >>> l [ 0 : 1 ] [ 1 ] >>> l [ 0 : 2 ] [ 1 , 'foo' ] >>> l [ 1 :] [ 'foo' , 3.14 ] >>> l . insert ( 2 , 'bar' ) >>> l [ 1 , 'foo' , 'bar' , 3.14 ] >>> l . pop () 3.14 >>> l . index ( 'foo' ) 1 >>> del l [ 0 ] >>> l [ 'foo' , 'bar' ] >>> l [ 0 ] = 'bea' >>> l [ 'bea' , 'bar' ] >>> Lesson: List Modification Starting out with >>> l = [ 'Agathe' , 'Bauer' ] modify l by changing the 1 st element to \"I've\" changing the 2 nd lement to \"got\" extending l with a 3 rd element \"the power\" in-place, i.e. not by creating a new list object from l. Hint: You can use help([]) to see extensive documentation on list operations.","title":"Lists - list"},{"location":"training/tutorial/#tuples-tuple","text":"Tuples are pretty similar to lists. They can store unnamed objects of different type but opposed to Python lists, they are unchangeable, i.e elements can't be inserted, substituted or removed: >>> ( 1 , 'foo' , 3.14 ) ( 1 , 'foo' , 3.14 ) >>> type (( 1 , 'foo' , 3.14 )) < class ' tuple '> Example tuple operations: >>> len (( 1 , 'foo' , 3.14 )) # length of a tuple 3 >>> l = ( 1 , 'foo' , 3.14 ) >>> l [ 0 ] 1 >>> l [ - 1 ] 3.14 >>> l [ 0 : 2 ] ( 1 , 'foo' ) >>> l + ( 42 , ) # create a new extended tuple by concatenation ( 1 , 'foo' , 3.14 , 42 ) >>> del l [ 0 ] Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'tuple' object doesn 't support item deletion >>> l [ 0 ] = 'more' Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'tuple' object does not support item assignment >>>","title":"Tuples - tuple"},{"location":"training/tutorial/#dictionaries-dict","text":"Dictionaries are a nearly ubiquituous data type in Python. Dictionaries are a \"mapping\" data type storing key-value data: >>> { 'name' : 'Paul' , 'age' : 26 , 'profession' : 'author' } { 'name' : 'Paul' , 'age' : 26 , 'profession' : 'author' } >>> type ({ 'name' : 'Paul' , 'age' : 26 , 'profession' : 'author' }) < class ' dict '> >>> Example dict operations: >>> d = { 'name' : 'Paul' , 'age' : 26 , 'profession' : 'author' } >>> d [ 'name' ] 'Paul' >>> d [ 'age' ] = 27 >>> list ( d . items ()) [( 'name' , 'Paul' ), ( 'age' , 27 ), ( 'profession' , 'author' )] >>> list ( d . keys ()) [ 'name' , 'age' , 'profession' ] >>> list ( d . values ()) [ 'Paul' , 27 , 'author' ] >>> del d [ 'age' ] >>> d { 'name' : 'Paul' , 'profession' : 'author' } >>> d . popitem () ( 'profession' , 'author' ) >>> d { 'name' : 'Paul' } >>>","title":"Dictionaries - dict"},{"location":"training/tutorial/#sets-set","text":"The Python set is a datatype similar to a mathematical set. It's a collection of unique objects, (potentially) of different types, and supports set operations like union , intersection and others. >>> { 1 , 2 , 'foo' } { 1 , 2 , 'foo' } >>> set ([ 1 , 2 , 'foo' ]) # create set from a list { 1 , 2 , 'foo' } >>> set (( 1 , 2 , 'foo' )) # create set from a tuple { 1 , 2 , 'foo' } >>> type ({ 1 , 2 , 'foo' }) < class ' set '> >>> set -example >>> set ([ 1 , 2 , 'foo' , 'foo' ]) # set from a list with a duplicate element { 1 , 2 , 'foo' } >>> set ([ 1 , 2 , 'foo' ]) & set ([ 1 , 2 ]) # intersection of 2 sets using '&'-operator { 1 , 2 } >>> >>> { 1 , 2 , 3 } . difference ({ 1 , 2 }) { 3 } >>> { 1 , 2 , 3 } . union ({ 1 , 2 , 4 }) { 1 , 2 , 3 , 4 } >>> { 1 , 2 , 3 } . intersection ({ 1 , 2 , 4 }) { 1 , 2 } >>>","title":"Sets - set"},{"location":"training/tutorial/#none-none","text":"The Python None type is a built-in constant and frequently used as a \"null\"-object to denote the absence of a value. A very common use is as a default function argument. >>> None >>> type ( None ) < class ' NoneType '> >>>","title":"None - None"},{"location":"training/tutorial/#boolean-bool","text":"The Python bool type has two built-in constants named False and True : >>> True True >>> type ( True ) >>> < class ' bool '> >>> Historically, bool is derived from int: >>> True + 1 2 >>>","title":"Boolean bool"},{"location":"training/tutorial/#input-and-output","text":"Programs serve a purpose, they follow the IPO-model: Input - Processing - Output Programs consume information (input), do some work (based on that input) and produce information (output). The input-side information can be 'raw data' or 'commands' (which tell the program what to do with the data). The output-side information can be 'computed data' or simple 'status information' describing the state of (individual) processing steps. Programs can consume and produce information from and to different channels. One kind of these channels is referred to as 'standard-input'/'standard-output' enabling a user to interactively provide input to and retrieve output from a program. In Python the builtin-functions input() and print() perform these basic tasks. Input-Example >>> # just echo the input >>> input ( 'Please enter your name: ' ) Please enter your name : Donald 'Donald' >>> or: >>> # store the input >>> name = input ( 'Please enter your name: ' ) Please enter your name : Donald >>> Output-Example >>> # print the stored input >>> print ( 'Hello %s ' % name ) Hello Donald >>> Combined Input/Output Example >>> print ( 'Hello %s ' % input ( 'Please enter your name: ' )) Please enter your name : Donald Hello Donald >>>","title":"Input and Output"},{"location":"training/tutorial/#control-flow","text":"Wikipedia describes control flow as follows: \"In computer science, control flow (or flow of control) is the order in which individual statements, instructions or function calls of an imperative program are executed or evaluated. The emphasis on explicit control flow distinguishes an imperative programming language from a declarative programming language.\" Python provides two kinds of 'explicit controls' affecting the order of execution: Choices Loops","title":"Control Flow"},{"location":"training/tutorial/#choices","text":"Choices are conditional controls, affecting the branches of execution according to a boolean condition.","title":"Choices"},{"location":"training/tutorial/#if-statements","text":"Python provides different variations of if -statements: Simple if - example: >>> a = 1 >>> if a == 1 : ... print ( 'a is 1' ) ... a is 1 >>> if-elif - example: >>> a = 2 >>> if a == 1 : ... print ( 'a is 1' ) ... elif a == 2 : ... print ( 'a is 2' ) ... a is 2 >>> if-elif-else - example: >>> a = 3 >>> if a == 1 : ... print ( 'a is 1' ) ... elif a == 2 : ... print ( 'a is 2' ) ... else : ... print ( 'a is neither 1 nor 2' ) ... a is neither 1 nor 2 >>>","title":"if-statements"},{"location":"training/tutorial/#conditional-expressions","text":"Python also supports Conditional expressions : >>> 1 if True else 0 1 >>>","title":"Conditional Expressions"},{"location":"training/tutorial/#loops","text":"Loops are repetitive controls, affecting the number of iterations a code block is executed.","title":"Loops"},{"location":"training/tutorial/#for-statement","text":"The Python for-statement can be viewed as a representative of what Wikipedia calls a count-controlled-loop . The number of repetitions in a for -loop is defined by the number elements of a (probably dynamically generated) sequence. for -loop example: >>> for elem in [ 1 , 2 , 3 ]: # number of elements in the list defines the number of repetitions ... print ( elem ) ... 1 2 3 >>> for -loops operate on iterables .","title":"for-statement"},{"location":"training/tutorial/#while-statement","text":"The Python while-statement can be viewed as a representative of what Wikipedia calls a condition-controlled-loop . In a while -loop a condition-variable is set before and changed within the while -loop. while -loop example >>> a = 1 >>> while a < 4 : ... print ( a ) ... a += 1 # change the condition-variable ... 1 2 3 >>>","title":"while-statement"},{"location":"training/tutorial/#functions","text":"Functions are named code blocks providing a dedicated task (procedure) or \"calculation\" (function). Functions can have input parameters and return values, i.e. result values returned to the caller. A function is defined using the def -statement: >>> # function definition >>> def echo ( text ): # (1) function header ... # (2) function body ... print ( text ) # 1.st statement ... return # 2.nd statement ... >>> A function definition consists of a (1) function-header and a (2) function body. The function header beginning with the def keyword followed by the function name and a (potentially empty) list of comma-separated input parameters in parentheses, followed by a colon : . The function body consists of an indented code-block of statements. In an interactive session the ... ellipsis show that a (multi-line) code block is ongoing. A function is called simply using its function name followed by a list of comma-separated call parameters in parentheses: >>> # function call >>> echo ( \"Hello World\" ) Hello World >>> Functions can also be called using name parameters : >>> # function call >>> echo ( text = \"Hello World\" ) Hello World >>> Functions can be called repeatedly and therefore are a major building block of reusable code in imperative programinmg languages.","title":"Functions"},{"location":"training/tutorial/#classes-and-instances","text":"Python allows user-defined data types called classes . Classes are type definitions which include data - so called attributes - and methods - functions that define the type-specific behaviour. Instances are objects created from classes. The following example demonstrates a simple class -definition, class-instantiations and common operations on class instances like attribute access and method call using the . -dot operator. class definition : >>> class MyDog : ... def __init__ ( self , name ): # class constructor ... self . name = name # instance-attribute ... def bark ( self ): # instance-method returning nothing ... print ( \"wuff\" ) ... >>> class instances and attribute/method access : >>> mydog = MyDog ( \"Django\" ) # create class instance >>> mydog . name # access instance-attribute using '.'-dot operator 'Django' >>> mydog . bark () # call instance-method using '.'-dot operator wuff >>>","title":"Classes and Instances"},{"location":"training/tutorial/#exceptions","text":"Python uses exceptions to communicate invalid (or impossible) operations aka runtime errors: >>> 1 + \"1\" Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : unsupported operand type ( s ) for + : 'int' and 'str' Such exceptions can be caught and handled: >>> try : ... myfile = open ( 'myfile.txt' , 'r' ) ... except FileNotFoundError as exc : ... print ( 'caught' , exc ) ... # ... (do some sensible handling of this situation here) ... caught [ Errno 2 ] No such file or directory : 'myfile.txt' >>>","title":"Exceptions"},{"location":"training/tutorial/#modules-packages","text":"In addition to Python's built-ins, standard library and 3 rd party libraries can be used through Python's import mechanism: >>> import os >>> os . listdir () [ 'README.md' , '.git' , '.gitignore' , 'LICENSE' , 'mkdocs.yml' , 'docs' , '.github' , 'site' ] >>> You can modularize your own code using modules (files) and packages (directories of module files): def myfunc ( arg ): \"\"\"Return the answer to all questions. \"\"\" print ( arg ) return 42 Now you can reuse this functionality: >>> import mymodule >>> mymodule . myfunc ( \"I just called\" ) I just called 42 >>>","title":"Modules &amp; Packages"},{"location":"training/tutorial/#generators","text":"A callable that doesn't return a single value but generates - possibly unlimited - values is called a generator. Generators yield values instead of returning values: >>> def gen ( limit =- 1 ): ... if limit < 0 : ... val = 0 ... while True : ... yield val ... val += 1 ... else : ... for val in range ( limit ): ... yield val ... >>> for i in gen ( 5 ): ... print ( i ) ... 0 1 2 3 4 For memory efficiency, these generated values are created on demand, in each iteration step, as opposed to pre-populating e.g. a large list. Lesson: Generate even and odd numbers Write a generator that yields even natural numbers (infinitely, i.e. until interrupted with <Ctrl>-C ) Optionally, write a generator that yields even or uneven numbers, depending on a parameter that switches even/uneven behaviour. Optionall, write a generator that yields even or uneven numbers (switchable) up to an upper limit.","title":"Generators"},{"location":"training/tutorial/#comprehensions-and-generator-expressions","text":"","title":"Comprehensions and Generator Expressions"},{"location":"training/tutorial/#list-comprehensions","text":"List comprehensions are an elegant and powerful feature to populate lists using a syntax that very much feels like a mathematical set notation: >>> import os # operating system (OS) routines >>> dirs = [ entry for entry in os . listdir () if os . path . isdir ( entry )] >>> dirs [ '.git' , 'docs' , '.github' , 'site' ] >>>","title":"List Comprehensions"},{"location":"training/tutorial/#generator-expressions","text":"Similarly, one can use generator expressions that do not pre-populate a data structure but yield elements on demand: >>> import os >>> generate_dirs = ( entry for entry in os . listdir () if os . path . isdir ( entry )) >>> generate_dirs < generator object < genexpr > at 0x7fc61861de60 > >>> list ( generate_dirs ) [ '.git' , 'docs' , '.github' , 'site' ] >>> list ( generate_dirs ) # watch out: the generator has been \"exhausted\" []","title":"Generator Expressions"},{"location":"training/tutorial/#dict-comprehensions","text":"A dict comprehension can be used to create a dictionary: >>> import os >>> { entry : 'dir' if os . path . isdir ( entry ) else ... 'file' if os . path . isfile ( entry ) else ... 'link' if os . path . islink ( entry ) else ... 'other' ... for entry in os . listdir ()} { 'README.md' : 'file' , '.git' : 'dir' , '.gitignore' : 'file' , 'LICENSE' : 'file' , 'mkdocs.yml' : 'file' , 'docs' : 'dir' , '.github' : 'dir' , 'site' : 'dir' } >>> Lesson: Rewrite dict comprehension Rewrite the dict comprehension d = { entry : 'dir' if os . path . isdir ( entry ) else 'file' if os . path . isfile ( entry ) else 'link' if os . path . islink ( entry ) else 'other' for entry in os . listdir ()} using a \"traditional\" for loop and if-else statements.","title":"Dict comprehensions"},{"location":"training/main-course/builtin-types/","text":"A practical Overview of Python Built-in Types # This chapter describes important properties of Python's built-in types. Python provides a bunch of popular data types. Simple types (also called primitive data types) as well as compound types , which are collections or containers of data of equal or different type. Each of the Python data types provide a data type-specific set of methods and operators that determine the data type's behaviour. This ensemble of data and behaviour defines the properties of all Python objects. For the complete list please refer to https://docs.python.org/3/library/stdtypes.html . Python builtin data types are Python classes themselves. Instances of nearly all Python builtin data-types can be created in two different ways: using a type-specific notation: literals in the case of simple data types or different kind of brackets ( , ) , [ , ] , { , } in the case of compound data-types using the data type's class constructor The type of a data-literal (or a variable referencing a data type holding that data-literal value) can be identified using the builtin type() -function. A type-test of a Python variable is done using buitlins isinstance() function Numeric datatypes # Integers - int # Example usage: >>> 1 1 >>> int () 0 >>> type ( 1 ) # type of int < class ' int '> >>> 1 + 2 # built-in '+'-operator for int 3 >>> type ( 1 + 2 ) # result type < class ' int '> >>> Floating Point Values - float # Example usage: >>> 1.2 1.2 >>> float () 0.0 >>> type ( 1.2 ) # type of float-literal < class ' float '> >>> 1.2 + 3.7 # built-in '+'-operator 4.9 >>> type ( 1.2 + 3.7 ) # result type < class ' float '> >>> Sequences # Sequences are indexed, ordered \"list data sets\" of objects: strings are immutable sequences of characters tuples are immutable sequences of arbitrary objects lists are mutable sequences of arbitrary objects Common Sequence Operations # # Length of sequence s denoted as N s [ i ] # item at sequence s index i s [ i : j ] # slice of s from i to j: s[i], ..., s[N-1] (a shallow copy) s [ i : j : k ] # slice of s from i to j with step k: s[i], s[i+k], ... len ( s ) # length of s: N min ( s ) # smallest item in s max ( s ) # biggest item in s s . index ( x [, i [, j ]]) # index of item x (between i and j, if given) s . count ( x ) # number of occurences of x in s x in s # True if an item in s equals x x not in s # False if an item in s equals x s1 + s2 # concatenation of s1 and s2 s * n # n-times concatenation of s n * s # - \" - Immutable Sequences # Strings - str # Strings are character sequences (of unicode characters): >>> s = 'text data is ubiquituous' >>> s1 , s2 = 'foo' , 'bar' >>> type ( s ) < class ' str '> >>> s [ 0 ] 't' >>> s [ 0 : 10 ] 'text data ' >>> s [ 0 : 10 : 2 ] 'tx aa' >>> len ( s ) 24 >>> min ( s ) ' ' >>> max ( s ) 'x' >>> s . index ( 'a' ) 6 >>> s . index ( 'data' , 0 , 10 ) # use of substrings is supported 5 >>> s . count ( 'is' ) 1 >>> 'data' in s True >>> 'data' not in s False >>> s1 + s2 'foobar' >>> s * 2 'text data is ubiquituoustext data is ubiquituous' >>> 2 * s 'text data is ubiquituoustext data is ubiquituous' >>> String Methods # str objects have plenty of additional functionality: ---------------------------------------------------------------------- # string s s.capitalize() -> str # capitalized (1st character uppercase, rest lowercase) copy of s ---------------------------------------------------------------------- s.casefold() -> str # \"casefolded\" copy of s (lowercase with replacement of \"caseless\" characters, # e.g. \"\u00df\" --> \"ss\" ---------------------------------------------------------------------- s.center(width[, fillchar]) -> str # s centered in width-length string, padded with fillchar (default blank) ---------------------------------------------------------------------- s.encode(encoding='utf-8', errors='strict') -> bytes # return s encoded to bytes object with encoding. ---------------------------------------------------------------------- s.endswith(suffix[, start[, end]]) -> bool # True if s ends with suffix, False otherwise. ---------------------------------------------------------------------- s.expandtabs(tabsize=8) -> str # tab-to-space-expanded copy of s ---------------------------------------------------------------------- s.find(sub[, start[, end]]) -> int # lowest index i is s where substring sub is found, -1 if not found. ---------------------------------------------------------------------- s.format(*args, **kwargs) -> str # return copy of s with the {}-format placeholders substituted by arguments ---------------------------------------------------------------------- s.format_map(mapping) -> str # return copy of s with the {}-format placeholders substituted from mapping ---------------------------------------------------------------------- s.isalnum() -> bool # True if all characters are alphanumeric and s is non-empty ---------------------------------------------------------------------- s.isalpha() -> bool # True if all characters are alphabetic and s is non-empty ---------------------------------------------------------------------- s.isdecimal() -> bool # True if all characters are decimal (can form numbers in base 10) and s is non-empty ---------------------------------------------------------------------- s.isdigit() -> bool # True if all characters are digits (includes sub-/superscripts) and s is non-empty ---------------------------------------------------------------------- s.isidentifier() -> bool # True if s qualifies as a valid identifier ---------------------------------------------------------------------- s.islower() -> bool # True if all characters are lowercase and s is non-empty ---------------------------------------------------------------------- s.isnumeric() -> bool # True if all characters are numeric (have Unicode numeric property) and s is non-empty ---------------------------------------------------------------------- s.isprintable() -> bool # True if all characters in S are printable ---------------------------------------------------------------------- s.isspace() -> bool # True is s is all-whitespace and s is non-empty ---------------------------------------------------------------------- s.istitle() -> bool # True is s is titlecased (each word in s starts uppercase and continues lowercase) and s is non-empty ---------------------------------------------------------------------- s.isupper() -> bool # True if s is all uppercase ---------------------------------------------------------------------- s.join(iterable) -> str # concatenate the strings in iterable with s as separator ---------------------------------------------------------------------- s.ljust(width[, fillchar]) -> str # return string of length starting with s (\"left-justified\"), padded with # fillchar; doesn't truncate s if len(s) > width ---------------------------------------------------------------------- s.lower() -> str # return all-lowercase copy of s ---------------------------------------------------------------------- s.lstrip([chars]) -> str # return copy of s with leading whitespace removed, or with each character in # chars removed from the beginning of s if chars is not None ---------------------------------------------------------------------- s.maketrans(x, y=None, z=None) -> dict # return translation table dictionary for str.translate(); a single argument # must be a ordinal/character-to-ordinal/string/None mapping dictionary; two # arguments must be strings of the same length (chars + replacement chars) ---------------------------------------------------------------------- s.partition(sep) -> (head, sep, tail) # return tuple (characters-before-sep, sep, characters-after sep) if separator # sep is found, otherwise (s, '', '') ---------------------------------------------------------------------- s.replace(old, new[, count]) -> str # copy of s with all occurences (up to count) of substring old replaced by new ---------------------------------------------------------------------- s.rfind(sub[, start[, end]]) -> int # return highest index where sub is found in s (between start and end), i.e. # \"search from the right\"; -1 if sub isn't found ---------------------------------------------------------------------- s.rindex(sub[, start[, end]]) -> int # return highest index where sub is found in s (between start and end), i.e. # \"search from the right\"; raise ValueError if sub is not found ---------------------------------------------------------------------- s.rjust(width[, fillchar]) -> str # return string of length ending with s (\"right-justified\"), padded with # fillchar; doesn't truncate s if len(s) > width ---------------------------------------------------------------------- s.rpartition(sep) -> (head, sep, tail) # return tuple (characters-before-sep, sep, characters-after sep) if separator # sep is found while searching from the end of s, otherwise (s, '', '') ---------------------------------------------------------------------- s.rsplit(sep=None, maxsplit=-1) -> list of strings # split s at separator s (up to maxsplit, searching from the end of s), return # the resulting list of words; split at any whitespace if sep is None (the # default) ---------------------------------------------------------------------- s.rstrip([chars]) -> str # return copy of s with trailing whitespace removed, or with each character in # chars removed from end of s if chars is not None ---------------------------------------------------------------------- s.split(sep=None, maxsplit=-1) -> list of strings # split s at separator s (up to maxsplit, searching from the start of s), # return the resulting list of words; split at any whitespace if sep is None # (the default) ---------------------------------------------------------------------- s.splitlines([keepends]) -> list of strings # return list of lines in s split at line boundaries ---------------------------------------------------------------------- s.startswith(prefix[, start[, end]]) -> bool # True is s startswith prefix (can be a tuple of prefixes) ---------------------------------------------------------------------- s.strip([chars]) -> str # return copy of s with leading + trailing whitespace removed, or with each # character in start and end of s, if chars is not None ---------------------------------------------------------------------- s.swapcase() -> str # return an case-inverted copy of s ---------------------------------------------------------------------- s.title() -> str # return a titlecased copy of s ---------------------------------------------------------------------- s.translate(table) -> str # return copy of s with all characters replaced according to # ordinal-to-ordinal/string/None mapping replacement table ---------------------------------------------------------------------- s.upper() -> str # return an all-uppercase copy of s ---------------------------------------------------------------------- s.zfill(width) -> str # return s right-justified and padded with zeros; never truncates Tuples - tuple # A Python list is an immutable sequence of arbitrary objects: >>> s = ( 'tuples' , 'contain' , 'objects' , 42 , 7.47 , { 'on' : True , 'off' : False }, >>> ( - 3 , 0 , 4 ), object ()) >>> s1 = ( 1 , 2 , 3 ) >>> s2 = ( 4.0 , 5.0 , 6.0 ) >>> type ( s ) < class ' tuple '> >>> s [ 0 ] 'tuples' >>> s [ 0 : 7 ] ( 'tuples' , 'contain' , 'objects' , 42 , 7.47 , { 'on' : True , 'off' : False }, ( - 3 , 0 , 4 )) >>> s [ 0 : 7 : 2 ] ( 'tuples' , 'objects' , 7.47 , ( - 3 , 0 , 4 )) >>> len ( s ) 8 >>> min ( s1 ) 1 >>> max ( s2 ) 6.0 >>> s . index ( 42 ) 3 >>> s . index ( 42 , 0 , 3 ) # will raise: 42 is not in this index range Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > ValueError : tuple . index ( x ): x not in tuple >>> s . count ( 42 ) 1 >>> 'objects' in s True >>> 'types' not in s True >>> s1 + s2 ( 1 , 2 , 3 , 4.0 , 5.0 , 6.0 ) >>> s1 * 2 ( 1 , 2 , 3 , 1 , 2 , 3 ) >>> 2 * s1 ( 1 , 2 , 3 , 1 , 2 , 3 ) >>> Mutable Sequences # Lists - list # A Python list is a mutable sequence of arbitrary objects. Common sequence operations on lists: >>> s = [ 'lists' , 'contain' , 'objects' , 42 , 7.47 , { 'on' : True , 'off' : False }, ( - 3 , 0 , 4 ), object ()] >>> s1 = [ 1 , 2 , 3 ] >>> s2 = [ 4.0 , 5.0 , 6.0 ] >>> s [ 0 ] 'lists' >>> s [ 0 : 7 ] [ 'lists' , 'contain' , 'objects' , 42 , 7.47 , { 'on' : True , 'off' : False }, ( - 3 , 0 , 4 )] >>> s [ 0 : 7 : 2 ] [ 'lists' , 'objects' , 7.47 , ( - 3 , 0 , 4 )] >>> len ( s ) 8 >>> min ( s1 ) 1 >>> max ( s2 ) 6.0 >>> s . index ( 42 ) 3 >>> s . index ( 42 , 0 , 3 ) # will raise: 42 is not in this index range Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > ValueError : 42 is not in list >>> s . count ( 42 ) 1 >>> 'objects' in s True >>> 'types' not in s True >>> s1 + s2 [ 1 , 2 , 3 , 4.0 , 5.0 , 6.0 ] >>> s1 * 2 [ 1 , 2 , 3 , 1 , 2 , 3 ] >>> 2 * s1 [ 1 , 2 , 3 , 1 , 2 , 3 ] >>> Additional Operations # # Length of sequence s denoted as N s [ i ] = x # set sequence s index i to x (replacing previous item) s [ i : j ] = iterable # replace slice of s from i to j with iterable contents s [ i : j : k ] = iterable # replace slice of s from i to j with step k with iterable contents s += iterable # extend sequence s with iterable contents del s [ i ] # remove item at i from s del s [ i : j ] # remove items from i to j del s [ i : j : k ] # remove items from i to j, step width k del s [:] # remove all items from s s . clear () # remove all items from s s . copy () # create a shallow copy of s s . extend ( iterable ) # extend sequence s with iterable contents s . insert ( i , x ) # insert x at index i (i.e. before item previously at i) s . pop ( i ) # remove item at i (default: -1, i.e. last item) s . remove ( x ) # remove the first item in s that equals x s . reverse () # reverse sequence items in-place s . sort () # sort list items in-place; opt. key function + reverse flag Additional modifying list operations: >>> s = [ 'lists' , 'contain' , 'objects' , 42 , 7.47 , { 'on' : True , 'off' : False }, >>> ( - 3 , 0 , 4 ), object ()] >>> s1 = [ 1 , 2 , 3 ] >>> s2 = [ 4.0 , 5.0 , 6.0 ] >>> s [ 0 ] = 'programs' >>> print ( s ) [ 'programs' , 'contain' , 'objects' , 42 , 7.47 , { 'on' : True , 'off' : False }, ( - 3 , 0 , 4 ), < object object at 0x7f6b7657e0c0 > ] >>> s . insert ( 2 , 'lots of' ) >>> print ( s ) [ 'programs' , 'contain' , 'lots of' , 'objects' , 42 , 7.47 , { 'on' : True , 'off' : False }, ( - 3 , 0 , 4 ), < object object at 0x7f6b7657e0c0 > ] >>> s [ 4 : 5 ] = [ 1999 , 2000 , 2001 ] >>> print ( s ) [ 'programs' , 'contain' , 'lots of' , 'objects' , 1999 , 2000 , 2001 , 7.47 , { 'on' : True , 'off' : False }, ( - 3 , 0 , 4 ), < object object at 0x7f6b7657e0c0 > ] >>> s [ 5 : - 1 ] = ( 'a' , 'b' , 'c' ) >>> print ( s ) [ 'programs' , 'contain' , 'lots of' , 'objects' , 1999 , 'a' , 'b' , 'c' , < object object at 0x7f6b7657e0c0 > ] >>> del s [ 0 ] >>> print ( s ) [ 'contain' , 'lots of' , 'objects' , 1999 , 'a' , 'b' , 'c' , < object object at 0x7f6b7657e0c0 > ] >>> del s [ 2 : 3 ] >>> print ( s ) [ 'contain' , 'lots of' , 1999 , 'a' , 'b' , 'c' , < object object at 0x7f6b7657e0c0 > ] >>> del s [ 0 : - 1 : 2 ] >>> print ( s ) [ 'lots of' , 'a' , 'c' , < object object at 0x7f6b7657e0c0 > ] >>> del s [:] # same as s.clear() >>> print ( s ) [] >>> print ( s . copy ()) [] >>> s . extend ( s1 ) >>> print ( s ) [ 1 , 2 , 3 ] >>> s += s2 >>> print ( s ) [ 1 , 2 , 3 , 4.0 , 5.0 , 6.0 ] >>> s . pop ( 0 ) 1 >>> print ( s ) [ 2 , 3 , 4.0 , 5.0 , 6.0 ] >>> s . remove ( 3 ) >>> print ( s ) [ 2 , 4.0 , 5.0 , 6.0 ] >>> s . reverse () >>> print ( s ) [ 6.0 , 5.0 , 4.0 , 2 ] >>> Hint: The Python standard library also provides an array -type where the objects are restricted to be of the same type, see Python Arrays . Dictionaries - dict # Dictionaries are mapping objects : a collection of objects indexed by key values. 1 Keys must be hashable objects which rules out certain mutable objects (e.g. a dict or a set cannot act as a dictionary key). Since Python 3.7 2 dictionary order is guaranteed to be insertion order, with updating a key not affecting order. Dictionaries support the following operations: # m is a dictionary (a \"mapping\") len ( m ) -> int # number of items in m m [ k ] -> object # value for key k in m; KeyError if no k m [ k ] = v # set value v for key k in mapping del m [ k ] # remove item with key k; KeyError if no k k in m -> bool # True if k is key in m m . clear () -> None # empty m i.e. remove all items m . copy () -> dict # shallow copy of m m . fromkeys ( iterable , value = None ) # create dict with keys from iterable, # values set to value. m . get ( k , d = None ) -> m [ k ] # m[k] if k in m, else d. m . items () -> dict_items ( m ) # iterable set-like object as a view on # m's items m . keys () -> dict_keys ( m ) # iterable set-like object as a view on # m's keys m . pop ( k , [, d ]) -> m [ k ] # remove key and return the corresponding # value; raise KeyError if k is not found # unless default d m . popitem () -> ( k , v ) # remove and return (key, value) pair #(LIFO); KeyError if m is empty m . setdefault ( k [, d ]) -> m . get ( k , d ) # Return m[k] if k in d else set D[k] = d # and return d m . update ( b [, ] ** kwargs ) # update m from dict/iterable (key, # value)-sequence b and kwargs m . values () -> dict_values ( m ) # iterable object as a view on m's values dict example >>> { 'name' : 'Paul' , 'age' : 26 , 'profession' : 'author' } { 'name' : 'Paul' , 'age' : 26 , 'profession' : 'author' } >>> type ({ 'name' : 'Paul' , 'age' : 26 , 'profession' : 'author' }) < class ' dict '> >>> dictionary-lookup Accessing individual elements of a dictionary m is done using the dictionary key-indexing-operator m.[key] >>> { 'name' : 'Paul' , 'age' : 26 , 'profession' : 'author' }[ 'name' ] 'Paul' >>> Sets - set # The Python set is a datatype according to the mathematical set theory it therefore is a collection of unique unnamed objects, probably of different types, and a set-operations like union , intersection and others. As opposed to the other Python builtin data types, set - type generation can only be done explicitly set - types generation >>> set ([ 1 , 2 , 'foo' ]) # explicit: 'set'- class constructor (1) using '[' ']' brackets { 1 , 2 , 'foo' } >>> set (( 1 , 2 , 'foo' )) # explicit: 'set'- class constructor (2) using '(' ')' brackets { 1 , 2 , 'foo' } set -example >>> set ([ 1 , 2 , 'foo' ]) # simple set with uniqe elements { 1 , 2 , 'foo' } >>> type ( set ([ 1 , 2 , 'foo' ])) # type of set < class ' set '> >>> set ([ 1 , 2 , 'foo' , 'foo' ]) # simple set with a non-uniqe element (getting dropped) { 1 , 2 , 'foo' } >>> type ( set ([ 1 , 2 , 'foo' , 'foo' ])) < class ' set '> >>> set ([ 1 , 2 , 'foo' ]) & set ([ 1 , 2 ]) # intersection of 2 sets using '&'-operator { 1 , 2 } >>> type ( set ([ 1 , 2 , 'foo' ]) & set ([ 1 , 2 ])) < class ' set '> >>> None - None # The Python None type is referred to as the Null -Object. It has a builtin contstant named None >>> None >>> type ( None ) < class ' NoneType '> >>> Boolean bool # The Python bool type has a two builtin constants named False an True >>> True True >>> type ( True ) >>> < class ' bool '> >>> Sometimes such objects are called \"hash table\" or \"associative array\". \u21a9 (C)Python 3.6 actually, but then an implementation detail rather than a language property. \u21a9","title":"Chapter 3: Built-in Types"},{"location":"training/main-course/builtin-types/#a-practical-overview-of-python-built-in-types","text":"This chapter describes important properties of Python's built-in types. Python provides a bunch of popular data types. Simple types (also called primitive data types) as well as compound types , which are collections or containers of data of equal or different type. Each of the Python data types provide a data type-specific set of methods and operators that determine the data type's behaviour. This ensemble of data and behaviour defines the properties of all Python objects. For the complete list please refer to https://docs.python.org/3/library/stdtypes.html . Python builtin data types are Python classes themselves. Instances of nearly all Python builtin data-types can be created in two different ways: using a type-specific notation: literals in the case of simple data types or different kind of brackets ( , ) , [ , ] , { , } in the case of compound data-types using the data type's class constructor The type of a data-literal (or a variable referencing a data type holding that data-literal value) can be identified using the builtin type() -function. A type-test of a Python variable is done using buitlins isinstance() function","title":"A practical Overview of Python Built-in Types"},{"location":"training/main-course/builtin-types/#numeric-datatypes","text":"","title":"Numeric datatypes"},{"location":"training/main-course/builtin-types/#integers-int","text":"Example usage: >>> 1 1 >>> int () 0 >>> type ( 1 ) # type of int < class ' int '> >>> 1 + 2 # built-in '+'-operator for int 3 >>> type ( 1 + 2 ) # result type < class ' int '> >>>","title":"Integers - int"},{"location":"training/main-course/builtin-types/#floating-point-values-float","text":"Example usage: >>> 1.2 1.2 >>> float () 0.0 >>> type ( 1.2 ) # type of float-literal < class ' float '> >>> 1.2 + 3.7 # built-in '+'-operator 4.9 >>> type ( 1.2 + 3.7 ) # result type < class ' float '> >>>","title":"Floating Point Values - float"},{"location":"training/main-course/builtin-types/#sequences","text":"Sequences are indexed, ordered \"list data sets\" of objects: strings are immutable sequences of characters tuples are immutable sequences of arbitrary objects lists are mutable sequences of arbitrary objects","title":"Sequences"},{"location":"training/main-course/builtin-types/#common-sequence-operations","text":"# Length of sequence s denoted as N s [ i ] # item at sequence s index i s [ i : j ] # slice of s from i to j: s[i], ..., s[N-1] (a shallow copy) s [ i : j : k ] # slice of s from i to j with step k: s[i], s[i+k], ... len ( s ) # length of s: N min ( s ) # smallest item in s max ( s ) # biggest item in s s . index ( x [, i [, j ]]) # index of item x (between i and j, if given) s . count ( x ) # number of occurences of x in s x in s # True if an item in s equals x x not in s # False if an item in s equals x s1 + s2 # concatenation of s1 and s2 s * n # n-times concatenation of s n * s # - \" -","title":"Common Sequence Operations"},{"location":"training/main-course/builtin-types/#immutable-sequences","text":"","title":"Immutable Sequences"},{"location":"training/main-course/builtin-types/#strings-str","text":"Strings are character sequences (of unicode characters): >>> s = 'text data is ubiquituous' >>> s1 , s2 = 'foo' , 'bar' >>> type ( s ) < class ' str '> >>> s [ 0 ] 't' >>> s [ 0 : 10 ] 'text data ' >>> s [ 0 : 10 : 2 ] 'tx aa' >>> len ( s ) 24 >>> min ( s ) ' ' >>> max ( s ) 'x' >>> s . index ( 'a' ) 6 >>> s . index ( 'data' , 0 , 10 ) # use of substrings is supported 5 >>> s . count ( 'is' ) 1 >>> 'data' in s True >>> 'data' not in s False >>> s1 + s2 'foobar' >>> s * 2 'text data is ubiquituoustext data is ubiquituous' >>> 2 * s 'text data is ubiquituoustext data is ubiquituous' >>>","title":"Strings - str"},{"location":"training/main-course/builtin-types/#string-methods","text":"str objects have plenty of additional functionality: ---------------------------------------------------------------------- # string s s.capitalize() -> str # capitalized (1st character uppercase, rest lowercase) copy of s ---------------------------------------------------------------------- s.casefold() -> str # \"casefolded\" copy of s (lowercase with replacement of \"caseless\" characters, # e.g. \"\u00df\" --> \"ss\" ---------------------------------------------------------------------- s.center(width[, fillchar]) -> str # s centered in width-length string, padded with fillchar (default blank) ---------------------------------------------------------------------- s.encode(encoding='utf-8', errors='strict') -> bytes # return s encoded to bytes object with encoding. ---------------------------------------------------------------------- s.endswith(suffix[, start[, end]]) -> bool # True if s ends with suffix, False otherwise. ---------------------------------------------------------------------- s.expandtabs(tabsize=8) -> str # tab-to-space-expanded copy of s ---------------------------------------------------------------------- s.find(sub[, start[, end]]) -> int # lowest index i is s where substring sub is found, -1 if not found. ---------------------------------------------------------------------- s.format(*args, **kwargs) -> str # return copy of s with the {}-format placeholders substituted by arguments ---------------------------------------------------------------------- s.format_map(mapping) -> str # return copy of s with the {}-format placeholders substituted from mapping ---------------------------------------------------------------------- s.isalnum() -> bool # True if all characters are alphanumeric and s is non-empty ---------------------------------------------------------------------- s.isalpha() -> bool # True if all characters are alphabetic and s is non-empty ---------------------------------------------------------------------- s.isdecimal() -> bool # True if all characters are decimal (can form numbers in base 10) and s is non-empty ---------------------------------------------------------------------- s.isdigit() -> bool # True if all characters are digits (includes sub-/superscripts) and s is non-empty ---------------------------------------------------------------------- s.isidentifier() -> bool # True if s qualifies as a valid identifier ---------------------------------------------------------------------- s.islower() -> bool # True if all characters are lowercase and s is non-empty ---------------------------------------------------------------------- s.isnumeric() -> bool # True if all characters are numeric (have Unicode numeric property) and s is non-empty ---------------------------------------------------------------------- s.isprintable() -> bool # True if all characters in S are printable ---------------------------------------------------------------------- s.isspace() -> bool # True is s is all-whitespace and s is non-empty ---------------------------------------------------------------------- s.istitle() -> bool # True is s is titlecased (each word in s starts uppercase and continues lowercase) and s is non-empty ---------------------------------------------------------------------- s.isupper() -> bool # True if s is all uppercase ---------------------------------------------------------------------- s.join(iterable) -> str # concatenate the strings in iterable with s as separator ---------------------------------------------------------------------- s.ljust(width[, fillchar]) -> str # return string of length starting with s (\"left-justified\"), padded with # fillchar; doesn't truncate s if len(s) > width ---------------------------------------------------------------------- s.lower() -> str # return all-lowercase copy of s ---------------------------------------------------------------------- s.lstrip([chars]) -> str # return copy of s with leading whitespace removed, or with each character in # chars removed from the beginning of s if chars is not None ---------------------------------------------------------------------- s.maketrans(x, y=None, z=None) -> dict # return translation table dictionary for str.translate(); a single argument # must be a ordinal/character-to-ordinal/string/None mapping dictionary; two # arguments must be strings of the same length (chars + replacement chars) ---------------------------------------------------------------------- s.partition(sep) -> (head, sep, tail) # return tuple (characters-before-sep, sep, characters-after sep) if separator # sep is found, otherwise (s, '', '') ---------------------------------------------------------------------- s.replace(old, new[, count]) -> str # copy of s with all occurences (up to count) of substring old replaced by new ---------------------------------------------------------------------- s.rfind(sub[, start[, end]]) -> int # return highest index where sub is found in s (between start and end), i.e. # \"search from the right\"; -1 if sub isn't found ---------------------------------------------------------------------- s.rindex(sub[, start[, end]]) -> int # return highest index where sub is found in s (between start and end), i.e. # \"search from the right\"; raise ValueError if sub is not found ---------------------------------------------------------------------- s.rjust(width[, fillchar]) -> str # return string of length ending with s (\"right-justified\"), padded with # fillchar; doesn't truncate s if len(s) > width ---------------------------------------------------------------------- s.rpartition(sep) -> (head, sep, tail) # return tuple (characters-before-sep, sep, characters-after sep) if separator # sep is found while searching from the end of s, otherwise (s, '', '') ---------------------------------------------------------------------- s.rsplit(sep=None, maxsplit=-1) -> list of strings # split s at separator s (up to maxsplit, searching from the end of s), return # the resulting list of words; split at any whitespace if sep is None (the # default) ---------------------------------------------------------------------- s.rstrip([chars]) -> str # return copy of s with trailing whitespace removed, or with each character in # chars removed from end of s if chars is not None ---------------------------------------------------------------------- s.split(sep=None, maxsplit=-1) -> list of strings # split s at separator s (up to maxsplit, searching from the start of s), # return the resulting list of words; split at any whitespace if sep is None # (the default) ---------------------------------------------------------------------- s.splitlines([keepends]) -> list of strings # return list of lines in s split at line boundaries ---------------------------------------------------------------------- s.startswith(prefix[, start[, end]]) -> bool # True is s startswith prefix (can be a tuple of prefixes) ---------------------------------------------------------------------- s.strip([chars]) -> str # return copy of s with leading + trailing whitespace removed, or with each # character in start and end of s, if chars is not None ---------------------------------------------------------------------- s.swapcase() -> str # return an case-inverted copy of s ---------------------------------------------------------------------- s.title() -> str # return a titlecased copy of s ---------------------------------------------------------------------- s.translate(table) -> str # return copy of s with all characters replaced according to # ordinal-to-ordinal/string/None mapping replacement table ---------------------------------------------------------------------- s.upper() -> str # return an all-uppercase copy of s ---------------------------------------------------------------------- s.zfill(width) -> str # return s right-justified and padded with zeros; never truncates","title":"String Methods"},{"location":"training/main-course/builtin-types/#tuples-tuple","text":"A Python list is an immutable sequence of arbitrary objects: >>> s = ( 'tuples' , 'contain' , 'objects' , 42 , 7.47 , { 'on' : True , 'off' : False }, >>> ( - 3 , 0 , 4 ), object ()) >>> s1 = ( 1 , 2 , 3 ) >>> s2 = ( 4.0 , 5.0 , 6.0 ) >>> type ( s ) < class ' tuple '> >>> s [ 0 ] 'tuples' >>> s [ 0 : 7 ] ( 'tuples' , 'contain' , 'objects' , 42 , 7.47 , { 'on' : True , 'off' : False }, ( - 3 , 0 , 4 )) >>> s [ 0 : 7 : 2 ] ( 'tuples' , 'objects' , 7.47 , ( - 3 , 0 , 4 )) >>> len ( s ) 8 >>> min ( s1 ) 1 >>> max ( s2 ) 6.0 >>> s . index ( 42 ) 3 >>> s . index ( 42 , 0 , 3 ) # will raise: 42 is not in this index range Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > ValueError : tuple . index ( x ): x not in tuple >>> s . count ( 42 ) 1 >>> 'objects' in s True >>> 'types' not in s True >>> s1 + s2 ( 1 , 2 , 3 , 4.0 , 5.0 , 6.0 ) >>> s1 * 2 ( 1 , 2 , 3 , 1 , 2 , 3 ) >>> 2 * s1 ( 1 , 2 , 3 , 1 , 2 , 3 ) >>>","title":"Tuples - tuple"},{"location":"training/main-course/builtin-types/#mutable-sequences","text":"","title":"Mutable Sequences"},{"location":"training/main-course/builtin-types/#lists-list","text":"A Python list is a mutable sequence of arbitrary objects. Common sequence operations on lists: >>> s = [ 'lists' , 'contain' , 'objects' , 42 , 7.47 , { 'on' : True , 'off' : False }, ( - 3 , 0 , 4 ), object ()] >>> s1 = [ 1 , 2 , 3 ] >>> s2 = [ 4.0 , 5.0 , 6.0 ] >>> s [ 0 ] 'lists' >>> s [ 0 : 7 ] [ 'lists' , 'contain' , 'objects' , 42 , 7.47 , { 'on' : True , 'off' : False }, ( - 3 , 0 , 4 )] >>> s [ 0 : 7 : 2 ] [ 'lists' , 'objects' , 7.47 , ( - 3 , 0 , 4 )] >>> len ( s ) 8 >>> min ( s1 ) 1 >>> max ( s2 ) 6.0 >>> s . index ( 42 ) 3 >>> s . index ( 42 , 0 , 3 ) # will raise: 42 is not in this index range Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > ValueError : 42 is not in list >>> s . count ( 42 ) 1 >>> 'objects' in s True >>> 'types' not in s True >>> s1 + s2 [ 1 , 2 , 3 , 4.0 , 5.0 , 6.0 ] >>> s1 * 2 [ 1 , 2 , 3 , 1 , 2 , 3 ] >>> 2 * s1 [ 1 , 2 , 3 , 1 , 2 , 3 ] >>>","title":"Lists - list"},{"location":"training/main-course/builtin-types/#additional-operations","text":"# Length of sequence s denoted as N s [ i ] = x # set sequence s index i to x (replacing previous item) s [ i : j ] = iterable # replace slice of s from i to j with iterable contents s [ i : j : k ] = iterable # replace slice of s from i to j with step k with iterable contents s += iterable # extend sequence s with iterable contents del s [ i ] # remove item at i from s del s [ i : j ] # remove items from i to j del s [ i : j : k ] # remove items from i to j, step width k del s [:] # remove all items from s s . clear () # remove all items from s s . copy () # create a shallow copy of s s . extend ( iterable ) # extend sequence s with iterable contents s . insert ( i , x ) # insert x at index i (i.e. before item previously at i) s . pop ( i ) # remove item at i (default: -1, i.e. last item) s . remove ( x ) # remove the first item in s that equals x s . reverse () # reverse sequence items in-place s . sort () # sort list items in-place; opt. key function + reverse flag Additional modifying list operations: >>> s = [ 'lists' , 'contain' , 'objects' , 42 , 7.47 , { 'on' : True , 'off' : False }, >>> ( - 3 , 0 , 4 ), object ()] >>> s1 = [ 1 , 2 , 3 ] >>> s2 = [ 4.0 , 5.0 , 6.0 ] >>> s [ 0 ] = 'programs' >>> print ( s ) [ 'programs' , 'contain' , 'objects' , 42 , 7.47 , { 'on' : True , 'off' : False }, ( - 3 , 0 , 4 ), < object object at 0x7f6b7657e0c0 > ] >>> s . insert ( 2 , 'lots of' ) >>> print ( s ) [ 'programs' , 'contain' , 'lots of' , 'objects' , 42 , 7.47 , { 'on' : True , 'off' : False }, ( - 3 , 0 , 4 ), < object object at 0x7f6b7657e0c0 > ] >>> s [ 4 : 5 ] = [ 1999 , 2000 , 2001 ] >>> print ( s ) [ 'programs' , 'contain' , 'lots of' , 'objects' , 1999 , 2000 , 2001 , 7.47 , { 'on' : True , 'off' : False }, ( - 3 , 0 , 4 ), < object object at 0x7f6b7657e0c0 > ] >>> s [ 5 : - 1 ] = ( 'a' , 'b' , 'c' ) >>> print ( s ) [ 'programs' , 'contain' , 'lots of' , 'objects' , 1999 , 'a' , 'b' , 'c' , < object object at 0x7f6b7657e0c0 > ] >>> del s [ 0 ] >>> print ( s ) [ 'contain' , 'lots of' , 'objects' , 1999 , 'a' , 'b' , 'c' , < object object at 0x7f6b7657e0c0 > ] >>> del s [ 2 : 3 ] >>> print ( s ) [ 'contain' , 'lots of' , 1999 , 'a' , 'b' , 'c' , < object object at 0x7f6b7657e0c0 > ] >>> del s [ 0 : - 1 : 2 ] >>> print ( s ) [ 'lots of' , 'a' , 'c' , < object object at 0x7f6b7657e0c0 > ] >>> del s [:] # same as s.clear() >>> print ( s ) [] >>> print ( s . copy ()) [] >>> s . extend ( s1 ) >>> print ( s ) [ 1 , 2 , 3 ] >>> s += s2 >>> print ( s ) [ 1 , 2 , 3 , 4.0 , 5.0 , 6.0 ] >>> s . pop ( 0 ) 1 >>> print ( s ) [ 2 , 3 , 4.0 , 5.0 , 6.0 ] >>> s . remove ( 3 ) >>> print ( s ) [ 2 , 4.0 , 5.0 , 6.0 ] >>> s . reverse () >>> print ( s ) [ 6.0 , 5.0 , 4.0 , 2 ] >>> Hint: The Python standard library also provides an array -type where the objects are restricted to be of the same type, see Python Arrays .","title":"Additional Operations"},{"location":"training/main-course/builtin-types/#dictionaries-dict","text":"Dictionaries are mapping objects : a collection of objects indexed by key values. 1 Keys must be hashable objects which rules out certain mutable objects (e.g. a dict or a set cannot act as a dictionary key). Since Python 3.7 2 dictionary order is guaranteed to be insertion order, with updating a key not affecting order. Dictionaries support the following operations: # m is a dictionary (a \"mapping\") len ( m ) -> int # number of items in m m [ k ] -> object # value for key k in m; KeyError if no k m [ k ] = v # set value v for key k in mapping del m [ k ] # remove item with key k; KeyError if no k k in m -> bool # True if k is key in m m . clear () -> None # empty m i.e. remove all items m . copy () -> dict # shallow copy of m m . fromkeys ( iterable , value = None ) # create dict with keys from iterable, # values set to value. m . get ( k , d = None ) -> m [ k ] # m[k] if k in m, else d. m . items () -> dict_items ( m ) # iterable set-like object as a view on # m's items m . keys () -> dict_keys ( m ) # iterable set-like object as a view on # m's keys m . pop ( k , [, d ]) -> m [ k ] # remove key and return the corresponding # value; raise KeyError if k is not found # unless default d m . popitem () -> ( k , v ) # remove and return (key, value) pair #(LIFO); KeyError if m is empty m . setdefault ( k [, d ]) -> m . get ( k , d ) # Return m[k] if k in d else set D[k] = d # and return d m . update ( b [, ] ** kwargs ) # update m from dict/iterable (key, # value)-sequence b and kwargs m . values () -> dict_values ( m ) # iterable object as a view on m's values dict example >>> { 'name' : 'Paul' , 'age' : 26 , 'profession' : 'author' } { 'name' : 'Paul' , 'age' : 26 , 'profession' : 'author' } >>> type ({ 'name' : 'Paul' , 'age' : 26 , 'profession' : 'author' }) < class ' dict '> >>> dictionary-lookup Accessing individual elements of a dictionary m is done using the dictionary key-indexing-operator m.[key] >>> { 'name' : 'Paul' , 'age' : 26 , 'profession' : 'author' }[ 'name' ] 'Paul' >>>","title":"Dictionaries - dict"},{"location":"training/main-course/builtin-types/#sets-set","text":"The Python set is a datatype according to the mathematical set theory it therefore is a collection of unique unnamed objects, probably of different types, and a set-operations like union , intersection and others. As opposed to the other Python builtin data types, set - type generation can only be done explicitly set - types generation >>> set ([ 1 , 2 , 'foo' ]) # explicit: 'set'- class constructor (1) using '[' ']' brackets { 1 , 2 , 'foo' } >>> set (( 1 , 2 , 'foo' )) # explicit: 'set'- class constructor (2) using '(' ')' brackets { 1 , 2 , 'foo' } set -example >>> set ([ 1 , 2 , 'foo' ]) # simple set with uniqe elements { 1 , 2 , 'foo' } >>> type ( set ([ 1 , 2 , 'foo' ])) # type of set < class ' set '> >>> set ([ 1 , 2 , 'foo' , 'foo' ]) # simple set with a non-uniqe element (getting dropped) { 1 , 2 , 'foo' } >>> type ( set ([ 1 , 2 , 'foo' , 'foo' ])) < class ' set '> >>> set ([ 1 , 2 , 'foo' ]) & set ([ 1 , 2 ]) # intersection of 2 sets using '&'-operator { 1 , 2 } >>> type ( set ([ 1 , 2 , 'foo' ]) & set ([ 1 , 2 ])) < class ' set '> >>>","title":"Sets - set"},{"location":"training/main-course/builtin-types/#none-none","text":"The Python None type is referred to as the Null -Object. It has a builtin contstant named None >>> None >>> type ( None ) < class ' NoneType '> >>>","title":"None - None"},{"location":"training/main-course/builtin-types/#boolean-bool","text":"The Python bool type has a two builtin constants named False an True >>> True True >>> type ( True ) >>> < class ' bool '> >>> Sometimes such objects are called \"hash table\" or \"associative array\". \u21a9 (C)Python 3.6 actually, but then an implementation detail rather than a language property. \u21a9","title":"Boolean bool"},{"location":"training/main-course/classes-instances/","text":"Be classy: Python Classes and Instances # Classes are the Python building block creating user-defined types in an object-oriented manner. Classes encapsulate data ('attributes') and appropriate functions ('methods'), which define the bahaviour of class-instances (i.e. objects of that class). Python supports 'composition' (\"has-a\"-relation) and (multiple-) 'inheritance' (\"is-a\"-relation) between classes/instances. In combination with 'method-overriding' and a special kind of 'polymorphism' ( Duck-Typing ), Python offers most of bunch of object-oriented features (Most, because Python doesn't really supports class privacy as explained below). Classes itself are objects, as such define a state (e.g. the __name__ attribute) and a behaviour (a set of methods) - the most common is the class-costructor, which creates instances of a class. Let's start with a simple class. Simple class # Simple classe typically have instance-attributes and instance-methods. instance attributes: each class instance has its own 'local' copy of its instance-atttributes instance-attributes are accessd using the . -dot operator: Pseudo-syntax <class-instance>.<instance-attribute> instance-methods: must be called with a class-instance instance-methods are accessed using the . -dot operator: Pseudo-syntax <class-instance>.<instance-method>(<params>) the 'class constructor' is named __init__() . The __init__() -method is not mandatory to create class-instances (that's the task of the __new__() -method , which is implicitly there. But practically the __init__() -method is always necessary to initialize the instance-attributes. To be more precisely: A class-instatiation is a 2-step process 1. creating the class ( __new__() )and 2. initialisation ( __init__() ). During a class-instantiation these 2-steps are implicitly performed by the interpreter. a class can define a destructor-mehod called __del__() , to explicitly do some finalizer tasks e.g. close ressources opened by the class-instance. The destructor is never called explicitly by user-code, instead its is called by the interpreters garbage collector, when the reference count (see Object Lifetime and Object Reference ) of the class instance reaches 0. For more details see del () . every instance-method need an explicit 1.st -parameter named self class definition example (1) >>> class A : pass ... >>> class __name__ - attribute >>> A . __name__ 'A' >>> class definition (2) >>> class A : ... def __init__ ( self , name ): # class constructor ... self . name = name # instance-attribute ... def getName ( self ): # instance method ... return self . name ... >>> class instantiation - attribute and method access >>> a1 = A ( 'A' ) >>> a1 . name # attribute-access using class-instance and '.'-dot operator 'A' >>> a1 . getName () # method-access using class-instance and '.'-dot operator 'A' >>> a . __class__ . __name__ # class-attribute 'A' >>> Note on self -parameter # During a instance-method call the python interpreter implicity converts (pseudocode) <class-instance-object>.<instance-method>(<param-1>, ... <param-n>) into <class-object>.<instance-method>(<class-instance-object>, <param-1>, ..., <param-n>) The self -argument is the class-instance-object iself. See also the section Instance methods auf the Python docs. The self -parameter is therefore similar to the this -pointer of C++ and Java: Python self : Explicit 1.st parameter in every instance-method C++ this -pointer: Implicit parameter to all member functions. It's a keyword holding a pointer to the current object Java this -reference: Implicit parameter of all member functions. It's a keyword holdung a reference to the current object Note: The name self is a convention , and could be changed, but it shouldn't, because it keeps's the code understandable. Class Privacy - private Attributes # Python doesen't provide any kind of 'access-specifiers' like e.g. C++ ( public , private , protected ) to control access to attributes or methods. I.e. attributes and methods are 'public' accessible. Python provides 2 weak forms of data-hiding (but no real protection by access-control) 'private-by-convention': Attributes prefixed with a single underscore _ should be regarded as a private attribute 'private-by-lexical-substitition': Attributes prefixed with double underscores __ like e.g. __foo will be implicitly renamed to _classname__foo by the interpreter. This textual substitution is called 'name-mangling'. As can be seen the following example this 'protections' can be bypassed: >>> class A : ... def __init__ ( self , name ): ... self . name = name ... self . _name = name # attribute 'private-by-convention' ... self . __name = name # attribute 'private-by-lexical-substitution' ... def getName ( self ): ... return self . name ... def _getName ( self ): ... return self . _name ... def __getName ( self ): ... return self . __name ... >>> usage >>> a = A ( \"ClassPrivacy\" ) >>> dir ( a ) [ '_A__getName' , '_A__name' , '__class__' , '__delattr__' , '__dict__' , '__dir__' , '__doc__' , '__eq__' , '__format__' , '__ge__' , '__getattribute__' , '__gt__' , '__hash__' , '__init__' , '__init_subclass__' , '__le__' , '__lt__' , '__module__' , '__ne__' , '__new__' , '__reduce__' , '__reduce_ex__' , '__repr__' , '__setattr__' , '__sizeof__' , '__str__' , '__subclasshook__' , '__weakref__' , '_getName' , '_name' , 'getName' , 'name' ] >>> a . name # (1) public attribute 'ClassPrivacy' >>> a . _name # (2) private-by-convention ==> still accessible 'ClassPrivacy' >>> a . __name # (3) private-by-lecical-convention ==> not accessible because it is not found Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > AttributeError : 'A' object has no attribute '__name' >>> a . getName () # (4) public method 'ClassPrivacy' >>> a . _getName () # (5) private-by-convention ==> still accessible/callable 'ClassPrivacy' >>> a . __getName () # (6) private-by-lexical-convention ==> not accessible because it is not found Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > AttributeError : 'A' object has no attribute '__getName' >>> a . _A__name # (7) bypass protection because you know the rule 'ClassPrivacy' >>> a . _A__getName () # (8) bypass protection because you know the rule 'ClassPrivacy' >>> For more details please refer to Private Variables Inheritance (\"is-a\"-relation) # Note on class privacy: As mentioned above, Python doesn't provide any real mechanism for class privacy, neither 'data-protection' nor 'data-hiding'. This also applies to class-inheritance. Inheritance is public by default, as a consequence all of the base-class attributes and methods are inherited by the derived-class class definition >>> class B ( A ): # class 'B' inherhits from class 'A' ... def __init__ ( self , name , number ): # class constructor ... A . __init__ ( self , name ) # call base-class initialisation-method ... self . number = number # instance variable ... def getNumber ( self ): # instance methode ... return self . number ... >>> class instantiation >>> b = B ( 'Inheritance' , 100 ) >>> b . name # attribute-access 'Inheritance' >>> b . getName () # method-access 'Inheritance' >>> b . number # attribute-access 100 >>> b . getNumber () # attribute-access 100 >>> Multiple Inheritance # Python also supports multiple inheritance class definition >>> class A : ... def __init__ ( self , name ): ... self . name = name ... def getName ( self ): ... return self . name ... >>> >>> class Z : ... def __init__ ( self , another_name ): ... self . another_name = another_name ... def getAnotherName ( self ): ... return self . another_name ... >>> >>> class B ( A , Z ): # multiple inheritance ... def __init__ ( self , name , another_name , number ): ... A . __init__ ( self , name ) # call base-class initialisation-method of class 'A' ... Z . __init__ ( self , another_name ) # call base-class initialisation-method of class 'Z' ... self . number = number ... def getNumber ( self ): ... return self . number ... >>> class instantiation >>> b = B ( 'BaseClass_A' , 'BaseClass_Z' , 100 ) >>> b . getNumber () 100 >>> b . getName () 'BaseClass_A' >>> b . getAnotherName () 'BaseClass_Z' >>> dir ( b ) [ '__class__' , '__delattr__' , '__dict__' , '__dir__' , '__doc__' , '__eq__' , '__format__' , '__ge__' , '__getattribute__' , '__gt__' , '__hash__' , '__init__' , '__init_subclass__' , '__le__' , '__lt__' , '__module__' , '__ne__' , '__new__' , '__reduce__' , '__reduce_ex__' , '__repr__' , '__setattr__' , '__sizeof__' , '__str__' , '__subclasshook__' , '__weakref__' , 'another_name' , 'getAnotherName' , 'getName' , 'getNumber' , 'name' , 'number' ] >>> Note: The dir(<object> )- builtin function lists all names in the namespace of the given object. As can be seen above all defined names of all base-class are in the namespace of the derived class. Composition (\"has-a\"-relation) # Python also support composition, i.e. a class 'B' has an instance-attribute pointing to an instance-attribute of class 'A' class definitions >>> class A : ... def __init__ ( self , name ): ... self . name = name ... def getName ( self ): ... return self . name ... >>> class B : ... def __init__ ( self , name , number ): ... self . a = A ( name ) # create a class 'A' (calling the constructor of class 'A') instance and old a reference to it (class 'B' \"has-a\" an instance-attribute of class 'A' ... self . number = number ... def getNumber ( self ): ... return self . number ... def getName ( self ): ... return self . a . getName () ... >>> class instantiation >>> b = B ( 'Composition' , 100 ) >>> b . getName () # (1): indirect access to instance-variable 'a' 'Composition' >>> b . a . getName () # (2): direct access to instance-variable 'a' 'Composition' >>> b . a . name # (3): direct access to instance-variable 'a' 'Composition' >>> b . getNumber () 100 >>> Class Attributes # As opposed to 'instance'-attributes 'class'-attributes are common to all class instances. class definition >>> class A : ... count = 0 ... def __init__ ( self , name ): ... self . name = name ... A . count += 1 ... >>> class instantiation >>> a1 = A ( 'A1' ) # 1.st instance increments class-attribute >>> a1 . count 1 >>> a2 = A ( 'A2' ) # 2.nd instance increments class-attribute >>> a2 . count 2 >>> a1 . count # Note: both instances share the same attribute 2 >>> >>> id ( a1 . count ) 140201179340160 >>> id ( a2 . count ) 140201179340160 >>> Class Properties # Ordinary Python instance-attributes are by default 'readable', 'writable' and 'deletable'. Python class properties ('property-attributes') are attributes with 'access-control', i.e. they can be designed to be 'readable', 'writeable' and 'deletable'. Python properties therefore are managed attributes. This is done with special getter -, setter - and deleter - methods which enables the properties to be accessed as ordinary atttributes (instead of a method-call). Usecase: Properties are a way of data encapusulation. Hiding ordinary attributes behind a 'property-interface/facade' introduces a level of indirection to the origin attribute. The origin attribute may change behind the scenes in keeping the user interface with the property-facade. The property can be seen as the user-interface, while the origin attribute is an implementation detail which is a subject to change. Python support two different ways of implementing properties: 'lower-level' using property() builtin function 'higher-level' using @propery -decorator The Python docs provide a good property-example , with read-, write- and delete-access. For convenience this is simply copied here. example using property() -builtin function class C : def __init__ ( self ): self . _x = None def getx ( self ): return self . _x def setx ( self , value ): self . _x = value def delx ( self ): del self . _x x = property ( getx , setx , delx , \"I'm the 'x' property.\" ) usage >>> p1 = C () >>> p1 . x = 1 # (1) set property value >>> p1 . x # (2) get property value 1 >>> del p1 . x # (3) delete property >>> p1 . x = 11 # (4) re-create property >>> p1 . x 11 example using the @propery -builtin decorator class C : def __init__ ( self ): self . _x = None @property def x ( self ): \"\"\"I'm the 'x' property.\"\"\" return self . _x @x . setter def x ( self , value ): self . _x = value @x . deleter def x ( self ): del self . _x usage >>> p1 = C () >>> p1 . x = 9 # (1) set property value >>> p1 . x # (2) get property value 9 >>> del p1 . x # (3) delete property >>> p1 . x = 99 # (4) re-create property >>> p1 . x 99 >>> * 'readonly property example * The above example stripped-down to be read-only: >>> class C : ... def __init__ ( self , x ): ... self . _x = x ... @property ... def x ( self ): ... return self . _x ... >>> usage >>> a = C ( 'foo' ) >>> a . x # (1) read access 'foo' >>> a . x = 'bar' # (2) write access Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > AttributeError : can 't set attribute >>> del a . x # (3) delete access Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > AttributeError : can 't delete attribute >>> Note: Property 'x' is read-only, write- and delete-access fail. Duck Typing # Statically typed languages like C++ use virtual function for runtime polymorphism. Derived classes therefore override base-class functions retaining their signature. When base-class objects, which hold a derived class reference, call their base-class function, the runtime will virtual dispatch the derived-class function. This allows programing on a abstract base-class level. But this is restricted to class-objects having an inheritance relationship. Pythons polymorphism is based on 'duck typing', where the polymorphism is not based on common types, instead it is based on common behaviour (methods) and attributes of the objects itself. See Wikipedia article on Duck typing : \"If it walks like a duck and it quacks like a duck, then it must be a duck\" This enable more architecural freedom on the program/class-design, because class-hierarchies can be breaked down and allow more loosely coupled program-design, as David M. Beazley writes in his Book \"Python Essential Reference (Fourth Edition)\". Special Methods # class methods # As opposed to instance-methods, class-methods operate on the class-object. Usecase: Python doesn't support method overloading like C++ or Java. Therefore multiple methods with the same name within a single class is not supported. As a consequence only a single class constructor ( __init__() -method) can be defined. With 'class-method's it's possible to overcome this. Python 'classc-methods' are defined using the @sclassmethod -decorator preceeding to the method-definition @classmethod -example >>> class ByteStringStore : ... encoding = 'utf-8' ... def __init__ ( self , bytestring ): ... self . bytestring = bytestring ... @classmethod ... def from_unicode ( cls , unicodestring ): ... return cls ( unicodestring . encode ( cls . encoding ) ... ... ) ... >>> a = ByteStringStore ( b 'abc' ) >>> b = ByteStringStore . from_unicode ( '\u00e4\u00f6\u00fc' ) >>> type ( a ) < class ' __main__ . ByteStringStore '> >>> type ( b ) < class ' __main__ . ByteStringStore '> >>> Static Methods # Python static-methods neither work on class-instance-objects nor on class-objects (that's the task of 'instance-method' and 'class-methods'). Python 'static-methods' can best be compared to module-functions, defined in the namespace of a class, instead of a modules-namespace. Usecase: Python 'static-methods' can be used for (utility-)functions that logical link to a class, but do not work on the class or their instaances itself Python 'static-methods' are defined using the @staticmethod -decorator preceeding to the method-definition @staticmethod -example >>> class A : ... @staticmethod ... def mystaticmethod (): ... print ( 'this is a staticmethod' ) ... >>> A . mystaticmethod () this is a staticmethod >>> Python @staticmethods are the correspondents to C++ and Java staticmethods, see the Python docs for classmethod Callable Classes # Callable classes are classes where the class-instances can simply be called as a function. Giving the class a callable-interface, their instances are callable. A class is made callable by defining a the special instance-method named __call__() ). Usecase: If different classes provide different instance-method names for the same functionality (e.g. A.getName() and B.getMyName() ), the usage for the programmers is cumbersome. If they want to get the name from the objects on the one hand they have to call a.getName() and on the other hand b.getMyName() . Making the classes callable, gives them a uniform interface, the name for both class-instance can be fetched in the same manner, simply using the object-name following parenthesis: a() and b() . Definition of a callable class >>> class CallableClass : ... name = None ... def __init__ ( self , name ): ... CallableClass . name = name ... def getName ( self ): ... print ( '>>> calling normal instance-method: %s () <<<' % self . getName . __name__ ) ... return CallableClass . name ... def __call__ ( self ): ... print ( '>>> calling special instance-method: %s () <<<' % self . __call__ . __name__ ) ... return CallableClass . name ... >>> Usage of a callable instance >>> foo = CallableClass ( 'foo' ) # (1) Create an instance of the callable class >>> print ( 'name = %s ' % foo . getName ()) # (2) use the 'standard'-class-interface instance-method 'getName()' >>> calling normal instance - method : getName () <<< name = foo >>> print ( 'name = %s ' % foo ()) # (3) use the 'callable'-class-interface instance-method '__call__()' >>> calling special instance - method : __call__ () <<< name = foo >>> Let's give it a try Lesson: Customers Class Create a class-hierarchy: Class Customer class-attribute: number of customers (which should increment with every new class-instance) class constructor with parameter: 'email', 'employees' instance-attribute: 'id' (number of the current value of 'number of customers') instance-attribute: 'email' instance-attribute: 'employees' (number of employees)) instance-method: 'getEmployees' (returning 'employees') Class Retail(Customer) private class attribute: '__type' initialized to 'Retail' class constructor with parameters: 'name', 'email', 'employees' private instance-attribute: '__retailname' (initialized with 'name'-parameter) instance-method: 'getRetailName' (returning private instance-attribute '__retailname') instance-method: 'getType' (returning private class attribute ' _type') Class Wholesale(Customer) private class attribute: '__type' initialized to 'Wholesale' class constructor with parameters: 'name', 'email', 'employees' private instance-attribute: '__wholesalename' (initialized with 'name'-parameter) instance-method: 'geWholesaleName' (returning private instance-attribute '__wholesalename') instance-method: 'getType' (returning private class attribute ' _type') 1.) Create a list of Customers of different types ('Retail'-customers and 'Wholesale'-customers) 2.) Iterate the list and output 'name', 'type', 'id' and 'employees' of each customer Hint: provide a callable interface __call__() Class Decorators # Decorators are explained in detail here . Here we just give a brief overview concerning decorating in the context of classes. Usecase Generally speaking a decorator is a 'wrappers' around functions or classes with the purpose of adding some functionality. Wrappers are callable object, see callable-class . So there are two parties in the decorating process: the decorator the object to be decorated Using a class as a decorator # In the following example we define a class as a decorator and define a function which is decorated with this 'class-decorator'. Class Decorator definition and function decoration >>> class MyDecorator : ... def __init__ ( self , func ): ... self . func = func ... def __call__ ( self , * args ): ... # put the additional functionalty here around the function ... print ( '==> START calling %s ()' % self . func . __name__ ) # some output before the wrapped function is called ... self . func ( * args ) # call the wrapped-function ... print ( '<== END calling %s ()' % self . func . __name__ ) # some output after the wrapped function is called ... >>> @MyDecorator ... def myfunc ( x ): ... print ( '>>> INSIDE decorated function: %s <<<' % x ) ... >>> function call >>> myfunc ( 'decorator-example' ) ==> START calling myfunc () >>> INSIDE decorated function : decorator - example <<< <== END calling myfunc () >>> Note: Here the class-decorator was used to provide some additional output, when the 'decorated' function is called. Decorating a class # In the following example we define a function as a decorator and define a class which is decorated with this 'function-decorator'. Note: Here the decorator works on class-definition level, providing some additional funtionality around the class-definition. For sure a rather infrequent usecase which can be classified in some sense as meta-programming. >>> def mydecoratorfunc ( cls ): ... print ( '>>> A new class was born: %s ' % cls ) ... return cls ... >>> @mydecoratorfunc ... class A : pass ... >>> A new class was born : < class ' __main__ . A '> >>> Class Testing # Python provides 2 builtin-function to identify/test the membership on class-instance-types. types() : Identifies the concrete class of the class-instance isinstance() : Testing the belonging to a certain type (along the class-hierarchy!) >>> class A (): pass ... >>> class B ( A ): pass ... >>> class C (): pass ... >>> a = A () >>> b = B () >>> c = C () >>> type ( a ) < class ' __main__ . A '> >>> type ( b ) < class ' __main__ . B '> >>> type ( c ) < class ' __main__ . C '> >>> isinstance ( a , A ) True >>> isinstance ( b , A ) # check along the inheritance-hierarchy True >>> isinstance ( c , B ) False MetaClasses # It should be mentioned that Python also supports techniques for meta-programming, for example to create metaclasses. But this is subject to advanced courses. Further readings on classes # Please refer to the Python docs about Classes .","title":"Chapter 5: Classes & Instances"},{"location":"training/main-course/classes-instances/#be-classy-python-classes-and-instances","text":"Classes are the Python building block creating user-defined types in an object-oriented manner. Classes encapsulate data ('attributes') and appropriate functions ('methods'), which define the bahaviour of class-instances (i.e. objects of that class). Python supports 'composition' (\"has-a\"-relation) and (multiple-) 'inheritance' (\"is-a\"-relation) between classes/instances. In combination with 'method-overriding' and a special kind of 'polymorphism' ( Duck-Typing ), Python offers most of bunch of object-oriented features (Most, because Python doesn't really supports class privacy as explained below). Classes itself are objects, as such define a state (e.g. the __name__ attribute) and a behaviour (a set of methods) - the most common is the class-costructor, which creates instances of a class. Let's start with a simple class.","title":"Be classy: Python Classes and Instances"},{"location":"training/main-course/classes-instances/#simple-class","text":"Simple classe typically have instance-attributes and instance-methods. instance attributes: each class instance has its own 'local' copy of its instance-atttributes instance-attributes are accessd using the . -dot operator: Pseudo-syntax <class-instance>.<instance-attribute> instance-methods: must be called with a class-instance instance-methods are accessed using the . -dot operator: Pseudo-syntax <class-instance>.<instance-method>(<params>) the 'class constructor' is named __init__() . The __init__() -method is not mandatory to create class-instances (that's the task of the __new__() -method , which is implicitly there. But practically the __init__() -method is always necessary to initialize the instance-attributes. To be more precisely: A class-instatiation is a 2-step process 1. creating the class ( __new__() )and 2. initialisation ( __init__() ). During a class-instantiation these 2-steps are implicitly performed by the interpreter. a class can define a destructor-mehod called __del__() , to explicitly do some finalizer tasks e.g. close ressources opened by the class-instance. The destructor is never called explicitly by user-code, instead its is called by the interpreters garbage collector, when the reference count (see Object Lifetime and Object Reference ) of the class instance reaches 0. For more details see del () . every instance-method need an explicit 1.st -parameter named self class definition example (1) >>> class A : pass ... >>> class __name__ - attribute >>> A . __name__ 'A' >>> class definition (2) >>> class A : ... def __init__ ( self , name ): # class constructor ... self . name = name # instance-attribute ... def getName ( self ): # instance method ... return self . name ... >>> class instantiation - attribute and method access >>> a1 = A ( 'A' ) >>> a1 . name # attribute-access using class-instance and '.'-dot operator 'A' >>> a1 . getName () # method-access using class-instance and '.'-dot operator 'A' >>> a . __class__ . __name__ # class-attribute 'A' >>>","title":"Simple class"},{"location":"training/main-course/classes-instances/#note-on-self-parameter","text":"During a instance-method call the python interpreter implicity converts (pseudocode) <class-instance-object>.<instance-method>(<param-1>, ... <param-n>) into <class-object>.<instance-method>(<class-instance-object>, <param-1>, ..., <param-n>) The self -argument is the class-instance-object iself. See also the section Instance methods auf the Python docs. The self -parameter is therefore similar to the this -pointer of C++ and Java: Python self : Explicit 1.st parameter in every instance-method C++ this -pointer: Implicit parameter to all member functions. It's a keyword holding a pointer to the current object Java this -reference: Implicit parameter of all member functions. It's a keyword holdung a reference to the current object Note: The name self is a convention , and could be changed, but it shouldn't, because it keeps's the code understandable.","title":"Note on self-parameter"},{"location":"training/main-course/classes-instances/#class-privacy-private-attributes","text":"Python doesen't provide any kind of 'access-specifiers' like e.g. C++ ( public , private , protected ) to control access to attributes or methods. I.e. attributes and methods are 'public' accessible. Python provides 2 weak forms of data-hiding (but no real protection by access-control) 'private-by-convention': Attributes prefixed with a single underscore _ should be regarded as a private attribute 'private-by-lexical-substitition': Attributes prefixed with double underscores __ like e.g. __foo will be implicitly renamed to _classname__foo by the interpreter. This textual substitution is called 'name-mangling'. As can be seen the following example this 'protections' can be bypassed: >>> class A : ... def __init__ ( self , name ): ... self . name = name ... self . _name = name # attribute 'private-by-convention' ... self . __name = name # attribute 'private-by-lexical-substitution' ... def getName ( self ): ... return self . name ... def _getName ( self ): ... return self . _name ... def __getName ( self ): ... return self . __name ... >>> usage >>> a = A ( \"ClassPrivacy\" ) >>> dir ( a ) [ '_A__getName' , '_A__name' , '__class__' , '__delattr__' , '__dict__' , '__dir__' , '__doc__' , '__eq__' , '__format__' , '__ge__' , '__getattribute__' , '__gt__' , '__hash__' , '__init__' , '__init_subclass__' , '__le__' , '__lt__' , '__module__' , '__ne__' , '__new__' , '__reduce__' , '__reduce_ex__' , '__repr__' , '__setattr__' , '__sizeof__' , '__str__' , '__subclasshook__' , '__weakref__' , '_getName' , '_name' , 'getName' , 'name' ] >>> a . name # (1) public attribute 'ClassPrivacy' >>> a . _name # (2) private-by-convention ==> still accessible 'ClassPrivacy' >>> a . __name # (3) private-by-lecical-convention ==> not accessible because it is not found Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > AttributeError : 'A' object has no attribute '__name' >>> a . getName () # (4) public method 'ClassPrivacy' >>> a . _getName () # (5) private-by-convention ==> still accessible/callable 'ClassPrivacy' >>> a . __getName () # (6) private-by-lexical-convention ==> not accessible because it is not found Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > AttributeError : 'A' object has no attribute '__getName' >>> a . _A__name # (7) bypass protection because you know the rule 'ClassPrivacy' >>> a . _A__getName () # (8) bypass protection because you know the rule 'ClassPrivacy' >>> For more details please refer to Private Variables","title":"Class Privacy - private Attributes"},{"location":"training/main-course/classes-instances/#inheritance-is-a-relation","text":"Note on class privacy: As mentioned above, Python doesn't provide any real mechanism for class privacy, neither 'data-protection' nor 'data-hiding'. This also applies to class-inheritance. Inheritance is public by default, as a consequence all of the base-class attributes and methods are inherited by the derived-class class definition >>> class B ( A ): # class 'B' inherhits from class 'A' ... def __init__ ( self , name , number ): # class constructor ... A . __init__ ( self , name ) # call base-class initialisation-method ... self . number = number # instance variable ... def getNumber ( self ): # instance methode ... return self . number ... >>> class instantiation >>> b = B ( 'Inheritance' , 100 ) >>> b . name # attribute-access 'Inheritance' >>> b . getName () # method-access 'Inheritance' >>> b . number # attribute-access 100 >>> b . getNumber () # attribute-access 100 >>>","title":"Inheritance (\"is-a\"-relation)"},{"location":"training/main-course/classes-instances/#multiple-inheritance","text":"Python also supports multiple inheritance class definition >>> class A : ... def __init__ ( self , name ): ... self . name = name ... def getName ( self ): ... return self . name ... >>> >>> class Z : ... def __init__ ( self , another_name ): ... self . another_name = another_name ... def getAnotherName ( self ): ... return self . another_name ... >>> >>> class B ( A , Z ): # multiple inheritance ... def __init__ ( self , name , another_name , number ): ... A . __init__ ( self , name ) # call base-class initialisation-method of class 'A' ... Z . __init__ ( self , another_name ) # call base-class initialisation-method of class 'Z' ... self . number = number ... def getNumber ( self ): ... return self . number ... >>> class instantiation >>> b = B ( 'BaseClass_A' , 'BaseClass_Z' , 100 ) >>> b . getNumber () 100 >>> b . getName () 'BaseClass_A' >>> b . getAnotherName () 'BaseClass_Z' >>> dir ( b ) [ '__class__' , '__delattr__' , '__dict__' , '__dir__' , '__doc__' , '__eq__' , '__format__' , '__ge__' , '__getattribute__' , '__gt__' , '__hash__' , '__init__' , '__init_subclass__' , '__le__' , '__lt__' , '__module__' , '__ne__' , '__new__' , '__reduce__' , '__reduce_ex__' , '__repr__' , '__setattr__' , '__sizeof__' , '__str__' , '__subclasshook__' , '__weakref__' , 'another_name' , 'getAnotherName' , 'getName' , 'getNumber' , 'name' , 'number' ] >>> Note: The dir(<object> )- builtin function lists all names in the namespace of the given object. As can be seen above all defined names of all base-class are in the namespace of the derived class.","title":"Multiple Inheritance"},{"location":"training/main-course/classes-instances/#composition-has-a-relation","text":"Python also support composition, i.e. a class 'B' has an instance-attribute pointing to an instance-attribute of class 'A' class definitions >>> class A : ... def __init__ ( self , name ): ... self . name = name ... def getName ( self ): ... return self . name ... >>> class B : ... def __init__ ( self , name , number ): ... self . a = A ( name ) # create a class 'A' (calling the constructor of class 'A') instance and old a reference to it (class 'B' \"has-a\" an instance-attribute of class 'A' ... self . number = number ... def getNumber ( self ): ... return self . number ... def getName ( self ): ... return self . a . getName () ... >>> class instantiation >>> b = B ( 'Composition' , 100 ) >>> b . getName () # (1): indirect access to instance-variable 'a' 'Composition' >>> b . a . getName () # (2): direct access to instance-variable 'a' 'Composition' >>> b . a . name # (3): direct access to instance-variable 'a' 'Composition' >>> b . getNumber () 100 >>>","title":"Composition (\"has-a\"-relation)"},{"location":"training/main-course/classes-instances/#class-attributes","text":"As opposed to 'instance'-attributes 'class'-attributes are common to all class instances. class definition >>> class A : ... count = 0 ... def __init__ ( self , name ): ... self . name = name ... A . count += 1 ... >>> class instantiation >>> a1 = A ( 'A1' ) # 1.st instance increments class-attribute >>> a1 . count 1 >>> a2 = A ( 'A2' ) # 2.nd instance increments class-attribute >>> a2 . count 2 >>> a1 . count # Note: both instances share the same attribute 2 >>> >>> id ( a1 . count ) 140201179340160 >>> id ( a2 . count ) 140201179340160 >>>","title":"Class Attributes"},{"location":"training/main-course/classes-instances/#class-properties","text":"Ordinary Python instance-attributes are by default 'readable', 'writable' and 'deletable'. Python class properties ('property-attributes') are attributes with 'access-control', i.e. they can be designed to be 'readable', 'writeable' and 'deletable'. Python properties therefore are managed attributes. This is done with special getter -, setter - and deleter - methods which enables the properties to be accessed as ordinary atttributes (instead of a method-call). Usecase: Properties are a way of data encapusulation. Hiding ordinary attributes behind a 'property-interface/facade' introduces a level of indirection to the origin attribute. The origin attribute may change behind the scenes in keeping the user interface with the property-facade. The property can be seen as the user-interface, while the origin attribute is an implementation detail which is a subject to change. Python support two different ways of implementing properties: 'lower-level' using property() builtin function 'higher-level' using @propery -decorator The Python docs provide a good property-example , with read-, write- and delete-access. For convenience this is simply copied here. example using property() -builtin function class C : def __init__ ( self ): self . _x = None def getx ( self ): return self . _x def setx ( self , value ): self . _x = value def delx ( self ): del self . _x x = property ( getx , setx , delx , \"I'm the 'x' property.\" ) usage >>> p1 = C () >>> p1 . x = 1 # (1) set property value >>> p1 . x # (2) get property value 1 >>> del p1 . x # (3) delete property >>> p1 . x = 11 # (4) re-create property >>> p1 . x 11 example using the @propery -builtin decorator class C : def __init__ ( self ): self . _x = None @property def x ( self ): \"\"\"I'm the 'x' property.\"\"\" return self . _x @x . setter def x ( self , value ): self . _x = value @x . deleter def x ( self ): del self . _x usage >>> p1 = C () >>> p1 . x = 9 # (1) set property value >>> p1 . x # (2) get property value 9 >>> del p1 . x # (3) delete property >>> p1 . x = 99 # (4) re-create property >>> p1 . x 99 >>> * 'readonly property example * The above example stripped-down to be read-only: >>> class C : ... def __init__ ( self , x ): ... self . _x = x ... @property ... def x ( self ): ... return self . _x ... >>> usage >>> a = C ( 'foo' ) >>> a . x # (1) read access 'foo' >>> a . x = 'bar' # (2) write access Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > AttributeError : can 't set attribute >>> del a . x # (3) delete access Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > AttributeError : can 't delete attribute >>> Note: Property 'x' is read-only, write- and delete-access fail.","title":"Class Properties"},{"location":"training/main-course/classes-instances/#duck-typing","text":"Statically typed languages like C++ use virtual function for runtime polymorphism. Derived classes therefore override base-class functions retaining their signature. When base-class objects, which hold a derived class reference, call their base-class function, the runtime will virtual dispatch the derived-class function. This allows programing on a abstract base-class level. But this is restricted to class-objects having an inheritance relationship. Pythons polymorphism is based on 'duck typing', where the polymorphism is not based on common types, instead it is based on common behaviour (methods) and attributes of the objects itself. See Wikipedia article on Duck typing : \"If it walks like a duck and it quacks like a duck, then it must be a duck\" This enable more architecural freedom on the program/class-design, because class-hierarchies can be breaked down and allow more loosely coupled program-design, as David M. Beazley writes in his Book \"Python Essential Reference (Fourth Edition)\".","title":"Duck Typing"},{"location":"training/main-course/classes-instances/#special-methods","text":"","title":"Special Methods"},{"location":"training/main-course/classes-instances/#class-methods","text":"As opposed to instance-methods, class-methods operate on the class-object. Usecase: Python doesn't support method overloading like C++ or Java. Therefore multiple methods with the same name within a single class is not supported. As a consequence only a single class constructor ( __init__() -method) can be defined. With 'class-method's it's possible to overcome this. Python 'classc-methods' are defined using the @sclassmethod -decorator preceeding to the method-definition @classmethod -example >>> class ByteStringStore : ... encoding = 'utf-8' ... def __init__ ( self , bytestring ): ... self . bytestring = bytestring ... @classmethod ... def from_unicode ( cls , unicodestring ): ... return cls ( unicodestring . encode ( cls . encoding ) ... ... ) ... >>> a = ByteStringStore ( b 'abc' ) >>> b = ByteStringStore . from_unicode ( '\u00e4\u00f6\u00fc' ) >>> type ( a ) < class ' __main__ . ByteStringStore '> >>> type ( b ) < class ' __main__ . ByteStringStore '> >>>","title":"class methods"},{"location":"training/main-course/classes-instances/#static-methods","text":"Python static-methods neither work on class-instance-objects nor on class-objects (that's the task of 'instance-method' and 'class-methods'). Python 'static-methods' can best be compared to module-functions, defined in the namespace of a class, instead of a modules-namespace. Usecase: Python 'static-methods' can be used for (utility-)functions that logical link to a class, but do not work on the class or their instaances itself Python 'static-methods' are defined using the @staticmethod -decorator preceeding to the method-definition @staticmethod -example >>> class A : ... @staticmethod ... def mystaticmethod (): ... print ( 'this is a staticmethod' ) ... >>> A . mystaticmethod () this is a staticmethod >>> Python @staticmethods are the correspondents to C++ and Java staticmethods, see the Python docs for classmethod","title":"Static Methods"},{"location":"training/main-course/classes-instances/#callable-classes","text":"Callable classes are classes where the class-instances can simply be called as a function. Giving the class a callable-interface, their instances are callable. A class is made callable by defining a the special instance-method named __call__() ). Usecase: If different classes provide different instance-method names for the same functionality (e.g. A.getName() and B.getMyName() ), the usage for the programmers is cumbersome. If they want to get the name from the objects on the one hand they have to call a.getName() and on the other hand b.getMyName() . Making the classes callable, gives them a uniform interface, the name for both class-instance can be fetched in the same manner, simply using the object-name following parenthesis: a() and b() . Definition of a callable class >>> class CallableClass : ... name = None ... def __init__ ( self , name ): ... CallableClass . name = name ... def getName ( self ): ... print ( '>>> calling normal instance-method: %s () <<<' % self . getName . __name__ ) ... return CallableClass . name ... def __call__ ( self ): ... print ( '>>> calling special instance-method: %s () <<<' % self . __call__ . __name__ ) ... return CallableClass . name ... >>> Usage of a callable instance >>> foo = CallableClass ( 'foo' ) # (1) Create an instance of the callable class >>> print ( 'name = %s ' % foo . getName ()) # (2) use the 'standard'-class-interface instance-method 'getName()' >>> calling normal instance - method : getName () <<< name = foo >>> print ( 'name = %s ' % foo ()) # (3) use the 'callable'-class-interface instance-method '__call__()' >>> calling special instance - method : __call__ () <<< name = foo >>> Let's give it a try Lesson: Customers Class Create a class-hierarchy: Class Customer class-attribute: number of customers (which should increment with every new class-instance) class constructor with parameter: 'email', 'employees' instance-attribute: 'id' (number of the current value of 'number of customers') instance-attribute: 'email' instance-attribute: 'employees' (number of employees)) instance-method: 'getEmployees' (returning 'employees') Class Retail(Customer) private class attribute: '__type' initialized to 'Retail' class constructor with parameters: 'name', 'email', 'employees' private instance-attribute: '__retailname' (initialized with 'name'-parameter) instance-method: 'getRetailName' (returning private instance-attribute '__retailname') instance-method: 'getType' (returning private class attribute ' _type') Class Wholesale(Customer) private class attribute: '__type' initialized to 'Wholesale' class constructor with parameters: 'name', 'email', 'employees' private instance-attribute: '__wholesalename' (initialized with 'name'-parameter) instance-method: 'geWholesaleName' (returning private instance-attribute '__wholesalename') instance-method: 'getType' (returning private class attribute ' _type') 1.) Create a list of Customers of different types ('Retail'-customers and 'Wholesale'-customers) 2.) Iterate the list and output 'name', 'type', 'id' and 'employees' of each customer Hint: provide a callable interface __call__()","title":"Callable Classes"},{"location":"training/main-course/classes-instances/#class-decorators","text":"Decorators are explained in detail here . Here we just give a brief overview concerning decorating in the context of classes. Usecase Generally speaking a decorator is a 'wrappers' around functions or classes with the purpose of adding some functionality. Wrappers are callable object, see callable-class . So there are two parties in the decorating process: the decorator the object to be decorated","title":"Class Decorators"},{"location":"training/main-course/classes-instances/#using-a-class-as-a-decorator","text":"In the following example we define a class as a decorator and define a function which is decorated with this 'class-decorator'. Class Decorator definition and function decoration >>> class MyDecorator : ... def __init__ ( self , func ): ... self . func = func ... def __call__ ( self , * args ): ... # put the additional functionalty here around the function ... print ( '==> START calling %s ()' % self . func . __name__ ) # some output before the wrapped function is called ... self . func ( * args ) # call the wrapped-function ... print ( '<== END calling %s ()' % self . func . __name__ ) # some output after the wrapped function is called ... >>> @MyDecorator ... def myfunc ( x ): ... print ( '>>> INSIDE decorated function: %s <<<' % x ) ... >>> function call >>> myfunc ( 'decorator-example' ) ==> START calling myfunc () >>> INSIDE decorated function : decorator - example <<< <== END calling myfunc () >>> Note: Here the class-decorator was used to provide some additional output, when the 'decorated' function is called.","title":"Using a class as a decorator"},{"location":"training/main-course/classes-instances/#decorating-a-class","text":"In the following example we define a function as a decorator and define a class which is decorated with this 'function-decorator'. Note: Here the decorator works on class-definition level, providing some additional funtionality around the class-definition. For sure a rather infrequent usecase which can be classified in some sense as meta-programming. >>> def mydecoratorfunc ( cls ): ... print ( '>>> A new class was born: %s ' % cls ) ... return cls ... >>> @mydecoratorfunc ... class A : pass ... >>> A new class was born : < class ' __main__ . A '> >>>","title":"Decorating a class"},{"location":"training/main-course/classes-instances/#class-testing","text":"Python provides 2 builtin-function to identify/test the membership on class-instance-types. types() : Identifies the concrete class of the class-instance isinstance() : Testing the belonging to a certain type (along the class-hierarchy!) >>> class A (): pass ... >>> class B ( A ): pass ... >>> class C (): pass ... >>> a = A () >>> b = B () >>> c = C () >>> type ( a ) < class ' __main__ . A '> >>> type ( b ) < class ' __main__ . B '> >>> type ( c ) < class ' __main__ . C '> >>> isinstance ( a , A ) True >>> isinstance ( b , A ) # check along the inheritance-hierarchy True >>> isinstance ( c , B ) False","title":"Class Testing"},{"location":"training/main-course/classes-instances/#metaclasses","text":"It should be mentioned that Python also supports techniques for meta-programming, for example to create metaclasses. But this is subject to advanced courses.","title":"MetaClasses"},{"location":"training/main-course/classes-instances/#further-readings-on-classes","text":"Please refer to the Python docs about Classes .","title":"Further readings on classes"},{"location":"training/main-course/context-managers/","text":"Context is Key: Context Managers # Python objects that follow the so-called \"context manager protocol\" can be used with Python's with statement. The with statement starts a code block that is processed \"within a context\", e.g. a resource that has been acquired: >>> with open ( \"myfile.txt\" , \"w\" ) as myfile : ... myfile . write ( \"Hello!\" ) ... 6 >>> with open ( \"myfile.txt\" , \"r\" ) as myfile : ... myfile . readlines () ... [ 'Hello!' ] >>> >> myfile < _io . TextIOWrapper name = 'myfile.txt' mode = 'r' encoding = 'UTF-8' > >>> myfile . closed True >>> After the with statement code block ends the context is \"terminated\", e.g. an acquired resource gets closed or destroyed. This is a useful mechanism for (but not limited to) closing resources that shouldn't be left open. Prominent examples for such resources are files network connections database connections It's possible to use multiple context managers for a code block: >>> with open ( 'in.txt' , 'r' ) as infile , open ( 'out.txt' , 'w' ) as outfile : >>> for line in infile : >>> # better do s.th. sensible with line first... >>> outfile . write ( line ) >>> Context managers can be implemented by providing an object with the context manager protocol methods: class MyContextManager : def __enter__ ( self ): # context initialization goes here (e.g. resource acquisition) # ... def __exit__ ( self , exc_type , exc_value , traceback ): # context finalization goes here (e.g. resource closing/cleanup) # ... A context manager object gets entered through the with statement execution and exits when the with code block ends. Useful tools for easily creating context managers can be found in the stdlib contextlib .","title":"Chapter 9: Context Managers"},{"location":"training/main-course/context-managers/#context-is-key-context-managers","text":"Python objects that follow the so-called \"context manager protocol\" can be used with Python's with statement. The with statement starts a code block that is processed \"within a context\", e.g. a resource that has been acquired: >>> with open ( \"myfile.txt\" , \"w\" ) as myfile : ... myfile . write ( \"Hello!\" ) ... 6 >>> with open ( \"myfile.txt\" , \"r\" ) as myfile : ... myfile . readlines () ... [ 'Hello!' ] >>> >> myfile < _io . TextIOWrapper name = 'myfile.txt' mode = 'r' encoding = 'UTF-8' > >>> myfile . closed True >>> After the with statement code block ends the context is \"terminated\", e.g. an acquired resource gets closed or destroyed. This is a useful mechanism for (but not limited to) closing resources that shouldn't be left open. Prominent examples for such resources are files network connections database connections It's possible to use multiple context managers for a code block: >>> with open ( 'in.txt' , 'r' ) as infile , open ( 'out.txt' , 'w' ) as outfile : >>> for line in infile : >>> # better do s.th. sensible with line first... >>> outfile . write ( line ) >>> Context managers can be implemented by providing an object with the context manager protocol methods: class MyContextManager : def __enter__ ( self ): # context initialization goes here (e.g. resource acquisition) # ... def __exit__ ( self , exc_type , exc_value , traceback ): # context finalization goes here (e.g. resource closing/cleanup) # ... A context manager object gets entered through the with statement execution and exits when the with code block ends. Useful tools for easily creating context managers can be found in the stdlib contextlib .","title":"Context is Key: Context Managers"},{"location":"training/main-course/decorators/","text":"Python decorators # Python decorators are used to add functionality to functions, methods or classes. Some of the use cases are e.g.: add logging/tracing around function calls add locking for threaded code register functions or classes add caching to callables Decorating functions # A very basic decorator to trace function entry and exit could look like this: >>> def trace ( func ): ... # create a wrapper function... ... def _wrapper ( * args , ** kwargs ): ... # ...that prints entry to and exit from the wrapped function, ... # with function name, arguments and result... ... print ( '--> {func} (args= {args} , kwargs= {kwargs} )' . format ( ... func = func . __name__ , args = args , kwargs = kwargs )) ... result = func ( * args , ** kwargs ) ... print ( '<-- {func} -> {result} ' . format ( ... func = func . __name__ , result = result )) ... # ...and return the wrapper for use instead of the original function ... return _wrapper ... We can now apply this decorator to a function: >>> @trace ... def inc ( x ): ... \"\"\"Return x increased by 1.\"\"\" ... return x + 1 ... >>> Calling our decorated \"traced\" function: >>> inc ( 6 ) --> inc ( args = ( 6 ,), kwargs = {}) <-- inc -> 7 >>> Note how we have instrumented the original function with tracing output, while not modifying any of the original function code. Since a (function) decorator is just a callable that takes a function as an argument and returns an enhanced, wrapped version of that function, the @ -decorator syntax is merely syntactial \"sugar\" for: >>> def inc ( x ): ... \"\"\"Return x increased by 1.\"\"\" ... return x + 1 ... >>> inc = trace ( inc ) >>> inc ( 6 ) --> inc ( args = ( 6 ,), kwargs = {}) <-- inc -> 7 >>> Let's take a look at how our decorated function behaves, now using @decorator-syntax again: >>> def trace ( func ): ... # create a wrapper function... ... def _wrapper ( * args , ** kwargs ): ... # ...that prints entry to and exit from the wrapped function, ... # with function name, arguments and result... ... print ( '--> {func} (args= {args} , kwargs= {kwargs} )' . format ( ... func = func . __name__ , args = args , kwargs = kwargs )) ... result = func ( * args , ** kwargs ) ... print ( '<-- {func} -> {result} ' . format ( ... func = func . __name__ , result = result )) ... # ...and return the wrapper for use instead of the original function ... return _wrapper ... >>> @trace ... def inc ( x ): ... \"\"\"Return x increased by 1. ... \"\"\" ... return 1 ... >>> print ( inc . __doc__ ) None >>> inspect . signature ( inc ) < Signature ( * args , ** kwargs ) > >>> Hm, this doesn't look too good a citizen: - the original function documentation has been lost - there's no information about the original function argument signature This is due to the fact that we see docstring and function signature of the wrapper, not the wrapped function. Luckily, there's a convenient way for us to retain this information using the functools library: >>> def trace ( func ): ... # create a wrapper function... ... @functools . wraps ( func ) ... def _wrapper ( * args , ** kwargs ): ... # ...that prints entry to and exit from the wrapped function, ... # with function name, arguments and result... ... print ( '--> {func} (args= {args} , kwargs= {kwargs} )' . format ( ... func = func . __name__ , args = args , kwargs = kwargs )) ... result = func ( * args , ** kwargs ) ... print ( '<-- {func} -> {result} ' . format ( ... func = func . __name__ , result = result )) ... # ...and return the wrapper for use instead of the original function ... return _wrapper ... >>> @trace ... def inc ( x ): ... \"\"\"Return x increased by 1. ... \"\"\" ... return x + 1 ... >>> print ( inc . __doc__ ) Return x increased by 1. >>> inspect . signature ( inc ) < Signature ( x ) > >>> Decorating methods # We can just as well decorate methods: >>> class Increaser : ... def __init__ ( self , increment = 1 ): ... self . increment = increment ... @trace ... def inc ( self , x ): ... \"\"\"Return x increased by increment init argument. ... \"\"\" ... return x + self . increment ... >>> inc = Increaser ( 3 ) >>> inc . inc ( 10 ) --> inc ( args = ( < __main__ . Increaser object at 0x7fc62185c320 > , 10 ), kwargs = {}) <-- inc -> 13 >>> >>> print ( inc . inc . __doc__ ) Return x increased by increment init argument . >>> inspect . signature ( inc . inc ) < Signature ( x ) > >>> In fact, Python implements its notion of class methods and static methods via the built-in @classmethod and @staticmethod decorators. Decorating classes # Decorating classes is just as easy: >>> class Registry : ... _registered_classes = [] ... ... @classmethod ... def register ( cls , register_cls ): ... cls . _registered_classes . append ( register_cls ) ... ... @classmethod ... def registered_classes ( cls ): ... return cls . _registered_classes ... >>> register = Registry . register >>> registry = Registry () >>> >>> @register ... class MyClass1 : ... pass ... >>> @register ... class MyClass2 : ... pass ... >>> registry . registered_classes () [ < class ' __main__ . MyClass1 '>, <class ' __main__ . MyClass2 '>] >>> Advanced Decorators # Decorators can also take arguments. Let's modify the tracing functionality to allow for selective entry and/or exit tracing: >>> def traced ( entry = True , exit = True ): ... # create tracing wrappers depending on the entry & exit args ... if entry and exit : ... def trace ( func ): ... @functools . wraps ( func ) ... def _wrapper ( * args , ** kwargs ): ... print ( '--> {func} (args= {args} , kwargs= {kwargs} )' . format ( ... func = func . __name__ , args = args , kwargs = kwargs )) ... result = func ( * args , ** kwargs ) ... print ( '<-- {func} -> {result} ' . format ( ... func = func . __name__ , result = result )) ... return _wrapper ... ... elif entry : ... def trace ( func ): ... @functools . wraps ( func ) ... def _wrapper ( * args , ** kwargs ): ... print ( '--> {func} (args= {args} , kwargs= {kwargs} )' . format ( ... func = func . __name__ , args = args , kwargs = kwargs )) ... result = func ( * args , ** kwargs ) ... return _wrapper ... ... elif exit : ... def trace ( func ): ... @functools . wraps ( func ) ... def _wrapper ( * args , ** kwargs ): ... result = func ( * args , ** kwargs ) ... print ( '<-- {func} -> {result} ' . format ( ... func = func . __name__ , result = result )) ... return _wrapper ... else : ... trace = None ... ... # create the decorator that will add the selected tracing setup ... def decorate ( cls ): ... if trace is not None : ... for ( name , method ) in inspect . getmembers ( cls ): ... if not name . startswith ( '__' ): ... wrapped = trace ( method ) ... setattr ( cls , name , wrapped ) ... return cls ... ... return decorate ... >>> We'll try this out on a delicious fruit salad: >>> class FruitSalad : ... ... def __init__ ( self ): ... self . fruits = {} ... ... def add ( self , fruit , weight ): ... if fruit not in self . fruits : ... self . fruits [ fruit ] = weight ... else : ... self . fruits [ fruit ] += weight ... >>> >>> fruit_salad = FruitSalad () >>> fruit_salad . add ( 'apple' , '500' ) >>> fruit_salad . add ( 'orange' , '800' ) >>> Make a traced fruit salad: >>> >>> @traced () ... class FruitSalad : ... ... def __init__ ( self ): ... self . fruits = {} ... ... def add ( self , fruit , weight ): ... if fruit not in self . fruits : ... self . fruits [ fruit ] = weight ... else : ... self . fruits [ fruit ] += weight ... >>> fruit_salad = FruitSalad () >>> fruit_salad . add ( 'apple' , '500' ) --> add ( args = ( < __main__ . FruitSalad object at 0x7fc61868cda0 > , 'apple' , '500' ), kwargs = {}) <-- add -> None >>> fruit_salad . add ( 'orange' , '800' ) --> add ( args = ( < __main__ . FruitSalad object at 0x7fc61868cda0 > , 'orange' , '800' ), kwargs = {}) <-- add -> None >>> This might look a little bit confusing initially. The important point is to realize that the callable traced we use in the @traced() decoration line is now rather a \"decorator factory\" than a decorator: it creates a decorator (the decorate function), and returns this to be applied on the decorated class. We can now switch off tracing method entry and only trace funtion exit: >>> >>> @traced ( entry = False ) ... class FruitSalad : ... ... def __init__ ( self ): ... self . fruits = {} ... ... def add ( self , fruit , weight ): ... if fruit not in self . fruits : ... self . fruits [ fruit ] = weight ... else : ... self . fruits [ fruit ] += weight ... >>> fruit_salad = FruitSalad () >>> fruit_salad . add ( 'apple' , '500' ) <-- add -> None >>> fruit_salad . add ( 'orange' , '800' ) <-- add -> None >>> Note : Maybe that's just cosmetics but it's a little annoying that we need to use @traced() syntax even if we simple use the default arguments. Let's make use of Python's [keyword-only] syntax to work around this: >>> def traced ( cls = None , * , entry = True , exit = True ): ... if entry and exit : ... def trace ( func ): ... @functools . wraps ( func ) ... def _wrapper ( * args , ** kwargs ): ... print ( '--> {func} (args= {args} , kwargs= {kwargs} )' . format ( ... func = func . __name__ , args = args , kwargs = kwargs )) ... result = func ( * args , ** kwargs ) ... print ( '<-- {func} -> {result} ' . format ( ... func = func . __name__ , result = result )) ... return _wrapper ... ... elif entry : ... def trace ( func ): ... @functools . wraps ( func ) ... def _wrapper ( * args , ** kwargs ): ... print ( '--> {func} (args= {args} , kwargs= {kwargs} )' . format ( ... func = func . __name__ , args = args , kwargs = kwargs )) ... result = func ( * args , ** kwargs ) ... return _wrapper ... ... elif exit : ... def trace ( func ): ... @functools . wraps ( func ) ... def _wrapper ( * args , ** kwargs ): ... result = func ( * args , ** kwargs ) ... print ( '<-- {func} -> {result} ' . format ( ... func = func . __name__ , result = result )) ... return _wrapper ... else : ... trace = None ... ... def decorate ( cls ): ... if trace is not None : ... for ( name , method ) in inspect . getmembers ( cls ): ... if not name . startswith ( '__' ): ... wrapped = trace ( method ) ... setattr ( cls , name , wrapped ) ... return cls ... ... ... if cls is None : ... # called with arguments ... return decorate ... else : ... # invoked without arguments ... return decorate ( cls ) ... >>> We are now able to omit () from the decoration line: >>> @traced ... class FruitSalad : ... ... def __init__ ( self ): ... self . fruits = {} ... ... def add ( self , fruit , weight ): ... if fruit not in self . fruits : ... self . fruits [ fruit ] = weight ... else : ... self . fruits [ fruit ] += weight ... >>> fruit_salad = FruitSalad () >>> fruit_salad . add ( 'apple' , '500' ) --> add ( args = ( < __main__ . FruitSalad object at 0x7fc61868cda0 > , 'apple' , '500' ), kwargs = {}) <-- add -> None >>> fruit_salad . add ( 'orange' , '800' ) --> add ( args = ( < __main__ . FruitSalad object at 0x7fc61868cda0 > , 'orange' , '800' ), kwargs = {}) <-- add -> None >>> Further Reading # One of the most exhaustive discussions of decorator intricacies is a series of blog posts by Graham Dumpleton , who also wrote the wrapt library for decoration purposes.","title":"Chapter 10: Decorators"},{"location":"training/main-course/decorators/#python-decorators","text":"Python decorators are used to add functionality to functions, methods or classes. Some of the use cases are e.g.: add logging/tracing around function calls add locking for threaded code register functions or classes add caching to callables","title":"Python decorators"},{"location":"training/main-course/decorators/#decorating-functions","text":"A very basic decorator to trace function entry and exit could look like this: >>> def trace ( func ): ... # create a wrapper function... ... def _wrapper ( * args , ** kwargs ): ... # ...that prints entry to and exit from the wrapped function, ... # with function name, arguments and result... ... print ( '--> {func} (args= {args} , kwargs= {kwargs} )' . format ( ... func = func . __name__ , args = args , kwargs = kwargs )) ... result = func ( * args , ** kwargs ) ... print ( '<-- {func} -> {result} ' . format ( ... func = func . __name__ , result = result )) ... # ...and return the wrapper for use instead of the original function ... return _wrapper ... We can now apply this decorator to a function: >>> @trace ... def inc ( x ): ... \"\"\"Return x increased by 1.\"\"\" ... return x + 1 ... >>> Calling our decorated \"traced\" function: >>> inc ( 6 ) --> inc ( args = ( 6 ,), kwargs = {}) <-- inc -> 7 >>> Note how we have instrumented the original function with tracing output, while not modifying any of the original function code. Since a (function) decorator is just a callable that takes a function as an argument and returns an enhanced, wrapped version of that function, the @ -decorator syntax is merely syntactial \"sugar\" for: >>> def inc ( x ): ... \"\"\"Return x increased by 1.\"\"\" ... return x + 1 ... >>> inc = trace ( inc ) >>> inc ( 6 ) --> inc ( args = ( 6 ,), kwargs = {}) <-- inc -> 7 >>> Let's take a look at how our decorated function behaves, now using @decorator-syntax again: >>> def trace ( func ): ... # create a wrapper function... ... def _wrapper ( * args , ** kwargs ): ... # ...that prints entry to and exit from the wrapped function, ... # with function name, arguments and result... ... print ( '--> {func} (args= {args} , kwargs= {kwargs} )' . format ( ... func = func . __name__ , args = args , kwargs = kwargs )) ... result = func ( * args , ** kwargs ) ... print ( '<-- {func} -> {result} ' . format ( ... func = func . __name__ , result = result )) ... # ...and return the wrapper for use instead of the original function ... return _wrapper ... >>> @trace ... def inc ( x ): ... \"\"\"Return x increased by 1. ... \"\"\" ... return 1 ... >>> print ( inc . __doc__ ) None >>> inspect . signature ( inc ) < Signature ( * args , ** kwargs ) > >>> Hm, this doesn't look too good a citizen: - the original function documentation has been lost - there's no information about the original function argument signature This is due to the fact that we see docstring and function signature of the wrapper, not the wrapped function. Luckily, there's a convenient way for us to retain this information using the functools library: >>> def trace ( func ): ... # create a wrapper function... ... @functools . wraps ( func ) ... def _wrapper ( * args , ** kwargs ): ... # ...that prints entry to and exit from the wrapped function, ... # with function name, arguments and result... ... print ( '--> {func} (args= {args} , kwargs= {kwargs} )' . format ( ... func = func . __name__ , args = args , kwargs = kwargs )) ... result = func ( * args , ** kwargs ) ... print ( '<-- {func} -> {result} ' . format ( ... func = func . __name__ , result = result )) ... # ...and return the wrapper for use instead of the original function ... return _wrapper ... >>> @trace ... def inc ( x ): ... \"\"\"Return x increased by 1. ... \"\"\" ... return x + 1 ... >>> print ( inc . __doc__ ) Return x increased by 1. >>> inspect . signature ( inc ) < Signature ( x ) > >>>","title":"Decorating functions"},{"location":"training/main-course/decorators/#decorating-methods","text":"We can just as well decorate methods: >>> class Increaser : ... def __init__ ( self , increment = 1 ): ... self . increment = increment ... @trace ... def inc ( self , x ): ... \"\"\"Return x increased by increment init argument. ... \"\"\" ... return x + self . increment ... >>> inc = Increaser ( 3 ) >>> inc . inc ( 10 ) --> inc ( args = ( < __main__ . Increaser object at 0x7fc62185c320 > , 10 ), kwargs = {}) <-- inc -> 13 >>> >>> print ( inc . inc . __doc__ ) Return x increased by increment init argument . >>> inspect . signature ( inc . inc ) < Signature ( x ) > >>> In fact, Python implements its notion of class methods and static methods via the built-in @classmethod and @staticmethod decorators.","title":"Decorating methods"},{"location":"training/main-course/decorators/#decorating-classes","text":"Decorating classes is just as easy: >>> class Registry : ... _registered_classes = [] ... ... @classmethod ... def register ( cls , register_cls ): ... cls . _registered_classes . append ( register_cls ) ... ... @classmethod ... def registered_classes ( cls ): ... return cls . _registered_classes ... >>> register = Registry . register >>> registry = Registry () >>> >>> @register ... class MyClass1 : ... pass ... >>> @register ... class MyClass2 : ... pass ... >>> registry . registered_classes () [ < class ' __main__ . MyClass1 '>, <class ' __main__ . MyClass2 '>] >>>","title":"Decorating classes"},{"location":"training/main-course/decorators/#advanced-decorators","text":"Decorators can also take arguments. Let's modify the tracing functionality to allow for selective entry and/or exit tracing: >>> def traced ( entry = True , exit = True ): ... # create tracing wrappers depending on the entry & exit args ... if entry and exit : ... def trace ( func ): ... @functools . wraps ( func ) ... def _wrapper ( * args , ** kwargs ): ... print ( '--> {func} (args= {args} , kwargs= {kwargs} )' . format ( ... func = func . __name__ , args = args , kwargs = kwargs )) ... result = func ( * args , ** kwargs ) ... print ( '<-- {func} -> {result} ' . format ( ... func = func . __name__ , result = result )) ... return _wrapper ... ... elif entry : ... def trace ( func ): ... @functools . wraps ( func ) ... def _wrapper ( * args , ** kwargs ): ... print ( '--> {func} (args= {args} , kwargs= {kwargs} )' . format ( ... func = func . __name__ , args = args , kwargs = kwargs )) ... result = func ( * args , ** kwargs ) ... return _wrapper ... ... elif exit : ... def trace ( func ): ... @functools . wraps ( func ) ... def _wrapper ( * args , ** kwargs ): ... result = func ( * args , ** kwargs ) ... print ( '<-- {func} -> {result} ' . format ( ... func = func . __name__ , result = result )) ... return _wrapper ... else : ... trace = None ... ... # create the decorator that will add the selected tracing setup ... def decorate ( cls ): ... if trace is not None : ... for ( name , method ) in inspect . getmembers ( cls ): ... if not name . startswith ( '__' ): ... wrapped = trace ( method ) ... setattr ( cls , name , wrapped ) ... return cls ... ... return decorate ... >>> We'll try this out on a delicious fruit salad: >>> class FruitSalad : ... ... def __init__ ( self ): ... self . fruits = {} ... ... def add ( self , fruit , weight ): ... if fruit not in self . fruits : ... self . fruits [ fruit ] = weight ... else : ... self . fruits [ fruit ] += weight ... >>> >>> fruit_salad = FruitSalad () >>> fruit_salad . add ( 'apple' , '500' ) >>> fruit_salad . add ( 'orange' , '800' ) >>> Make a traced fruit salad: >>> >>> @traced () ... class FruitSalad : ... ... def __init__ ( self ): ... self . fruits = {} ... ... def add ( self , fruit , weight ): ... if fruit not in self . fruits : ... self . fruits [ fruit ] = weight ... else : ... self . fruits [ fruit ] += weight ... >>> fruit_salad = FruitSalad () >>> fruit_salad . add ( 'apple' , '500' ) --> add ( args = ( < __main__ . FruitSalad object at 0x7fc61868cda0 > , 'apple' , '500' ), kwargs = {}) <-- add -> None >>> fruit_salad . add ( 'orange' , '800' ) --> add ( args = ( < __main__ . FruitSalad object at 0x7fc61868cda0 > , 'orange' , '800' ), kwargs = {}) <-- add -> None >>> This might look a little bit confusing initially. The important point is to realize that the callable traced we use in the @traced() decoration line is now rather a \"decorator factory\" than a decorator: it creates a decorator (the decorate function), and returns this to be applied on the decorated class. We can now switch off tracing method entry and only trace funtion exit: >>> >>> @traced ( entry = False ) ... class FruitSalad : ... ... def __init__ ( self ): ... self . fruits = {} ... ... def add ( self , fruit , weight ): ... if fruit not in self . fruits : ... self . fruits [ fruit ] = weight ... else : ... self . fruits [ fruit ] += weight ... >>> fruit_salad = FruitSalad () >>> fruit_salad . add ( 'apple' , '500' ) <-- add -> None >>> fruit_salad . add ( 'orange' , '800' ) <-- add -> None >>> Note : Maybe that's just cosmetics but it's a little annoying that we need to use @traced() syntax even if we simple use the default arguments. Let's make use of Python's [keyword-only] syntax to work around this: >>> def traced ( cls = None , * , entry = True , exit = True ): ... if entry and exit : ... def trace ( func ): ... @functools . wraps ( func ) ... def _wrapper ( * args , ** kwargs ): ... print ( '--> {func} (args= {args} , kwargs= {kwargs} )' . format ( ... func = func . __name__ , args = args , kwargs = kwargs )) ... result = func ( * args , ** kwargs ) ... print ( '<-- {func} -> {result} ' . format ( ... func = func . __name__ , result = result )) ... return _wrapper ... ... elif entry : ... def trace ( func ): ... @functools . wraps ( func ) ... def _wrapper ( * args , ** kwargs ): ... print ( '--> {func} (args= {args} , kwargs= {kwargs} )' . format ( ... func = func . __name__ , args = args , kwargs = kwargs )) ... result = func ( * args , ** kwargs ) ... return _wrapper ... ... elif exit : ... def trace ( func ): ... @functools . wraps ( func ) ... def _wrapper ( * args , ** kwargs ): ... result = func ( * args , ** kwargs ) ... print ( '<-- {func} -> {result} ' . format ( ... func = func . __name__ , result = result )) ... return _wrapper ... else : ... trace = None ... ... def decorate ( cls ): ... if trace is not None : ... for ( name , method ) in inspect . getmembers ( cls ): ... if not name . startswith ( '__' ): ... wrapped = trace ( method ) ... setattr ( cls , name , wrapped ) ... return cls ... ... ... if cls is None : ... # called with arguments ... return decorate ... else : ... # invoked without arguments ... return decorate ( cls ) ... >>> We are now able to omit () from the decoration line: >>> @traced ... class FruitSalad : ... ... def __init__ ( self ): ... self . fruits = {} ... ... def add ( self , fruit , weight ): ... if fruit not in self . fruits : ... self . fruits [ fruit ] = weight ... else : ... self . fruits [ fruit ] += weight ... >>> fruit_salad = FruitSalad () >>> fruit_salad . add ( 'apple' , '500' ) --> add ( args = ( < __main__ . FruitSalad object at 0x7fc61868cda0 > , 'apple' , '500' ), kwargs = {}) <-- add -> None >>> fruit_salad . add ( 'orange' , '800' ) --> add ( args = ( < __main__ . FruitSalad object at 0x7fc61868cda0 > , 'orange' , '800' ), kwargs = {}) <-- add -> None >>>","title":"Advanced Decorators"},{"location":"training/main-course/decorators/#further-reading","text":"One of the most exhaustive discussions of decorator intricacies is a series of blog posts by Graham Dumpleton , who also wrote the wrapt library for decoration purposes.","title":"Further Reading"},{"location":"training/main-course/exceptions/","text":"Exceptional behaviour: Creating and handling exceptions # Exceptions are the answer of handling errors during program-execution. A SyntaxError is an Exception which ca't be handled. Every other error can be programatically be expected and processed Errors mainly occur in circumstances where program resources are occupied/unavailable data is not as expected wrong-type wrong format wrong value e.g.out-of-range) This section gives a brief overview of exception-handling But lets start with creating a simple exception Creating an Exception # FileNotFoundError This an example from the 1.st category 'resource not available' >>> open ( 'foo.txt' ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > FileNotFoundError : [ Errno 2 ] No such file or directory : 'foo.txt' >>> TypeError Exception example This an example from the 2.nd category 'data not as is expected' >>> a = 'foo' + 1 Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : must be str , not int >>> Handling Exceptions # Similar to C++ try-catch - and Java's try-catch statements, Python provides a try-except-finally -statement. The complete description can be founf in the Python docs Handling Exceptions A simple example An example showing the general usage >>> try : ... # statements in the try-block ... pass ... except FileNotFoundError as e : # catch two different exceptions in one 'except'-block ... # handle 'FileNotFoundError' ... except TypeError as e : ... # handle 'TypeError' ... pass ... except ( ImportError , NameError ) as e : # catch two different exceptions in one 'except'-block ... # Handle 'ImportError' and 'KeyError' ... pass >>> In this example excpetions of type 'FileNotFoundError', 'ImportError','NameError' will be catched. Every other exception will be provided to the surrounding code-block and has to be catzched and processed there. A more complex example The next example uses the optional else - and finally -clauses of a 'tyr-except`-statement >>> try : ... # statements in the try-block ... pass ... except FileNotFoundError as e : ... # handle 'FileNotFoundError' ... pass ... except TypeError as e : ... # handle 'TypeError' ... pass ... except ( ImportError , NameError ) ... # Handle ImportError and KeyError ... else : # optional ... # do some additional works, in the case the 'try'-block succeeds ... pass ... finally : # optional ... # cleanup/free some ressource, this code block is executed no matter if te try succeeds or an error occurs ... pass >>> Note: - the else -block: - if present must folow the except -clauses - will only be executed if the try -blocks succeeds, i.e. it is executed after a successfull try -block - the finally -clause: - will be executed no matter if the try -block succeeds or an error is raised - detailed descriptions plaese read Defining Clean-Up Actions Raising Exceptions # Raising an exception is simple done using the raise -statement (C++: throw -keyword, Java: throw -statement) * raise -example * >>> raise TypeError ( 'Argument has wrong type' ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : Argument has wrong type >>> User-defined Exceptions # Python programms provide a bunch of builtin-exceptions, see Exception Hierarchy . But sometimes it's necessary to provide more spceialized exceptions. Python exceptions are classes. A 'user-defined' excection is therfore simply writing a new class inheritung from one of the classes in the exception-hierarchy. User-defined Exception >>> class MyException ( Exception ): ... def __init__ ( self , value ): ... self . value = value ... >>> type ( MyException ) < class ' type '> >>> Usage >>> try : ... raise MyException ( 'MyException-ERROR' ) ... except MyException as e : ... print ( str ( e )) ... MyException - ERROR >>>","title":"Chapter 7: Exceptions"},{"location":"training/main-course/exceptions/#exceptional-behaviour-creating-and-handling-exceptions","text":"Exceptions are the answer of handling errors during program-execution. A SyntaxError is an Exception which ca't be handled. Every other error can be programatically be expected and processed Errors mainly occur in circumstances where program resources are occupied/unavailable data is not as expected wrong-type wrong format wrong value e.g.out-of-range) This section gives a brief overview of exception-handling But lets start with creating a simple exception","title":"Exceptional behaviour: Creating and handling exceptions"},{"location":"training/main-course/exceptions/#creating-an-exception","text":"FileNotFoundError This an example from the 1.st category 'resource not available' >>> open ( 'foo.txt' ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > FileNotFoundError : [ Errno 2 ] No such file or directory : 'foo.txt' >>> TypeError Exception example This an example from the 2.nd category 'data not as is expected' >>> a = 'foo' + 1 Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : must be str , not int >>>","title":"Creating an Exception"},{"location":"training/main-course/exceptions/#handling-exceptions","text":"Similar to C++ try-catch - and Java's try-catch statements, Python provides a try-except-finally -statement. The complete description can be founf in the Python docs Handling Exceptions A simple example An example showing the general usage >>> try : ... # statements in the try-block ... pass ... except FileNotFoundError as e : # catch two different exceptions in one 'except'-block ... # handle 'FileNotFoundError' ... except TypeError as e : ... # handle 'TypeError' ... pass ... except ( ImportError , NameError ) as e : # catch two different exceptions in one 'except'-block ... # Handle 'ImportError' and 'KeyError' ... pass >>> In this example excpetions of type 'FileNotFoundError', 'ImportError','NameError' will be catched. Every other exception will be provided to the surrounding code-block and has to be catzched and processed there. A more complex example The next example uses the optional else - and finally -clauses of a 'tyr-except`-statement >>> try : ... # statements in the try-block ... pass ... except FileNotFoundError as e : ... # handle 'FileNotFoundError' ... pass ... except TypeError as e : ... # handle 'TypeError' ... pass ... except ( ImportError , NameError ) ... # Handle ImportError and KeyError ... else : # optional ... # do some additional works, in the case the 'try'-block succeeds ... pass ... finally : # optional ... # cleanup/free some ressource, this code block is executed no matter if te try succeeds or an error occurs ... pass >>> Note: - the else -block: - if present must folow the except -clauses - will only be executed if the try -blocks succeeds, i.e. it is executed after a successfull try -block - the finally -clause: - will be executed no matter if the try -block succeeds or an error is raised - detailed descriptions plaese read Defining Clean-Up Actions","title":"Handling Exceptions"},{"location":"training/main-course/exceptions/#raising-exceptions","text":"Raising an exception is simple done using the raise -statement (C++: throw -keyword, Java: throw -statement) * raise -example * >>> raise TypeError ( 'Argument has wrong type' ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : Argument has wrong type >>>","title":"Raising Exceptions"},{"location":"training/main-course/exceptions/#user-defined-exceptions","text":"Python programms provide a bunch of builtin-exceptions, see Exception Hierarchy . But sometimes it's necessary to provide more spceialized exceptions. Python exceptions are classes. A 'user-defined' excection is therfore simply writing a new class inheritung from one of the classes in the exception-hierarchy. User-defined Exception >>> class MyException ( Exception ): ... def __init__ ( self , value ): ... self . value = value ... >>> type ( MyException ) < class ' type '> >>> Usage >>> try : ... raise MyException ( 'MyException-ERROR' ) ... except MyException as e : ... print ( str ( e )) ... MyException - ERROR >>>","title":"User-defined Exceptions"},{"location":"training/main-course/flow-control/","text":"Everything will flow: Python control-flow constructs # Control flow(-statements) controls the order of execution of statements within a program. Python offers a common set of 'control-flow'-statements. choices - the if -statement # The if -statement provides condtional-execution of code-blocks, see also Python docs if -statement . if -statement example >>> a = 1 >>> if a == 0 : ... print ( 'a is 0' ) ... elif a == 1 : ... print ( 'a is 1' ) ... elif a == 2 : ... print ( 'a is 2' ) ... else : ... print ( 'a neither 0, nor 1 or 2' ) ... >>> a is 1 loops # for -statement # The for -statement is a count-based loop-control, i.e. the number of repetitions is based upon the number of elements of a 'sequence'. All sequence-types provide a len() -method, returning the number of elements of the object. A 'sequence' can be (class construction in paranthesis) list : class/type-constructor list() e.g. list([1,2,3]) or list([(1,2,3)) tuple : class/type-constructor tuple() e.g. tuple([1,2,3]) or tuple((1,2,3)) str : class/type-constructor str() e.g str(\"foo\") range ( range() : e.g. range(0,3) or range(2) or range(1,3) Note: The range() -builtin function creates object of type range , which produces a sequence of integers, see Range or help(range) : >>> help ( range ) Help on class range in module builtins : class range ( object ) | range ( stop ) -> range object | range ( start , stop [, step ]) -> range object ... < abbreviated > for-loop using a list -object (1) In this example create a sequence as an implicit unnamed counter variable >>> for elem in list ([ 0 , 1 , 2 ]): ... print ( elem ) ... 0 1 2 >>> for-loop using a list -object (1) Normally you provide an explicit list-counter-variable to the for-loop-statement >>> a [ 1 , 2 , 3 ] >>> for elem in a : ... print ( elem ) ... del a [ - 1 ] # (1) changing the counter-variable inside the loop will affect number of repetitions ... 1 2 >>> a # (2) list-objects are mutable they will also effects the variable i the outer-block [ 1 ] >>> Note: Better use immutable 'tuple`-object to avoid side-effects for-loop using a range -objects (1) Example using 'start' and 'stop'-parameter >>> for elem in range ( 0 , 3 ): ... print ( elem ) ... 0 1 2 >>> for-loop using a range -objects (2) Example using only 'stop'-parameter >>> for elem in range ( 3 ): ... print ( elem ) ... 0 1 2 >>> for-loop using a range -objects (3) Example using only 'start'-, stop'- and 'step'-parameter >>> for elem in range ( 0 , 9 , 3 ): ... print ( elem ) ... 0 3 6 >>> while -statement # The while -statement is a condition-based loop-control, i.e the number of repetitions is controlled by a boolean-expression evaluating to True . In a while-loop a 'condition-variable' is set before and changed within the while-loop. simple while -statement # >>> a = 0 >>> while a < 3 : ... print ( a ) ... a += 1 # change the condition variable ... 0 1 2 >> break -statement # With break -statement loops can quit prematurely Usage: Stop iteration at '1.st-occurence-of' Using break -statement in a for -loop >>> s = \"text\" >>> for elem in s : ... if elem == 'x' : ... break ... print ( elem ) ... t e >>> Using break -statement in a while -loop >>> s = \"text\" >>> a = 0 >>> while a < len ( s ): ... if s [ a ] == 'x' : ... break ... print ( s [ a ]) ... a += 1 ... t e >>> continue -statement # With a continue -statement loops skip the current iteration Usage: 'skip-on-condition' Using continue -statement in a for -loop >>> for elem in s : ... if elem == 'x' : ... continue ... print ( elem ) ... t e t >>> Using continue -statement in a while -loop >> a = 0 >>> while a < len ( s ): ... if s [ a ] == 'x' : ... a += 1 ... continue ... print ( s [ a ]) ... a += 1 ... t e t >>> else -clause # As from the Python docs about the purpose of else -clause and when it is executed (see else -clause ): \"Loop statements may have an else clause; it is executed when the loop terminates through exhaustion of the iterable (with for) or when the condition becomes false (with while), but not when the loop is terminated by a break statement\" So the else -clause can be seen as 'finalizer'-block of statements which are processed ath the end of a loop during normal operations. Using else -clause in a for -loop >>> s = \"text\" >>> for elem in s : ... print ( elem ) ... else : ... print ( 'End of normal processing' ) ... t e x t End of normal processing >>> Using else -clause in a while -loop >>> s = \"text\" >>> a = 0 >>> while a < len ( s ): ... print ( s [ a ]) ... a = a + 1 ... else : ... print ( 'End of normal processing' ) ... t e x t End of normal processing >>> Note: Don't mix up with the else -clause of the if -statement which is part of a choice-control pass -statement # The pass - statement is a noop \u00b4-statement , meaning no-operation, as it does nothing: Usage: As from the Python Docs pass -statement \"It can be used when a statement is required syntactically but the program requires no action\" * Example pass -statement - demonstrating a class-definition * >>> class A : pass ... >>> type ( A ) < class ' type '> >>>","title":"Chapter 6: Flow Control"},{"location":"training/main-course/flow-control/#everything-will-flow-python-control-flow-constructs","text":"Control flow(-statements) controls the order of execution of statements within a program. Python offers a common set of 'control-flow'-statements.","title":"Everything will flow: Python control-flow constructs"},{"location":"training/main-course/flow-control/#choices-the-if-statement","text":"The if -statement provides condtional-execution of code-blocks, see also Python docs if -statement . if -statement example >>> a = 1 >>> if a == 0 : ... print ( 'a is 0' ) ... elif a == 1 : ... print ( 'a is 1' ) ... elif a == 2 : ... print ( 'a is 2' ) ... else : ... print ( 'a neither 0, nor 1 or 2' ) ... >>> a is 1","title":"choices - the if-statement"},{"location":"training/main-course/flow-control/#loops","text":"","title":"loops"},{"location":"training/main-course/flow-control/#for-statement","text":"The for -statement is a count-based loop-control, i.e. the number of repetitions is based upon the number of elements of a 'sequence'. All sequence-types provide a len() -method, returning the number of elements of the object. A 'sequence' can be (class construction in paranthesis) list : class/type-constructor list() e.g. list([1,2,3]) or list([(1,2,3)) tuple : class/type-constructor tuple() e.g. tuple([1,2,3]) or tuple((1,2,3)) str : class/type-constructor str() e.g str(\"foo\") range ( range() : e.g. range(0,3) or range(2) or range(1,3) Note: The range() -builtin function creates object of type range , which produces a sequence of integers, see Range or help(range) : >>> help ( range ) Help on class range in module builtins : class range ( object ) | range ( stop ) -> range object | range ( start , stop [, step ]) -> range object ... < abbreviated > for-loop using a list -object (1) In this example create a sequence as an implicit unnamed counter variable >>> for elem in list ([ 0 , 1 , 2 ]): ... print ( elem ) ... 0 1 2 >>> for-loop using a list -object (1) Normally you provide an explicit list-counter-variable to the for-loop-statement >>> a [ 1 , 2 , 3 ] >>> for elem in a : ... print ( elem ) ... del a [ - 1 ] # (1) changing the counter-variable inside the loop will affect number of repetitions ... 1 2 >>> a # (2) list-objects are mutable they will also effects the variable i the outer-block [ 1 ] >>> Note: Better use immutable 'tuple`-object to avoid side-effects for-loop using a range -objects (1) Example using 'start' and 'stop'-parameter >>> for elem in range ( 0 , 3 ): ... print ( elem ) ... 0 1 2 >>> for-loop using a range -objects (2) Example using only 'stop'-parameter >>> for elem in range ( 3 ): ... print ( elem ) ... 0 1 2 >>> for-loop using a range -objects (3) Example using only 'start'-, stop'- and 'step'-parameter >>> for elem in range ( 0 , 9 , 3 ): ... print ( elem ) ... 0 3 6 >>>","title":"for-statement"},{"location":"training/main-course/flow-control/#while-statement","text":"The while -statement is a condition-based loop-control, i.e the number of repetitions is controlled by a boolean-expression evaluating to True . In a while-loop a 'condition-variable' is set before and changed within the while-loop.","title":"while-statement"},{"location":"training/main-course/flow-control/#simple-while-statement","text":">>> a = 0 >>> while a < 3 : ... print ( a ) ... a += 1 # change the condition variable ... 0 1 2 >>","title":"simple while-statement"},{"location":"training/main-course/flow-control/#break-statement","text":"With break -statement loops can quit prematurely Usage: Stop iteration at '1.st-occurence-of' Using break -statement in a for -loop >>> s = \"text\" >>> for elem in s : ... if elem == 'x' : ... break ... print ( elem ) ... t e >>> Using break -statement in a while -loop >>> s = \"text\" >>> a = 0 >>> while a < len ( s ): ... if s [ a ] == 'x' : ... break ... print ( s [ a ]) ... a += 1 ... t e >>>","title":"break-statement"},{"location":"training/main-course/flow-control/#continue-statement","text":"With a continue -statement loops skip the current iteration Usage: 'skip-on-condition' Using continue -statement in a for -loop >>> for elem in s : ... if elem == 'x' : ... continue ... print ( elem ) ... t e t >>> Using continue -statement in a while -loop >> a = 0 >>> while a < len ( s ): ... if s [ a ] == 'x' : ... a += 1 ... continue ... print ( s [ a ]) ... a += 1 ... t e t >>>","title":"continue-statement"},{"location":"training/main-course/flow-control/#else-clause","text":"As from the Python docs about the purpose of else -clause and when it is executed (see else -clause ): \"Loop statements may have an else clause; it is executed when the loop terminates through exhaustion of the iterable (with for) or when the condition becomes false (with while), but not when the loop is terminated by a break statement\" So the else -clause can be seen as 'finalizer'-block of statements which are processed ath the end of a loop during normal operations. Using else -clause in a for -loop >>> s = \"text\" >>> for elem in s : ... print ( elem ) ... else : ... print ( 'End of normal processing' ) ... t e x t End of normal processing >>> Using else -clause in a while -loop >>> s = \"text\" >>> a = 0 >>> while a < len ( s ): ... print ( s [ a ]) ... a = a + 1 ... else : ... print ( 'End of normal processing' ) ... t e x t End of normal processing >>> Note: Don't mix up with the else -clause of the if -statement which is part of a choice-control","title":"else-clause"},{"location":"training/main-course/flow-control/#pass-statement","text":"The pass - statement is a noop \u00b4-statement , meaning no-operation, as it does nothing: Usage: As from the Python Docs pass -statement \"It can be used when a statement is required syntactically but the program requires no action\" * Example pass -statement - demonstrating a class-definition * >>> class A : pass ... >>> type ( A ) < class ' type '> >>>","title":"pass-statement"},{"location":"training/main-course/functions/","text":"Functions # Providing repeating tasks or calculation in functions is an effective way of code-reuse (\"write-once-use-many\"). This is a brief introduction of Python functions, not covering all possible variations of function-definitions. More on this can be found in the official Python docs https://docs.python.org/3/tutorial/controlflow.html#more-on-defining-functions . Function itself are Python objects, as such they can e.g be assigned, passed as parameters to or returned from functions, more on that later. Function Definition # In Python user-defined functions are defined using the def -statement. A function definition is made up a function-header (defining the function-name and the call-signature) and a function-body (the implementation of the task/calculation as a sequence of code statements ending up with an optional return-statement). Python allows different ways of function-definitions as described in the following subsections. Note: Often the term \"argument\" and \"parameter\" are used interchangeable, but this is a little bit diffuse. More precise are the terms \"actual parameter\" for \"argument\" for variables or values in function-calls and \"formal parameter\" for parameter-names in function-definitions. Here the term \"argument\" is used for the variable/values in function-calls, the term \"parameter is used for parameter-names in function-definitions. Function with simple parameters # function-definition example >>> def increment ( a , stride ): # function-header ... ''' Purpose: Increment a with stride ''' # optional doc-string ... # function-body ... c = a + stride ... return c ... >>> A function-call is done simply writing the function-name following a tuple of positional call-arguments function-call example >>> result = increment ( 1 , 2 ) >>> print ( result ) 3 >>> Note: The number of parameters equal the number of call-arguments. Also the order of the call-parameter must match the order of function-parameters: During the function-call the 1.st call-argument is mapped to the 1.st function-parameter, the 2.nd call-argument is mapped to the 2.nd function-parameter, i.e a position-based mapping from the call-arguments to the function-parameters (call-arguments here are positional arguments ) Let's give it a try Lesson: Check palindromes Create a function that takes a single string argument returns True if string is a palindrome, False otherwise (1) Use a loop for implementation (2) Try an alternative implementation using \"extended slicing\": Check word == word[::-1] test the function by calling it with a palindrome-word and a Optionally: Create a python script check_palindrom.py that asks the user to enter a word to be checked to be a palindrom python3 check_palindrom.py Please enter a word: abba word: abba - reversed-word: abba # optional output is_palindrom: abba ==> True python3 check_palindrom.py Please enter a word: foo word: foo - reversed-word: oof # optional output is_palindrom: foo ==> False Hint: use input() -builtin for user-input Optionally: Instead of user input provide a command line argument to your python script. Hint: Command line argument can be accessed using sys.argv . Function with optional parameters # Optional parameters are parameters with assigned default values in the function-definition. Those optional parameters may be omitted during the function-call. function-definition example - utilizing default-paramater value >>> def increment ( a , stride = 1 ): # function-header with default-argument ... ''' Purpose: Increment a with stride ''' # optional doc-string ... # function-body ... c = a + stride ... return c ... >>> function-call example (1) - omitting optional parameter >>> result = increment ( 1 ) >>> print ( result ) 2 >>> function-call example (2) - overwriting default-value of optional-parameter >>> result = increment ( 1 , 5 ) >>> print ( result ) 6 >>> Note 1: Function-call can be made using only with arguments for parameters, where no default-agument are defined Note 2: Optional-parameters must be defined at the end of the function-parameter-list. Otherhwise a SyntaxError is raised, e.g. >>> def a ( a , b = 1 , c ): ... return ( a + b + c ) ... File \"<stdin>\" , line 1 SyntaxError : non - default argument follows default argument Function with variable parameter list (variadic parameter) # A function can be defined having a variable-parameter-list. This is specified in preceding the last parameter with an asterisk-character * in the function definition. function-definition >>> def print_info ( header , footer , * args ): # 2 normal parameter & variable-length-parameter ... print ( header ) ... for elem in args : print ( elem ) ... print ( footer ) ... >>> varargs-function-call (1) >>> print_info ( '-->' , '<--' , 'Hello' , 'World' ) # last 2 arguments are mapped as a tuple into the *-parameter --> Hello World <-- >>> varargs-function-call (2) >>> print_info ( '-->' , '<--' , 'Tic' , 'Tac' , 'Toe' ) # last 3 arguments are mapped as a tuple into the *-parameter --> Tic Tac Toe <-- >>> Keyword Arguments # In the above sections the functions are called with positional arguments , see Note above. In addition function can also be called using named arguments (keyword arguments). To demonstrate this, we use the increment -function-definition from above. * function-definition * >>> def increment ( a , stride = 1 ): # function-header ... ''' Purpose: Increment a with stride ''' # optional doc-string ... # function-body ... c = a + stride ... return c ... >>> function-call using keyword parameter (1) >>> increment ( a = 1 ) 2 >>> function-call using keyword parameter (2) >>> increment ( stride = 3 , a = 1 ) 4 >>> Note Using keyword-arguments the position of the call-argument doesn't matter Function with additional keyword parameter # Additionally Python allows function-definitions with arbitray additional keyword-paramaters. This is specified in preceeding the last parmeter with double-asterisk character ** . Additional kewyword-arguments are mapped during the function-call into a dictionary for the keyword-parameter of the function definition function-definition with keyword-parameters >>> def print_info ( header , footer , * args , ** kwargs ): ... print ( header ) ... for elem in args : print ( elem ) ... for elem in kwargs . keys (): print ( ' %s : %s ' % ( elem , kwargs [ elem ])) ... print ( footer ) ... >>> function-call >>> print_info ( '-->' , '<--' , 'Madrid' , 'Berlin' , 'Paris' , capitols_of = 'European Countries' , belonging_to = 'EU' ) --> Madrid Berlin Paris capitols_of : European Countries belonging_to : EU <-- >>> Function Return Value # Python allows the return of mutiple values. >>> def divide ( number , div ): ... '''Division returning truncated division and modulo''' ... d = number // div ... m = number % div ... return d , m ... >>> d , m = divide ( 9 , 4 ) >>> d 2 >>> m 1 >>> Inner functions # Functions can be defined at every place, at module-level, inside classes (methods), but also inside functions. function definition >>> def outer_func ( inner_func ): ... ''' function which defines inner functions''' ... def x (): ... print ( x . __name__ ) ... def y (): ... print ( y . __name__ ) ... # return an inner function, simply by its name ... if inner_func == 1 : ... return x ... else : ... return y ... >>> function-call >>> a_func = outer_func ( 1 ) # assign a function >>> a_func () # call the function x >>> b_func = outer_func ( 2 ) # assign a function >>> b_func () # call the function y >>> Note: As can be seen, functions are like ordinary Python objects that can be returned and assigned. Functions Annotations # Function Annotations allow programmers to associate meta-information to a function-header. One kind of interesting mata-information are so called 'type-hints', which can provide 'type-information' about the function-paramertes and return-value. Function annotations are stored in the __annotations__ attribute of a function object. Function Annotation example >>> def concatenate ( string_1 : str , string_2 : str ) -> str : ... return string_1 + string_2 ... >>> concate ( 'foo' , 'bar' ) 'foobar' >>> concate . __annotations__ { 'string_1' : < class ' str '>, ' string_2 ': <class ' str '>, ' return ': <class ' str '>} >>> For a more detailed inforamtions please refer to PEP 3107 -- Function Annotations and PEP 484 -- Type Hints Note 1: Function annotations are optional, they are just informations. They are neither evaluated nor their compliance is enforced by the interpreter itself. It's provided in the language, helping other libraries do some type-checking. Note 2: 'Type Hints'-support is implemented in the Python standard library typing . Note 3: PEP - Python Enhancement Proposal - is the official process of suggesting enhancements to the Python language, please read PEP 001 -- PEP Purpose and Guidelines . Pythons Function Call Semantics # Function-call arguments are suggested in PEP variables in the scope of the caller. Traditional function call semantics are: call-by-value: the value of the argument-variable is copied to the call-parameter of the function changing the value inside the function doesn't effect the caller call-by-reference: a reference of the caller's variable is passed to the call-parameter of the function as a consequence, changes to variable inside the function will affect the callers variable (side-effect from callee back to the caller) alongside the function return value, this provides additional communication-channels between caller and callee Python function call semantics instead are controlled by the mutability/immutability of the Python objects of the caller's function-call arguments. argument variable refering an immutable object: Will work without side-effects to the callee even, when the functions is changing the value, this is due to the copy-on-write behaviour argument variable refering a mutable object may have side-effects to the callee, when the variable is changed inside the function function-call with immutable call-argument >>> a = 1 >>> id ( 1 ) # (1) 139752035048832 >>> def increment ( a ): ... print ( id ( a )) # (2) refers to the same object as the callers variable (1) ... a += 1 # (3) copy-on-write creates new object ... print ( id ( a )) # (4) new object dur to (3) ... return a ... >>> b = increment ( a ) 139752035048832 139752035048864 >>> a 1 >>> id ( a ) # (4) refers to the same object as in (1) 139752035048832 >>> Note: Immutable objects of the caller are not effected by changes in the callee function-call with mmutable call-argument >>> d1 = { 'a' : 1 , 'b' : 2 } >>> id ( d1 ) # (1) 139752035393824 >>> def change_callee_object ( d ): ... print ( id ( d )) # (2) refers to the same object as the callers variable (1) ... for elem in d . keys (): d [ elem ] += 1 # (3) no copy is made, changes apply to origin object ... print ( id ( d )) # (4) refers to the origin object (1), (2) ... return d ... >>> d2 = change_callee_object ( d1 ) 139752035393824 139752035393824 >>> d1 # site-effect caused by function-call with mutable argument { 'a' : 2 , 'b' : 3 } >>> id ( d1 ) 139752035393824 >>> d2 { 'a' : 2 , 'b' : 3 } >>> id ( d2 ) 139752035393824 >>> Note: Function-calls with mutable objects may have site-effect to the callee","title":"Chapter 4: Functions"},{"location":"training/main-course/functions/#functions","text":"Providing repeating tasks or calculation in functions is an effective way of code-reuse (\"write-once-use-many\"). This is a brief introduction of Python functions, not covering all possible variations of function-definitions. More on this can be found in the official Python docs https://docs.python.org/3/tutorial/controlflow.html#more-on-defining-functions . Function itself are Python objects, as such they can e.g be assigned, passed as parameters to or returned from functions, more on that later.","title":"Functions"},{"location":"training/main-course/functions/#function-definition","text":"In Python user-defined functions are defined using the def -statement. A function definition is made up a function-header (defining the function-name and the call-signature) and a function-body (the implementation of the task/calculation as a sequence of code statements ending up with an optional return-statement). Python allows different ways of function-definitions as described in the following subsections. Note: Often the term \"argument\" and \"parameter\" are used interchangeable, but this is a little bit diffuse. More precise are the terms \"actual parameter\" for \"argument\" for variables or values in function-calls and \"formal parameter\" for parameter-names in function-definitions. Here the term \"argument\" is used for the variable/values in function-calls, the term \"parameter is used for parameter-names in function-definitions.","title":"Function Definition"},{"location":"training/main-course/functions/#function-with-simple-parameters","text":"function-definition example >>> def increment ( a , stride ): # function-header ... ''' Purpose: Increment a with stride ''' # optional doc-string ... # function-body ... c = a + stride ... return c ... >>> A function-call is done simply writing the function-name following a tuple of positional call-arguments function-call example >>> result = increment ( 1 , 2 ) >>> print ( result ) 3 >>> Note: The number of parameters equal the number of call-arguments. Also the order of the call-parameter must match the order of function-parameters: During the function-call the 1.st call-argument is mapped to the 1.st function-parameter, the 2.nd call-argument is mapped to the 2.nd function-parameter, i.e a position-based mapping from the call-arguments to the function-parameters (call-arguments here are positional arguments ) Let's give it a try Lesson: Check palindromes Create a function that takes a single string argument returns True if string is a palindrome, False otherwise (1) Use a loop for implementation (2) Try an alternative implementation using \"extended slicing\": Check word == word[::-1] test the function by calling it with a palindrome-word and a Optionally: Create a python script check_palindrom.py that asks the user to enter a word to be checked to be a palindrom python3 check_palindrom.py Please enter a word: abba word: abba - reversed-word: abba # optional output is_palindrom: abba ==> True python3 check_palindrom.py Please enter a word: foo word: foo - reversed-word: oof # optional output is_palindrom: foo ==> False Hint: use input() -builtin for user-input Optionally: Instead of user input provide a command line argument to your python script. Hint: Command line argument can be accessed using sys.argv .","title":"Function with simple parameters"},{"location":"training/main-course/functions/#function-with-optional-parameters","text":"Optional parameters are parameters with assigned default values in the function-definition. Those optional parameters may be omitted during the function-call. function-definition example - utilizing default-paramater value >>> def increment ( a , stride = 1 ): # function-header with default-argument ... ''' Purpose: Increment a with stride ''' # optional doc-string ... # function-body ... c = a + stride ... return c ... >>> function-call example (1) - omitting optional parameter >>> result = increment ( 1 ) >>> print ( result ) 2 >>> function-call example (2) - overwriting default-value of optional-parameter >>> result = increment ( 1 , 5 ) >>> print ( result ) 6 >>> Note 1: Function-call can be made using only with arguments for parameters, where no default-agument are defined Note 2: Optional-parameters must be defined at the end of the function-parameter-list. Otherhwise a SyntaxError is raised, e.g. >>> def a ( a , b = 1 , c ): ... return ( a + b + c ) ... File \"<stdin>\" , line 1 SyntaxError : non - default argument follows default argument","title":"Function with optional parameters"},{"location":"training/main-course/functions/#function-with-variable-parameter-list-variadic-parameter","text":"A function can be defined having a variable-parameter-list. This is specified in preceding the last parameter with an asterisk-character * in the function definition. function-definition >>> def print_info ( header , footer , * args ): # 2 normal parameter & variable-length-parameter ... print ( header ) ... for elem in args : print ( elem ) ... print ( footer ) ... >>> varargs-function-call (1) >>> print_info ( '-->' , '<--' , 'Hello' , 'World' ) # last 2 arguments are mapped as a tuple into the *-parameter --> Hello World <-- >>> varargs-function-call (2) >>> print_info ( '-->' , '<--' , 'Tic' , 'Tac' , 'Toe' ) # last 3 arguments are mapped as a tuple into the *-parameter --> Tic Tac Toe <-- >>>","title":"Function with variable parameter list (variadic parameter)"},{"location":"training/main-course/functions/#keyword-arguments","text":"In the above sections the functions are called with positional arguments , see Note above. In addition function can also be called using named arguments (keyword arguments). To demonstrate this, we use the increment -function-definition from above. * function-definition * >>> def increment ( a , stride = 1 ): # function-header ... ''' Purpose: Increment a with stride ''' # optional doc-string ... # function-body ... c = a + stride ... return c ... >>> function-call using keyword parameter (1) >>> increment ( a = 1 ) 2 >>> function-call using keyword parameter (2) >>> increment ( stride = 3 , a = 1 ) 4 >>> Note Using keyword-arguments the position of the call-argument doesn't matter","title":"Keyword Arguments"},{"location":"training/main-course/functions/#function-with-additional-keyword-parameter","text":"Additionally Python allows function-definitions with arbitray additional keyword-paramaters. This is specified in preceeding the last parmeter with double-asterisk character ** . Additional kewyword-arguments are mapped during the function-call into a dictionary for the keyword-parameter of the function definition function-definition with keyword-parameters >>> def print_info ( header , footer , * args , ** kwargs ): ... print ( header ) ... for elem in args : print ( elem ) ... for elem in kwargs . keys (): print ( ' %s : %s ' % ( elem , kwargs [ elem ])) ... print ( footer ) ... >>> function-call >>> print_info ( '-->' , '<--' , 'Madrid' , 'Berlin' , 'Paris' , capitols_of = 'European Countries' , belonging_to = 'EU' ) --> Madrid Berlin Paris capitols_of : European Countries belonging_to : EU <-- >>>","title":"Function with additional keyword parameter"},{"location":"training/main-course/functions/#function-return-value","text":"Python allows the return of mutiple values. >>> def divide ( number , div ): ... '''Division returning truncated division and modulo''' ... d = number // div ... m = number % div ... return d , m ... >>> d , m = divide ( 9 , 4 ) >>> d 2 >>> m 1 >>>","title":"Function Return Value"},{"location":"training/main-course/functions/#inner-functions","text":"Functions can be defined at every place, at module-level, inside classes (methods), but also inside functions. function definition >>> def outer_func ( inner_func ): ... ''' function which defines inner functions''' ... def x (): ... print ( x . __name__ ) ... def y (): ... print ( y . __name__ ) ... # return an inner function, simply by its name ... if inner_func == 1 : ... return x ... else : ... return y ... >>> function-call >>> a_func = outer_func ( 1 ) # assign a function >>> a_func () # call the function x >>> b_func = outer_func ( 2 ) # assign a function >>> b_func () # call the function y >>> Note: As can be seen, functions are like ordinary Python objects that can be returned and assigned.","title":"Inner functions"},{"location":"training/main-course/functions/#functions-annotations","text":"Function Annotations allow programmers to associate meta-information to a function-header. One kind of interesting mata-information are so called 'type-hints', which can provide 'type-information' about the function-paramertes and return-value. Function annotations are stored in the __annotations__ attribute of a function object. Function Annotation example >>> def concatenate ( string_1 : str , string_2 : str ) -> str : ... return string_1 + string_2 ... >>> concate ( 'foo' , 'bar' ) 'foobar' >>> concate . __annotations__ { 'string_1' : < class ' str '>, ' string_2 ': <class ' str '>, ' return ': <class ' str '>} >>> For a more detailed inforamtions please refer to PEP 3107 -- Function Annotations and PEP 484 -- Type Hints Note 1: Function annotations are optional, they are just informations. They are neither evaluated nor their compliance is enforced by the interpreter itself. It's provided in the language, helping other libraries do some type-checking. Note 2: 'Type Hints'-support is implemented in the Python standard library typing . Note 3: PEP - Python Enhancement Proposal - is the official process of suggesting enhancements to the Python language, please read PEP 001 -- PEP Purpose and Guidelines .","title":"Functions Annotations"},{"location":"training/main-course/functions/#pythons-function-call-semantics","text":"Function-call arguments are suggested in PEP variables in the scope of the caller. Traditional function call semantics are: call-by-value: the value of the argument-variable is copied to the call-parameter of the function changing the value inside the function doesn't effect the caller call-by-reference: a reference of the caller's variable is passed to the call-parameter of the function as a consequence, changes to variable inside the function will affect the callers variable (side-effect from callee back to the caller) alongside the function return value, this provides additional communication-channels between caller and callee Python function call semantics instead are controlled by the mutability/immutability of the Python objects of the caller's function-call arguments. argument variable refering an immutable object: Will work without side-effects to the callee even, when the functions is changing the value, this is due to the copy-on-write behaviour argument variable refering a mutable object may have side-effects to the callee, when the variable is changed inside the function function-call with immutable call-argument >>> a = 1 >>> id ( 1 ) # (1) 139752035048832 >>> def increment ( a ): ... print ( id ( a )) # (2) refers to the same object as the callers variable (1) ... a += 1 # (3) copy-on-write creates new object ... print ( id ( a )) # (4) new object dur to (3) ... return a ... >>> b = increment ( a ) 139752035048832 139752035048864 >>> a 1 >>> id ( a ) # (4) refers to the same object as in (1) 139752035048832 >>> Note: Immutable objects of the caller are not effected by changes in the callee function-call with mmutable call-argument >>> d1 = { 'a' : 1 , 'b' : 2 } >>> id ( d1 ) # (1) 139752035393824 >>> def change_callee_object ( d ): ... print ( id ( d )) # (2) refers to the same object as the callers variable (1) ... for elem in d . keys (): d [ elem ] += 1 # (3) no copy is made, changes apply to origin object ... print ( id ( d )) # (4) refers to the origin object (1), (2) ... return d ... >>> d2 = change_callee_object ( d1 ) 139752035393824 139752035393824 >>> d1 # site-effect caused by function-call with mutable argument { 'a' : 2 , 'b' : 3 } >>> id ( d1 ) 139752035393824 >>> d2 { 'a' : 2 , 'b' : 3 } >>> id ( d2 ) 139752035393824 >>> Note: Function-calls with mutable objects may have site-effect to the callee","title":"Pythons Function Call Semantics"},{"location":"training/main-course/grasping-python/","text":"You gotta understand: Important things for grasping Python # Syntax # Just the basic rules to be able to understand Python code, informally. Statements # Single statement : A single statement is an executable instruction ending with a newline or semicolon. A statement changes the state of the program. Expressions # An expression is a sequence of operands and operators evaluating to a single value. Operands can be expressions themselves. Examples: \"foo\" # string literal 3.14 # float literal True # boolean literal a # simple identifier a + b # simple expression using add-operator x == y # simple expression using equal-comparison operator id ( x ) # simple expression using id()-builtin function getting the # object id of the object the variable 'x' refers to a is b # simple expression using 'is'-operator # (check identity as with id()-builtin function) The evaluation (calculation) of an expression itself is triggered by an appropriate statement - in an interactive interpreter session this means you need to finish your entered expression with a carriage return (newline), this will make an expression statement out of an expression. Expressions are printable and assignable. Because expressions are assignable, they form the smallest unit of reusable code. Example 1 - expression statement: >>> 5 + 3 # expression-statement 8 >>> Operands and Operators # Operands are literals, identifiers (variable names) or functions returning a single value. Operators are (meaningful) links between operands. Assignments # Example 2 - assignment statement >>> a = 5 + 3 # assignment-statement >>> a # expression-statement 8 >>> Indentation # Grouping statements - i.e. building code blocks - is the basis for structuring a program. Organized in \"higher-level\" building blocks like functions, classes, modules and packages, they provide reusable code fragments. A sensible \"program organization\" is crucial for creating - understandable - maintainable - extendible - testable code. Python uses indentation to denote blocks of code (as opposed to e.g. {} braces in many other languages). 1 Many love it, some don't care all that much, a few hate it. We believe that this is one reason why Python is so inherently readable. Consecutive statements can be grouped together forming a code block using the same indentation level: >>> if need_cake : >>> make_dough () # three >>> add_toppings () # steps >>> bake () # in the same code block Indentation must be consistent: >>> if True : ... print ( 'True!' ) ... print ( 'Still true.' ) File \"<stdin>\" , line 3 print ( 'Still true.' ) ^ IndentationError : unexpected indent Always use 4 spaces for one level of indentation. 2 Comments # Comments are used for documenting the code in-place. A comment starts with a \"#\" and ends at the end of a line: >>> # a comment ... print ( 'something' ) # an inline comment something The Python interpreter ignores comments. Literals # Numeric Literals # >>> 12345 # integer 12345 >>> 123.45 # floating-point number 123.45 >>> 1 + 3 j # complex number with real and imaginary part ( 1 + 3 j ) >>> 1.1 + 3.1 J # another complex number with real and imaginary part ( 1.1 + 3.1 j ) You can optionally separate big numbers for easier human reading: >>> 1000_000_000 # not peanuts 1000000000 String Literals # All these are valid string literals i.e. text or \"sequences of characters\": >>> \"\"\"text\"\"\" 'text' >>> '''text''' 'text' >>> \"text\" 'text' >>> 'text' 'text' You can use the different variations to avoid escaping. I.e. instead of >>> 'Guido \\' s time machine' \"Guido's time machine\" simply use >>> \"Guido's time machine\" \"Guido's time machine\" >>> Docstrings # A string literal as 1 st statement in a module, a function or a class definition will become the so-called \"documentation string\" of this object, which is accessible as the object's __doc__ attribute: A documented function: >>> def noop ( x ): ... \"\"\"noop does nothing, really.\"\"\" ... return x ... >>> noop . __doc__ 'noop does nothing, really.' A documented class: >>> class Animal : ... \"\"\"I'm a beast. ... \"\"\" ... >>> Animal . __doc__ \"I'm a beast. \\n \" >>> A documented module: $ cat mymodule . py \"\"\"This is my module's docstring. \"\"\" import os print ( os ) $ python3 - q >>> import mymodule < module 'os' from '/opt/subtools/current/lib/python3.6/os.py' > >>> mymodule . __doc__ \"This is my module's docstring. \\n \" >>> If for some reason you can't put this docstring as the first module statement you may alternatively just set __doc__ (as a module-global variable): $ cat mymodule2 . py import os # for some reason we want to do this first __doc__ = \"\"\"This is my module's docstring. \"\"\" print ( os ) $ python3 - q >>> import mymodule2 < module 'os' from '/opt/subtools/current/lib/python3.6/os.py' > >>> mymodule2 . __doc__ \"This is my module's docstring. \\n \" >>> Valid Identifiers & Reserved Words # Identifiers are the names you are allowed to use e.g. for variable, function or class names. You can find out all there is to know about identifiers here: https://docs.python.org/3/reference/lexical_analysis.html#identifiers As a basic rule of thumb identifiers consist of letters A to Z (uppercase and lowercase), the underscore _ and digits 0 to 9. Identifiers must not start with a digit. 3 Identifiers are case-sensitive. Reserved words are the language keywords which are not allowed for use as a name: False await else import pass None break except in raise True class finally is return and continue for lambda try as def from nonlocal while assert del global not with async elif if or yield Source code encoding # Source code is text data. The binary representation of text data (e.g. when stored in a file) is called an \"encoding\". It is important to know the encoding of a text file since different encodings are capable of representing different characters and interpret the binary data as different characters (e.g. the ISO-8859-1 encoding does not contain the \u20ac (EUR) sign (but the \u00a4 \"general currency sign\"), whereas the ISO-8859-15 encoding does; the byte A4 is thus interpreted differently by these encodings) A special comment on the 1 st or 2 nd line # -*- coding: <encoding-name> -*- explicitly denotes the source code file encding. The default Python source code encoding is UTF-8 . Line Continuation # Usually a statement ends with a newline. If long statements need to be formatted to span multiple lines for readability the line continuation character \"\\\" can be used. This is called explicit line joining: x = ( operand1 + operand2 ) * \\ ( operand1 - operand2 ) As code enclosed in parentheses (...) (and brackets [...], braces {...} and triple quotes) can span multiple line the line continuation character is often unnecessary: \"\"\"A long docstring comment on this example. Triple-quoted strings can span multiple lines. \"\"\" if ( condition_a and condition_b and condition_c ): do_this () german_month_names = [ # comments are allowed 'Januar' , 'Februar' , 'M\u00e4rz' , # Q1 'April' , 'Mai' , 'Juni' , # Q2 'Juli' , 'August' , 'September' , # Q3 'Oktober' , 'November' , 'Dezember' # Q4 ] # dictionaries more often than not span lines german_months = { 1 : 'Januar' , 2 : 'Februar' , 3 : 'M\u00e4rz' , 4 : 'April' , 5 : 'Mai' , 6 : 'Juni' , 7 : 'Juli' , 8 : 'August' , 9 : 'September' , 10 : 'Oktober' , 11 : 'November' , 12 : 'Dezember' } This is called implicit line joining. Tip: This and Python's implicit string concatenation can be used to format lines: >>> \"12\" \"34\" \"56\" # implicit string concatenation '123456' >>> hash ( \"12\" ... \"34\" ... \"56\" ) 239865887022063660 >>> hash ( \"123456\" ) 239865887022063660 This can be handy e.g. for formatting function calls with longer string parameters (i.e. not so short as in this example...). Annotations # Function Annotations # Optional function annotations can be used e.g. as a means to more clearly document the type(s) of arguments a function (or method) expects: def say_hello ( name : str ) -> str : return 'Hello {} !' . format ( name ) This information can be accessed at runtime: >> def say_hello ( name : str ) -> str : ... return 'Hello {} !' . format ( name ) ... >>> say_hello . __annotations__ { 'name' : < class ' str '>, ' return ': <class ' str '>} >>> Note that the Python interpreter does not do any type checking using this information: >>> say_hello ( 'Lisa' ) 'Hello Lisa!' >>> say_hello ( 8.5 ) 'Hello 8.5!' >>> A function annotation is actually an expression i.e. not necessarily limited to a type. The expression is evaluated at function definition execution: >>> def say_hello ( name : 'what' + '?' ) -> 7 + 3 : ... return 'Hello {} !' . format ( name ) ... >>> say_hello . __annotations__ { 'name' : 'what?' , 'return' : 10 } >>> Function annotations gain meaning by usage in libraries or tools; the Python interpreter does not do anything with them apart from evaluating the expressions when the function definition is executed and thus \"associating\" this information with the function properties (i.e. its parameters and return values) Function annotations can be used for several purposes, e.g. in optional \"compile time\" type checkers in editors or IDEs to to implement \"generic functions\" that dispatch on parameter type and more. Variable Annotations # In the same way function parameters and return types may b annotated you can annotate (module, class or instance) variables: An annotated variable: >>> x : str = \"text\" >>> x 'text' Again, the annotations can be accessed through the __annoations__ dict: >>> __annotations__ # module-level (here: interactive session) { 'x' : < class ' str '>} >>> An annotated class: >>> class Knight : ... knows : str = 'ni' ... ... def __init__ ( self , words : list ): ... self . words : str = words ... ... def say_something ( self ): ... print ( self . knows ) ... ... def say_something_personal ( self ): ... print ( ' ' . join ( self . words )) ... >>> knight = Knight ([ 'my' , 'words' ]) >>> knight . say_something () ni >>> knight . say_something_personal () my words Annotations are now available at class or instance level: >>> Knight . __annotations__ # class level { 'knows' : < class ' str '>} >>> >>> knight . __init__ . __annotations__ # instance level { 'words' : < class ' list '>} >>> knight . __annotations__ { 'knows' : < class ' str '>} >>> Like other annotations these are optional and not used by the interpeter itself but libraries and tools. See the typing stdlib module documentation for infrastructure with regard to (type hint) annotation. Decorators # The @ -syntax introduces decorators: >>> @some_decorator ... def f (): ... pass ... See the decorators chapter for more information. Names and Objects # Python variables are names for objects. An object can have many names: >>> x = 1 >>> y = x >>> x 1 >>> y 1 >>> l1 = [ 1 , 2 , 3 ] >>> l2 = l1 >>> l1 [ 1 , 2 , 3 ] >>> l2 [ 1 , 2 , 3 ] But it is still the same object: >>> x is y # is checks for object identity True >>> l1 is l2 True >>> id ( x ), id ( y ) # id() returns an object's unique id ( 140700697906560 , 140700697906560 ) >>> id ( l1 ), id ( l2 ) ( 140700698907784 , 140700698907784 ) Compare that to the meaning of variables in other languages, e.g. C. In C (or C++) a variable is basically the in-program name for a \"memory cell\" (a memory location that can hold a value of the type declared for that variable ). Thus, assignment in C/C++ means writing a value of the proper type into that \"memory cell\". Whereas a variable in Python is rather one \"label\" (of potentially many) for an object in a sense more analogous to a C++ reference or a C pointer: a name for an object. Consequently, assignment in Python means \"pinning\" a new name to an object; it never copies data. 4 Deleting a name doesn't affect object existence: >>> del x >>> y 1 (as long as there is still a name (or another object) referencing that object) Further reading : A great in-depth explanation can be found here . Python Scoping # A scope defines the visibility of names. The lookup of names in Python obeys the \"LEGB\"-Rule: L ocal E nclosing G lobal B uiltin The workings of LEGB by example: >>> global_x = \"I'm global\" >>> >>> def f (): # functions define scope ... print ( global_x ) # lookup in local scope (nothing), then in global scope ... ... def inner (): ... local_z = \"I'm local\" # a name in inner local scope ... print ( local_z ) ... print ( enclosing_y ) # local (nothing), enclosing -> enclosing_y ... print ( global_x ) # local (nothing), enclosing (nothing), ... # global -> global_x ... print ( 'print() is a built-in!' ) ... ... # variable in local scope of f == enclosing scope of inner ... enclosing_y = \"I'm enclosing (for inner), local for f\" ... # run inner function ... inner () ... >>> f () I 'm global I 'm local I 'm enclosing (for inner), local for f I 'm global print () is a built - in ! >>> Python Classes \"Unscoped\" # Note that the class body block of a class definition does not form an enclosing scope for the methods of the class: >> class FunctionsDefineScope : ... ... # class attributes ... cls_var = 'common' ... another_cls_var = 'also ' + cls_var # name in the same scope is usable ... ... def show_me ( self ): ... # class body is not an enclosing scope for method body... ... ... # access class attributes... ... # ...through class ... print ( FunctionsDefineScope . cls_var , ... FunctionsDefineScope . another_cls_var ) ... # ...through instance ... print ( self . cls_var , self . another_cls_var ) ... ... # this will raise: ... print ( cls_var , another_cls_var ) ... >>> fds = FunctionsDefineScope () >>> fds . show_me () common also common common also common Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"<stdin>\" , line 17 , in show_me NameError : name 'cls_var' is not defined >>> Style guide # Python has a widely accepted style guide . Follow it. Be pythonic # Python programmers often strive to write code that is said to be \"pythonic\", which means it has a certain quality of beauty (as in being working, functional, elegant yet maintainable and readable). While \"pythonic\" can understandably not be a very well-defined term the Zen of Python is a collection of Python's language design guiding principles which can also be put to good use in your quest to write \"pythonic\" code. E.g in Java or C, the semicolon ; is used as single-statement-delimiter, the curly braces { } are used for code blocks. \u21a9 While this is not mandatory and enforced just do it . \u21a9 Since Python 3.0 you can actually use other unicode characters in identifiers though in international codebases, the ASCII range characters prevail. \u21a9 Whereas in C/C++ assignment usually copies data. \u21a9","title":"Chapter 1: Grasping Python"},{"location":"training/main-course/grasping-python/#you-gotta-understand-important-things-for-grasping-python","text":"","title":"You gotta understand: Important things for grasping Python"},{"location":"training/main-course/grasping-python/#syntax","text":"Just the basic rules to be able to understand Python code, informally.","title":"Syntax"},{"location":"training/main-course/grasping-python/#statements","text":"Single statement : A single statement is an executable instruction ending with a newline or semicolon. A statement changes the state of the program.","title":"Statements"},{"location":"training/main-course/grasping-python/#expressions","text":"An expression is a sequence of operands and operators evaluating to a single value. Operands can be expressions themselves. Examples: \"foo\" # string literal 3.14 # float literal True # boolean literal a # simple identifier a + b # simple expression using add-operator x == y # simple expression using equal-comparison operator id ( x ) # simple expression using id()-builtin function getting the # object id of the object the variable 'x' refers to a is b # simple expression using 'is'-operator # (check identity as with id()-builtin function) The evaluation (calculation) of an expression itself is triggered by an appropriate statement - in an interactive interpreter session this means you need to finish your entered expression with a carriage return (newline), this will make an expression statement out of an expression. Expressions are printable and assignable. Because expressions are assignable, they form the smallest unit of reusable code. Example 1 - expression statement: >>> 5 + 3 # expression-statement 8 >>>","title":"Expressions"},{"location":"training/main-course/grasping-python/#operands-and-operators","text":"Operands are literals, identifiers (variable names) or functions returning a single value. Operators are (meaningful) links between operands.","title":"Operands and Operators"},{"location":"training/main-course/grasping-python/#assignments","text":"Example 2 - assignment statement >>> a = 5 + 3 # assignment-statement >>> a # expression-statement 8 >>>","title":"Assignments"},{"location":"training/main-course/grasping-python/#indentation","text":"Grouping statements - i.e. building code blocks - is the basis for structuring a program. Organized in \"higher-level\" building blocks like functions, classes, modules and packages, they provide reusable code fragments. A sensible \"program organization\" is crucial for creating - understandable - maintainable - extendible - testable code. Python uses indentation to denote blocks of code (as opposed to e.g. {} braces in many other languages). 1 Many love it, some don't care all that much, a few hate it. We believe that this is one reason why Python is so inherently readable. Consecutive statements can be grouped together forming a code block using the same indentation level: >>> if need_cake : >>> make_dough () # three >>> add_toppings () # steps >>> bake () # in the same code block Indentation must be consistent: >>> if True : ... print ( 'True!' ) ... print ( 'Still true.' ) File \"<stdin>\" , line 3 print ( 'Still true.' ) ^ IndentationError : unexpected indent Always use 4 spaces for one level of indentation. 2","title":"Indentation"},{"location":"training/main-course/grasping-python/#comments","text":"Comments are used for documenting the code in-place. A comment starts with a \"#\" and ends at the end of a line: >>> # a comment ... print ( 'something' ) # an inline comment something The Python interpreter ignores comments.","title":"Comments"},{"location":"training/main-course/grasping-python/#literals","text":"","title":"Literals"},{"location":"training/main-course/grasping-python/#numeric-literals","text":">>> 12345 # integer 12345 >>> 123.45 # floating-point number 123.45 >>> 1 + 3 j # complex number with real and imaginary part ( 1 + 3 j ) >>> 1.1 + 3.1 J # another complex number with real and imaginary part ( 1.1 + 3.1 j ) You can optionally separate big numbers for easier human reading: >>> 1000_000_000 # not peanuts 1000000000","title":"Numeric Literals"},{"location":"training/main-course/grasping-python/#string-literals","text":"All these are valid string literals i.e. text or \"sequences of characters\": >>> \"\"\"text\"\"\" 'text' >>> '''text''' 'text' >>> \"text\" 'text' >>> 'text' 'text' You can use the different variations to avoid escaping. I.e. instead of >>> 'Guido \\' s time machine' \"Guido's time machine\" simply use >>> \"Guido's time machine\" \"Guido's time machine\" >>>","title":"String Literals"},{"location":"training/main-course/grasping-python/#docstrings","text":"A string literal as 1 st statement in a module, a function or a class definition will become the so-called \"documentation string\" of this object, which is accessible as the object's __doc__ attribute: A documented function: >>> def noop ( x ): ... \"\"\"noop does nothing, really.\"\"\" ... return x ... >>> noop . __doc__ 'noop does nothing, really.' A documented class: >>> class Animal : ... \"\"\"I'm a beast. ... \"\"\" ... >>> Animal . __doc__ \"I'm a beast. \\n \" >>> A documented module: $ cat mymodule . py \"\"\"This is my module's docstring. \"\"\" import os print ( os ) $ python3 - q >>> import mymodule < module 'os' from '/opt/subtools/current/lib/python3.6/os.py' > >>> mymodule . __doc__ \"This is my module's docstring. \\n \" >>> If for some reason you can't put this docstring as the first module statement you may alternatively just set __doc__ (as a module-global variable): $ cat mymodule2 . py import os # for some reason we want to do this first __doc__ = \"\"\"This is my module's docstring. \"\"\" print ( os ) $ python3 - q >>> import mymodule2 < module 'os' from '/opt/subtools/current/lib/python3.6/os.py' > >>> mymodule2 . __doc__ \"This is my module's docstring. \\n \" >>>","title":"Docstrings"},{"location":"training/main-course/grasping-python/#valid-identifiers-reserved-words","text":"Identifiers are the names you are allowed to use e.g. for variable, function or class names. You can find out all there is to know about identifiers here: https://docs.python.org/3/reference/lexical_analysis.html#identifiers As a basic rule of thumb identifiers consist of letters A to Z (uppercase and lowercase), the underscore _ and digits 0 to 9. Identifiers must not start with a digit. 3 Identifiers are case-sensitive. Reserved words are the language keywords which are not allowed for use as a name: False await else import pass None break except in raise True class finally is return and continue for lambda try as def from nonlocal while assert del global not with async elif if or yield","title":"Valid Identifiers &amp; Reserved Words"},{"location":"training/main-course/grasping-python/#source-code-encoding","text":"Source code is text data. The binary representation of text data (e.g. when stored in a file) is called an \"encoding\". It is important to know the encoding of a text file since different encodings are capable of representing different characters and interpret the binary data as different characters (e.g. the ISO-8859-1 encoding does not contain the \u20ac (EUR) sign (but the \u00a4 \"general currency sign\"), whereas the ISO-8859-15 encoding does; the byte A4 is thus interpreted differently by these encodings) A special comment on the 1 st or 2 nd line # -*- coding: <encoding-name> -*- explicitly denotes the source code file encding. The default Python source code encoding is UTF-8 .","title":"Source code encoding"},{"location":"training/main-course/grasping-python/#line-continuation","text":"Usually a statement ends with a newline. If long statements need to be formatted to span multiple lines for readability the line continuation character \"\\\" can be used. This is called explicit line joining: x = ( operand1 + operand2 ) * \\ ( operand1 - operand2 ) As code enclosed in parentheses (...) (and brackets [...], braces {...} and triple quotes) can span multiple line the line continuation character is often unnecessary: \"\"\"A long docstring comment on this example. Triple-quoted strings can span multiple lines. \"\"\" if ( condition_a and condition_b and condition_c ): do_this () german_month_names = [ # comments are allowed 'Januar' , 'Februar' , 'M\u00e4rz' , # Q1 'April' , 'Mai' , 'Juni' , # Q2 'Juli' , 'August' , 'September' , # Q3 'Oktober' , 'November' , 'Dezember' # Q4 ] # dictionaries more often than not span lines german_months = { 1 : 'Januar' , 2 : 'Februar' , 3 : 'M\u00e4rz' , 4 : 'April' , 5 : 'Mai' , 6 : 'Juni' , 7 : 'Juli' , 8 : 'August' , 9 : 'September' , 10 : 'Oktober' , 11 : 'November' , 12 : 'Dezember' } This is called implicit line joining. Tip: This and Python's implicit string concatenation can be used to format lines: >>> \"12\" \"34\" \"56\" # implicit string concatenation '123456' >>> hash ( \"12\" ... \"34\" ... \"56\" ) 239865887022063660 >>> hash ( \"123456\" ) 239865887022063660 This can be handy e.g. for formatting function calls with longer string parameters (i.e. not so short as in this example...).","title":"Line Continuation"},{"location":"training/main-course/grasping-python/#annotations","text":"","title":"Annotations"},{"location":"training/main-course/grasping-python/#function-annotations","text":"Optional function annotations can be used e.g. as a means to more clearly document the type(s) of arguments a function (or method) expects: def say_hello ( name : str ) -> str : return 'Hello {} !' . format ( name ) This information can be accessed at runtime: >> def say_hello ( name : str ) -> str : ... return 'Hello {} !' . format ( name ) ... >>> say_hello . __annotations__ { 'name' : < class ' str '>, ' return ': <class ' str '>} >>> Note that the Python interpreter does not do any type checking using this information: >>> say_hello ( 'Lisa' ) 'Hello Lisa!' >>> say_hello ( 8.5 ) 'Hello 8.5!' >>> A function annotation is actually an expression i.e. not necessarily limited to a type. The expression is evaluated at function definition execution: >>> def say_hello ( name : 'what' + '?' ) -> 7 + 3 : ... return 'Hello {} !' . format ( name ) ... >>> say_hello . __annotations__ { 'name' : 'what?' , 'return' : 10 } >>> Function annotations gain meaning by usage in libraries or tools; the Python interpreter does not do anything with them apart from evaluating the expressions when the function definition is executed and thus \"associating\" this information with the function properties (i.e. its parameters and return values) Function annotations can be used for several purposes, e.g. in optional \"compile time\" type checkers in editors or IDEs to to implement \"generic functions\" that dispatch on parameter type and more.","title":"Function Annotations"},{"location":"training/main-course/grasping-python/#variable-annotations","text":"In the same way function parameters and return types may b annotated you can annotate (module, class or instance) variables: An annotated variable: >>> x : str = \"text\" >>> x 'text' Again, the annotations can be accessed through the __annoations__ dict: >>> __annotations__ # module-level (here: interactive session) { 'x' : < class ' str '>} >>> An annotated class: >>> class Knight : ... knows : str = 'ni' ... ... def __init__ ( self , words : list ): ... self . words : str = words ... ... def say_something ( self ): ... print ( self . knows ) ... ... def say_something_personal ( self ): ... print ( ' ' . join ( self . words )) ... >>> knight = Knight ([ 'my' , 'words' ]) >>> knight . say_something () ni >>> knight . say_something_personal () my words Annotations are now available at class or instance level: >>> Knight . __annotations__ # class level { 'knows' : < class ' str '>} >>> >>> knight . __init__ . __annotations__ # instance level { 'words' : < class ' list '>} >>> knight . __annotations__ { 'knows' : < class ' str '>} >>> Like other annotations these are optional and not used by the interpeter itself but libraries and tools. See the typing stdlib module documentation for infrastructure with regard to (type hint) annotation.","title":"Variable Annotations"},{"location":"training/main-course/grasping-python/#decorators","text":"The @ -syntax introduces decorators: >>> @some_decorator ... def f (): ... pass ... See the decorators chapter for more information.","title":"Decorators"},{"location":"training/main-course/grasping-python/#names-and-objects","text":"Python variables are names for objects. An object can have many names: >>> x = 1 >>> y = x >>> x 1 >>> y 1 >>> l1 = [ 1 , 2 , 3 ] >>> l2 = l1 >>> l1 [ 1 , 2 , 3 ] >>> l2 [ 1 , 2 , 3 ] But it is still the same object: >>> x is y # is checks for object identity True >>> l1 is l2 True >>> id ( x ), id ( y ) # id() returns an object's unique id ( 140700697906560 , 140700697906560 ) >>> id ( l1 ), id ( l2 ) ( 140700698907784 , 140700698907784 ) Compare that to the meaning of variables in other languages, e.g. C. In C (or C++) a variable is basically the in-program name for a \"memory cell\" (a memory location that can hold a value of the type declared for that variable ). Thus, assignment in C/C++ means writing a value of the proper type into that \"memory cell\". Whereas a variable in Python is rather one \"label\" (of potentially many) for an object in a sense more analogous to a C++ reference or a C pointer: a name for an object. Consequently, assignment in Python means \"pinning\" a new name to an object; it never copies data. 4 Deleting a name doesn't affect object existence: >>> del x >>> y 1 (as long as there is still a name (or another object) referencing that object) Further reading : A great in-depth explanation can be found here .","title":"Names and Objects"},{"location":"training/main-course/grasping-python/#python-scoping","text":"A scope defines the visibility of names. The lookup of names in Python obeys the \"LEGB\"-Rule: L ocal E nclosing G lobal B uiltin The workings of LEGB by example: >>> global_x = \"I'm global\" >>> >>> def f (): # functions define scope ... print ( global_x ) # lookup in local scope (nothing), then in global scope ... ... def inner (): ... local_z = \"I'm local\" # a name in inner local scope ... print ( local_z ) ... print ( enclosing_y ) # local (nothing), enclosing -> enclosing_y ... print ( global_x ) # local (nothing), enclosing (nothing), ... # global -> global_x ... print ( 'print() is a built-in!' ) ... ... # variable in local scope of f == enclosing scope of inner ... enclosing_y = \"I'm enclosing (for inner), local for f\" ... # run inner function ... inner () ... >>> f () I 'm global I 'm local I 'm enclosing (for inner), local for f I 'm global print () is a built - in ! >>>","title":"Python Scoping"},{"location":"training/main-course/grasping-python/#python-classes-unscoped","text":"Note that the class body block of a class definition does not form an enclosing scope for the methods of the class: >> class FunctionsDefineScope : ... ... # class attributes ... cls_var = 'common' ... another_cls_var = 'also ' + cls_var # name in the same scope is usable ... ... def show_me ( self ): ... # class body is not an enclosing scope for method body... ... ... # access class attributes... ... # ...through class ... print ( FunctionsDefineScope . cls_var , ... FunctionsDefineScope . another_cls_var ) ... # ...through instance ... print ( self . cls_var , self . another_cls_var ) ... ... # this will raise: ... print ( cls_var , another_cls_var ) ... >>> fds = FunctionsDefineScope () >>> fds . show_me () common also common common also common Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"<stdin>\" , line 17 , in show_me NameError : name 'cls_var' is not defined >>>","title":"Python Classes \"Unscoped\""},{"location":"training/main-course/grasping-python/#style-guide","text":"Python has a widely accepted style guide . Follow it.","title":"Style guide"},{"location":"training/main-course/grasping-python/#be-pythonic","text":"Python programmers often strive to write code that is said to be \"pythonic\", which means it has a certain quality of beauty (as in being working, functional, elegant yet maintainable and readable). While \"pythonic\" can understandably not be a very well-defined term the Zen of Python is a collection of Python's language design guiding principles which can also be put to good use in your quest to write \"pythonic\" code. E.g in Java or C, the semicolon ; is used as single-statement-delimiter, the curly braces { } are used for code blocks. \u21a9 While this is not mandatory and enforced just do it . \u21a9 Since Python 3.0 you can actually use other unicode characters in identifiers though in international codebases, the ASCII range characters prevail. \u21a9 Whereas in C/C++ assignment usually copies data. \u21a9","title":"Be pythonic"},{"location":"training/main-course/installation/","text":"Keeping a Python: Python installation # Linux # In most Linux distributions Python comes preinstalled. See https://docs.python.org/3/using/unix.html for further info. Windows # See https://docs.python.org/3/using/windows.html . MacOS # See https://docs.python.org/3/using/mac.html . Online Pythons # Instead of installing Python there are some cool options for using Python as a cloud-based service, from your browser: Repl.it: https://repl.it/ Python Anywhere: https://www.pythonanywhere.com Trinket: https://trinket.io Python Fiddle: http://pythonfiddle.com These solutions allow for varying degrees of \"not needing a local Python installation, at all\". At the very least, they are great for trying out simple things, from basically anywhere. And then, there's the incredible Jupyter Notebooks . Jupyter notebooks bundle documentation, code and data and can be used for amazing stuff. Starting out with Python, Jupyter now supports a wide range of languages and can also be used as a cloud-based service from here: https://jupyter.org/try","title":"Chapter 0: Installing Python"},{"location":"training/main-course/installation/#keeping-a-python-python-installation","text":"","title":"Keeping a Python: Python installation"},{"location":"training/main-course/installation/#linux","text":"In most Linux distributions Python comes preinstalled. See https://docs.python.org/3/using/unix.html for further info.","title":"Linux"},{"location":"training/main-course/installation/#windows","text":"See https://docs.python.org/3/using/windows.html .","title":"Windows"},{"location":"training/main-course/installation/#macos","text":"See https://docs.python.org/3/using/mac.html .","title":"MacOS"},{"location":"training/main-course/installation/#online-pythons","text":"Instead of installing Python there are some cool options for using Python as a cloud-based service, from your browser: Repl.it: https://repl.it/ Python Anywhere: https://www.pythonanywhere.com Trinket: https://trinket.io Python Fiddle: http://pythonfiddle.com These solutions allow for varying degrees of \"not needing a local Python installation, at all\". At the very least, they are great for trying out simple things, from basically anywhere. And then, there's the incredible Jupyter Notebooks . Jupyter notebooks bundle documentation, code and data and can be used for amazing stuff. Starting out with Python, Jupyter now supports a wide range of languages and can also be used as a cloud-based service from here: https://jupyter.org/try","title":"Online Pythons"},{"location":"training/main-course/io/","text":"Get it in (and out): (File) Input and Output # Programs can consume data from different input- and produce data into different output-'channels'. Generally speaking channels are a concept providing a common interface to concrete data-sources and data-sinks. Bute here we use the term 'channel' in a more fluffy sense, meaning we refer to concrete types of data-sources and data-sinks. Channel-interfaces typically provide open() close() read() (or: get() , ( receive() ) write() (or: put() , ( send() ) operations, sometimes named differently, as shown. Typical channels are: standard-input/standard-output streams: file-input/file-output (Text I/O, Binary I/O, Raw I/O) sockets: a 'network channel' Here we focus on 'Text I/O'-files ('text-stream') as concrete data-sources/-sinks. Open a file # Python provides the open() builtin function to open a file. If it doesn't exists an Exception is raised. The open() -call returns a 'file-object' (Remember: In Python everything is an object), sometimes called a 'file-descriptor', which provides typical file-operation methods. Access-Modes Files can be opened in different access-modes. The mode is provided as a parameter to the open() -call. Available modes are (copied from the help(open) -builtin call): ========= =============================================================== Character Meaning --------- --------------------------------------------------------------- 'r' open for reading ( default ) 'w' open for writing , truncating the file first 'x' create a new file and open it for writing 'a' open for writing , appending to the end of the file if it exists 'b' binary mode 't' text mode ( default ) '+' open a disk file for updating ( reading and writing ) 'U' universal newline mode ( deprecated ) ========= =============================================================== file open() -call Python's interactive help(open) -builtin gives a full description of the open() -builtin, here abbreviated: >>> help ( open ) Help on built - in function open in module io : open ( file , mode = 'r' , buffering =- 1 , encoding = None , errors = None , newline = None , closefd = T rue , opener = None ) Open file and return a stream . Raise IOError upon failure . file is either a text or byte string giving the name ( and the path if the file isn 't in the current working directory) of the file to be opened or an integer file descriptor of the file to be wrapped . ( If a file descriptor is given , it is closed when the returned I / O object is closed , unless closefd is set to False . ) ... < abbreviated > Note: Navigation in help() -mode - q (quit) - <enter> : Line down - <space> : Page down - On Windows the Python interpreter automatically 'quits' help-mode after reaching the end, on Linux you have toe enter q file open() in 'read-mode' - if it doesn't exists: >>> fd = open ( 'bar.txt' ) # same as open('bar.txt', 'r') Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > FileNotFoundError : [ Errno 2 ] No such file or directory : 'bar.txt' >>> file open() in 'read-mode' - if the file-exists >>> fd = open ( 'foo.txt' ) # same as open('foo.txt', 'r') >>> type ( fd ) < class ' _io . TextIOWrapper '> >>> The open() -builtin call will return a 'file-object' of type _io.TextIOWrapper . It will open an existing file named 'foo.txt' (expected to be in the current working directory cwd , i.e the directory you started the python interpreter) in 'read-mode'. If your file is in a different directory than the cwd , you have to provide a fully qualified file-name either with a relative-path to the cwd or an absolute-path starting from the file-system-root. Here a Unix-based example using / as path-separator (use \\ on Windows-Systems): Assume your cwd is /var/tmp/python_course/stundent_1 assume your file-location is /var/tmp/python_course/stundent_1/data then your qualified filename could be: relative: ./data/.foo.txt absolute: `/var/tmp/python course/stundent 1/data/foo.txt' Check available 'file-operations' (methods) and attributes of 'file-objects' A full set f available attributes and methods on (text-based)-file objects can be found in the Python docs of _io.TextIOWrapper . using dir() -builtin You can list the available attributes and methods of typical file-operations using the dir(<file-object>) -builtin function as shown here: >>> dir ( fd ) [ '_CHUNK_SIZE' , '__class__' , '__del__' , '__delattr__' , '__dict__' , '__dir__' , '__doc__' , '__enter__' , '__eq__' , '__exit__' , '__format__' , '__ge__' , '__getattribute__' , '__getstate__' , '__gt__' , '__hash__' , '__init__' , '__init_subclass__' , '__iter__' , '__le__' , '__lt__' , '__ne__' , '__new__' , '__next__' , '__reduce__' , '__reduce_ex__' , '__repr__' , '__setattr__' , '__sizeof__' , '__str__' , '__subclasshook__' , '_checkClosed' , '_checkReadable' , '_checkSeekable' , '_checkWritable' , '_finalizing' , 'buffer' , 'close' , 'closed' , 'detach' , 'encoding' , 'errors' , 'fileno' , 'flush' , 'isatty' , 'line_buffering' , 'mode' , 'name' , 'newlines' , 'read' , 'readable' , 'readline' , 'readlines' , 'seek' , 'seekable' , 'tell' , 'truncate' , 'writable' , 'write' , 'writelines' ] >>> using help() -builtin Again you can display the full description using the help(fd) -builtin on the returned file-object fd or any subsequent method or attribute e.g. help(fd.read) . Create a file # There is no explictit function to create a file. A file is implicitly created (if it doesn't exists) using the write() -method providing the mode-parameter w . >>> fd2 = open ( 'bar.txt' , 'w' ) >>> Note: Be aware of that w -mode will overwrite (truncate) a files content, if you need to keep it, use a -append mode. Read from a file # Assume the file 'foo.txt' contains the following 2-lines cat foo.txt abc def There are three ways getting the content of a file read number of characters complete file line-by-line Read some characters # file read() -call Here we ask for 2-characters in a read() -call >>> fd = open ( 'foo.txt' ) >>> fd . read ( 2 ) 'ab' >>> fd . read ( 2 ) 'c \\n ' >>> fd . read ( 2 ) 'de' >>> fd . read ( 2 ) 'f \\n ' >>> this can be looped >>> fd = open ( 'foo.txt' ) >>> s = None >>> while s != '' : ... s = fd . read ( 2 ) ... print ( repr ( s )) ... 'ab' 'c \\n ' 'de' 'f \\n ' '' >>> Note: read() returns the empty string '' when it reached the EOF (End Of File) Read the complete file # file read() -call If the read() is called without a parameter, it returns the complete content of the file . >>> fd = open ( 'foo.txt' ) >>> s = fd . read () >>> print ( s ) abc def >>> Read line-by-line # A file can be read line-by-line using the readline() -method of the file-objects, see help(fd.readline) : file readline() -call Read line-by-line >>> fd = open ( 'foo.txt' ) >>> s = None >>> while s != '' : ... s = fd . readline () ... print ( repr ( s )) ... 'abc \\n ' 'def \\n ' '' >>> Write to a file # File-writing needs a file-object opened in 'write'- or 'append'--mode. Assume you have an empty bar.txt file * file write() -call * >>> fd = open ( 'bar.txt' , 'w' ) # open the file in write-mode >>> fd . write ( 'abc \\n ' ) 4 >>> fd . write ( 'def \\n ' ) 4 >>> fd . flush () >>> * Note: * The written output is buffered until it reaches a dedicated size before it is finally written to the file. Flushing the buffer enforces writing the content to the buffer into the file. You can check the written file cat bar.txt abc def Close a file # To close a file use close() -method of the file-object file close() -call >>> fd . close () >>> Note: Never forget to close a file after finishing the file-processing.","title":"Chapter 8: (File) Input & Output"},{"location":"training/main-course/io/#get-it-in-and-out-file-input-and-output","text":"Programs can consume data from different input- and produce data into different output-'channels'. Generally speaking channels are a concept providing a common interface to concrete data-sources and data-sinks. Bute here we use the term 'channel' in a more fluffy sense, meaning we refer to concrete types of data-sources and data-sinks. Channel-interfaces typically provide open() close() read() (or: get() , ( receive() ) write() (or: put() , ( send() ) operations, sometimes named differently, as shown. Typical channels are: standard-input/standard-output streams: file-input/file-output (Text I/O, Binary I/O, Raw I/O) sockets: a 'network channel' Here we focus on 'Text I/O'-files ('text-stream') as concrete data-sources/-sinks.","title":"Get it in (and out): (File) Input and Output"},{"location":"training/main-course/io/#open-a-file","text":"Python provides the open() builtin function to open a file. If it doesn't exists an Exception is raised. The open() -call returns a 'file-object' (Remember: In Python everything is an object), sometimes called a 'file-descriptor', which provides typical file-operation methods. Access-Modes Files can be opened in different access-modes. The mode is provided as a parameter to the open() -call. Available modes are (copied from the help(open) -builtin call): ========= =============================================================== Character Meaning --------- --------------------------------------------------------------- 'r' open for reading ( default ) 'w' open for writing , truncating the file first 'x' create a new file and open it for writing 'a' open for writing , appending to the end of the file if it exists 'b' binary mode 't' text mode ( default ) '+' open a disk file for updating ( reading and writing ) 'U' universal newline mode ( deprecated ) ========= =============================================================== file open() -call Python's interactive help(open) -builtin gives a full description of the open() -builtin, here abbreviated: >>> help ( open ) Help on built - in function open in module io : open ( file , mode = 'r' , buffering =- 1 , encoding = None , errors = None , newline = None , closefd = T rue , opener = None ) Open file and return a stream . Raise IOError upon failure . file is either a text or byte string giving the name ( and the path if the file isn 't in the current working directory) of the file to be opened or an integer file descriptor of the file to be wrapped . ( If a file descriptor is given , it is closed when the returned I / O object is closed , unless closefd is set to False . ) ... < abbreviated > Note: Navigation in help() -mode - q (quit) - <enter> : Line down - <space> : Page down - On Windows the Python interpreter automatically 'quits' help-mode after reaching the end, on Linux you have toe enter q file open() in 'read-mode' - if it doesn't exists: >>> fd = open ( 'bar.txt' ) # same as open('bar.txt', 'r') Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > FileNotFoundError : [ Errno 2 ] No such file or directory : 'bar.txt' >>> file open() in 'read-mode' - if the file-exists >>> fd = open ( 'foo.txt' ) # same as open('foo.txt', 'r') >>> type ( fd ) < class ' _io . TextIOWrapper '> >>> The open() -builtin call will return a 'file-object' of type _io.TextIOWrapper . It will open an existing file named 'foo.txt' (expected to be in the current working directory cwd , i.e the directory you started the python interpreter) in 'read-mode'. If your file is in a different directory than the cwd , you have to provide a fully qualified file-name either with a relative-path to the cwd or an absolute-path starting from the file-system-root. Here a Unix-based example using / as path-separator (use \\ on Windows-Systems): Assume your cwd is /var/tmp/python_course/stundent_1 assume your file-location is /var/tmp/python_course/stundent_1/data then your qualified filename could be: relative: ./data/.foo.txt absolute: `/var/tmp/python course/stundent 1/data/foo.txt' Check available 'file-operations' (methods) and attributes of 'file-objects' A full set f available attributes and methods on (text-based)-file objects can be found in the Python docs of _io.TextIOWrapper . using dir() -builtin You can list the available attributes and methods of typical file-operations using the dir(<file-object>) -builtin function as shown here: >>> dir ( fd ) [ '_CHUNK_SIZE' , '__class__' , '__del__' , '__delattr__' , '__dict__' , '__dir__' , '__doc__' , '__enter__' , '__eq__' , '__exit__' , '__format__' , '__ge__' , '__getattribute__' , '__getstate__' , '__gt__' , '__hash__' , '__init__' , '__init_subclass__' , '__iter__' , '__le__' , '__lt__' , '__ne__' , '__new__' , '__next__' , '__reduce__' , '__reduce_ex__' , '__repr__' , '__setattr__' , '__sizeof__' , '__str__' , '__subclasshook__' , '_checkClosed' , '_checkReadable' , '_checkSeekable' , '_checkWritable' , '_finalizing' , 'buffer' , 'close' , 'closed' , 'detach' , 'encoding' , 'errors' , 'fileno' , 'flush' , 'isatty' , 'line_buffering' , 'mode' , 'name' , 'newlines' , 'read' , 'readable' , 'readline' , 'readlines' , 'seek' , 'seekable' , 'tell' , 'truncate' , 'writable' , 'write' , 'writelines' ] >>> using help() -builtin Again you can display the full description using the help(fd) -builtin on the returned file-object fd or any subsequent method or attribute e.g. help(fd.read) .","title":"Open a file"},{"location":"training/main-course/io/#create-a-file","text":"There is no explictit function to create a file. A file is implicitly created (if it doesn't exists) using the write() -method providing the mode-parameter w . >>> fd2 = open ( 'bar.txt' , 'w' ) >>> Note: Be aware of that w -mode will overwrite (truncate) a files content, if you need to keep it, use a -append mode.","title":"Create a file"},{"location":"training/main-course/io/#read-from-a-file","text":"Assume the file 'foo.txt' contains the following 2-lines cat foo.txt abc def There are three ways getting the content of a file read number of characters complete file line-by-line","title":"Read from a file"},{"location":"training/main-course/io/#read-some-characters","text":"file read() -call Here we ask for 2-characters in a read() -call >>> fd = open ( 'foo.txt' ) >>> fd . read ( 2 ) 'ab' >>> fd . read ( 2 ) 'c \\n ' >>> fd . read ( 2 ) 'de' >>> fd . read ( 2 ) 'f \\n ' >>> this can be looped >>> fd = open ( 'foo.txt' ) >>> s = None >>> while s != '' : ... s = fd . read ( 2 ) ... print ( repr ( s )) ... 'ab' 'c \\n ' 'de' 'f \\n ' '' >>> Note: read() returns the empty string '' when it reached the EOF (End Of File)","title":"Read some characters"},{"location":"training/main-course/io/#read-the-complete-file","text":"file read() -call If the read() is called without a parameter, it returns the complete content of the file . >>> fd = open ( 'foo.txt' ) >>> s = fd . read () >>> print ( s ) abc def >>>","title":"Read the complete file"},{"location":"training/main-course/io/#read-line-by-line","text":"A file can be read line-by-line using the readline() -method of the file-objects, see help(fd.readline) : file readline() -call Read line-by-line >>> fd = open ( 'foo.txt' ) >>> s = None >>> while s != '' : ... s = fd . readline () ... print ( repr ( s )) ... 'abc \\n ' 'def \\n ' '' >>>","title":"Read line-by-line"},{"location":"training/main-course/io/#write-to-a-file","text":"File-writing needs a file-object opened in 'write'- or 'append'--mode. Assume you have an empty bar.txt file * file write() -call * >>> fd = open ( 'bar.txt' , 'w' ) # open the file in write-mode >>> fd . write ( 'abc \\n ' ) 4 >>> fd . write ( 'def \\n ' ) 4 >>> fd . flush () >>> * Note: * The written output is buffered until it reaches a dedicated size before it is finally written to the file. Flushing the buffer enforces writing the content to the buffer into the file. You can check the written file cat bar.txt abc def","title":"Write to a file"},{"location":"training/main-course/io/#close-a-file","text":"To close a file use close() -method of the file-object file close() -call >>> fd . close () >>> Note: Never forget to close a file after finishing the file-processing.","title":"Close a file"},{"location":"training/main-course/main-course/","text":"A Curious Python Main Course # The Curious Python Main Course builds upon the material touched in the tutorial and tries to provide some more in-depth information on these topics.","title":"A Curious Python Main Course"},{"location":"training/main-course/main-course/#a-curious-python-main-course","text":"The Curious Python Main Course builds upon the material touched in the tutorial and tries to provide some more in-depth information on these topics.","title":"A Curious Python Main Course"},{"location":"training/main-course/modules-packages/","text":"We are the Mods: Modules & Package (and Scripts) # Basic Module and Package Layout # A typical Python code layout structures the code in package directories and module files. A very simple package structure could look like this: mypackage/ mypackage/__init__.py mypackage/module1.py mypackage/module2.py Suppose these files have the following contents: # mypackage Python package print ( 'mypackage' ) # module1 print ( \"I'm module 1\" ) def f ( * args , ** kwargs ): print ( 'Module 1 is great' ) # module2 print ( \"I'm module 2\" ) def f ( * args , ** kwargs ): print ( 'Module 2 is also great' ) This package can now be used as follows: >>> import mypackage mypackage >>> mypackage . module1 . f () # this will fail: mypackage.module1 not yet imported Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > AttributeError : module 'mypackage' has no attribute 'module1' >>> >>> import mypackage.module1 I 'm module 1 >>> mypackage . module1 . f () Module 1 is great >>> import mypackage.module2 I 'm module 2 >>> mypackage . module2 . f () Module 2 is also great >>> >> import mypackage.module1 # 2nd import >>> Some things to note: code in an __init__.py -file in a package dir gets executed when the package is imported __init__.py code is just regular Python code statements in a module get executed when the module is imported modules are imported only once per interpreter session (you can enforce reload in interactive sessions ) Regular and Namespace Packages # Module Search Path # Lookup of modules involves a search path. The search order for mod.py is look for a built-in module with that name look in the directories available in sys.path for the mod.py file sys.path basically contains the directory containing the importing file, or the current working directory if no file, i.e. in an interactive interpreter session the directories set in the (optional) PYTHONPATH environment variable the default directories of the Python installation, e.g. for a Python 3.6 linux installation: .../lib/python3.6/ # stdlib .../lib/python3.6/lib-dynload/ # stdlib shared libraries .../lib/python3.6/site-packages/ # site-wide installed 3rd party packages Scripts # Scripts are Python modules that are intended to be run as executables. More often that not such scripts will want to parse command line options, receive stdin input or user input and write stdout output or output file(s). Often, the duality of a script also being a normal module makes it desirable to have it act both as an importable module as well as an executable. In such situations it makes sense to guard the executable operations with: if __name__ == \"__main__\" : # everything here will only get executed when run as the main module # i.e. the special name __name__ contains the string \"__main__\" ... The special name __name__ is set to \"__main__\" for the main file that gets executed by the Python interpreter, e.g. python myprogram.py or ./myprogram.py if this file has been made executable. Note : The main file run by the Python interpreter doesn't need to have the .py file extension, so you can make such a file look like an executable or command with regard to its file name (\"myprogram\"). However, it is not importable itself, then. Here's a template for a basic command line script: import sys def parse_args ( args = None ): \"\"\"Parse arguments from sys.argv if args is None (the default) or from args sequence otherwise. \"\"\" import argparse parser = argparse . ArgumentParser () # Add arguments here args = parser . parse_args ( args ) return args def main ( args = None ): \"\"\"Main module function. Exposes this modules' executable functionality for use as a module function. Parses arguments from sys.argv if args is None (the default) or from args sequence otherwise. \"\"\" args = parse_args ( args ) # Add main code here if __name__ == \"__main__\" : sys . exit ( main ()) Hint : More elaborate Python libraries that contain many packages and modules may want use the console_scripts entry point functionality of setuptools . This is allows you to expose functions of your library (the \"entry points\") as command line scripts, automatically generated by setuptools when building the installable library package from the source code files. You can find more information on this here or in the Python Packaging User Guide .","title":"Chapter 11: Modules & Packages"},{"location":"training/main-course/modules-packages/#we-are-the-mods-modules-package-and-scripts","text":"","title":"We are the Mods: Modules &amp; Package (and Scripts)"},{"location":"training/main-course/modules-packages/#basic-module-and-package-layout","text":"A typical Python code layout structures the code in package directories and module files. A very simple package structure could look like this: mypackage/ mypackage/__init__.py mypackage/module1.py mypackage/module2.py Suppose these files have the following contents: # mypackage Python package print ( 'mypackage' ) # module1 print ( \"I'm module 1\" ) def f ( * args , ** kwargs ): print ( 'Module 1 is great' ) # module2 print ( \"I'm module 2\" ) def f ( * args , ** kwargs ): print ( 'Module 2 is also great' ) This package can now be used as follows: >>> import mypackage mypackage >>> mypackage . module1 . f () # this will fail: mypackage.module1 not yet imported Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > AttributeError : module 'mypackage' has no attribute 'module1' >>> >>> import mypackage.module1 I 'm module 1 >>> mypackage . module1 . f () Module 1 is great >>> import mypackage.module2 I 'm module 2 >>> mypackage . module2 . f () Module 2 is also great >>> >> import mypackage.module1 # 2nd import >>> Some things to note: code in an __init__.py -file in a package dir gets executed when the package is imported __init__.py code is just regular Python code statements in a module get executed when the module is imported modules are imported only once per interpreter session (you can enforce reload in interactive sessions )","title":"Basic Module and Package Layout"},{"location":"training/main-course/modules-packages/#regular-and-namespace-packages","text":"","title":"Regular and Namespace Packages"},{"location":"training/main-course/modules-packages/#module-search-path","text":"Lookup of modules involves a search path. The search order for mod.py is look for a built-in module with that name look in the directories available in sys.path for the mod.py file sys.path basically contains the directory containing the importing file, or the current working directory if no file, i.e. in an interactive interpreter session the directories set in the (optional) PYTHONPATH environment variable the default directories of the Python installation, e.g. for a Python 3.6 linux installation: .../lib/python3.6/ # stdlib .../lib/python3.6/lib-dynload/ # stdlib shared libraries .../lib/python3.6/site-packages/ # site-wide installed 3rd party packages","title":"Module Search Path"},{"location":"training/main-course/modules-packages/#scripts","text":"Scripts are Python modules that are intended to be run as executables. More often that not such scripts will want to parse command line options, receive stdin input or user input and write stdout output or output file(s). Often, the duality of a script also being a normal module makes it desirable to have it act both as an importable module as well as an executable. In such situations it makes sense to guard the executable operations with: if __name__ == \"__main__\" : # everything here will only get executed when run as the main module # i.e. the special name __name__ contains the string \"__main__\" ... The special name __name__ is set to \"__main__\" for the main file that gets executed by the Python interpreter, e.g. python myprogram.py or ./myprogram.py if this file has been made executable. Note : The main file run by the Python interpreter doesn't need to have the .py file extension, so you can make such a file look like an executable or command with regard to its file name (\"myprogram\"). However, it is not importable itself, then. Here's a template for a basic command line script: import sys def parse_args ( args = None ): \"\"\"Parse arguments from sys.argv if args is None (the default) or from args sequence otherwise. \"\"\" import argparse parser = argparse . ArgumentParser () # Add arguments here args = parser . parse_args ( args ) return args def main ( args = None ): \"\"\"Main module function. Exposes this modules' executable functionality for use as a module function. Parses arguments from sys.argv if args is None (the default) or from args sequence otherwise. \"\"\" args = parse_args ( args ) # Add main code here if __name__ == \"__main__\" : sys . exit ( main ()) Hint : More elaborate Python libraries that contain many packages and modules may want use the console_scripts entry point functionality of setuptools . This is allows you to expose functions of your library (the \"entry points\") as command line scripts, automatically generated by setuptools when building the installable library package from the source code files. You can find more information on this here or in the Python Packaging User Guide .","title":"Scripts"},{"location":"training/main-course/objects/","text":"Python Objects: Understanding (the basics of) the Python Object Model # Everything is an Object # In Python everything is an object: Functions are objects, classes are objects, instances are objects, types are objects, modules are objects, you name it: everything's an object. Even code is an object: >>> source = \"lambda: 'Hello!'\" >>> code = compile ( source , '' , 'eval' ) >>> type ( code ) < class ' code '> >>> isinstance ( code , object ) True >>> f = eval ( code ) >>> f () 'Hello!' >>> An object is an entity encompassing the \"data\" and its acceptable operations. The Python data model documentation ( https://docs.python.org/dev/reference/datamodel.html ) describes: \"Every object has an identity , a type and a value . An object\u2019s identity never changes once it has been created; you may think of it as the object\u2019s address in memory. The \u2018is\u2019 operator compares the identity of two objects; the id() function returns an integer representing its identity.\" Often, Python objects are created and named immediately with an assignment. Assigments introduce a name to refer to the object but don't create the object: 1 >>> a = 1.2 # new name a for new float object >>> b = 1.2 # new name b for new float object >>> c = a # new name c for existing float object >>> type ( a ) < class ' float '> >>> type ( b ) < class ' float '> >>> type ( c ) < class ' float '> >>> id ( a ) # (1) 140026583519544 # (2) different identity than (1) ==> different object >>> id ( b ) 140026583519592 >>> id ( c ) # (3) same identity as (1) ==> same object 140026583519544 >>> a is b False >>> a is c True >>> But note that an object needn't have a name: >>> l = [ 1 , 2.0 , lambda x : x ] In this example while the list does have a name (\"l\") none of its items has one: Neither the 1 st integer item nor the 2 nd float item nor the 3 rd anonymous function item. Python objects can be created e.g. by instantiating built-in types instantiating user-defined types (classes) defining classes defining functions defining anonymous functions You can create an instance of the most basic type object like this: >>> object () < object object at 0x7f33e1b9b0d0 > Objects are First-Class # This means that all (named) objects are equal in the sense that they can be treated equally: a function object can be an argument to another function, a module object can be a list item, a class can be a dictionary value (or even a dictionary key), ... This allows for writing powerful constructs: >> data = [ 42 , 5.0 , \"some examples are more intelligent than others\" ] >>> dispatcher = { ... str : lambda x : x . strip (), # we want strings stripped ... int : lambda x : str ( x ** 2 ), # we want ints squared ... float : lambda x : str ( - x ) # we want inverted floats ... } >>> print ( '|' . join ( ... dispatcher [ type ( d )]( d ) for d in data ) ... ) 1764 |- 5.0 | some examples are more intelligent than others >>> More characteristics of objects # The identity of an object never changes after creation (see above). The type of an object never changes after creation. The type of the object defines the allowed values and the acceptable operations. An objects is mutable if its value can be changed, immutable otherwise. Immutable and Mutable Objects # The mutability/immutability of object-values is defined by its type: immutable types: str , int , float , complex , tuple , frozenset mutable types: list , dict , set , user-defined objects (classes) Examples: immutable types # Immutable type int : >>> a = 1 >>> id ( a ) 140026581642624 >>> a = 2 # assign name 'a' to a new object >>> id ( a ) 140026581642656 >>> a += 1 >>> a 3 >>> id ( a ) # a is now a name for another new object: immutable object 2 hasn't changed in-place 140357021310400 Immutable type float : >>> f1 = 1.2 >>> f2 = 1.2 >>> f3 = f1 # (1) f3 is another name for the object named f1 >>> id ( f1 ) 140026583519544 >>> id ( f2 ) 140026583519592 >>> id ( f3 ) 140026583519544 >>> f1 = 1.3 # (2) the name f1 is now given to another object >>> f1 1.3 >>> f2 1.2 >>> f3 # (3) f3 is unaffected: it is still a name for the original object (1) 1.2 >>> id ( f1 ) 140026583519352 >>> id ( f2 ) 140026583519592 >>> id ( f3 ) 140026583519544 >>> Examples: mutable types # Mutable type list : >>> l1 = [ 1 , 2 , 3 ] >>> l2 = l1 # (1) l2 is another name for the object named l1 >>> id ( l1 ) 140026582652168 >>> id ( l2 ) 140026582652168 >>> l1 [ 0 ] = 9 # (2) change a value of of l1 >>> l1 [ 9 , 2 , 3 ] >>> l2 # (3) the change (2) also effects the value of l2 [ 9 , 2 , 3 ] >>> id ( l1 ) 140026582652168 >>> id ( l2 ) 140026582652168 >>> >>> l1 = [ 1 , 2 , 3 ] >>> l2 = l1 >>> l1 += [ 4 ] # extend mutable object >>> l1 [ 1 , 2 , 3 , 4 ] >>> l2 [ 1 , 2 , 3 , 4 ] >>> l1 is l2 True >>> Mutable type dict : >>> d1 = { 1 : 'one' , 2 : 'two' } >>> d2 = d1 >>> d2 [ 1 ] = 'three' # create some confusion >>> d2 { 1 : 'three' , 2 : 'two' } >>> d1 { 1 : 'three' , 2 : 'two' } >>> Object Lifetime and Object Reference # Every object that is created must be destroyed when it is no longer needed, otherwise we run out of memory eventually. In Python objects aren't explicitly destroyed but may be garbage-collected by the interpreter when they become unreachable, i.e. they aren't referenced any more (by name or by other objects). CPython implementation detail: CPython uses reference counting . Every object carries the \"in-use\" information in a \"reference count\" which records the number of references to this object. Remember, a variable is a name referencing an object. An assignment of a name to an object establishes this reference - during this step the reference count of the object is increased. Conversely the object's reference count is decreased when the variable is deleted (explicit using del or implicit by running out of scope) or re-assigned to another object. If the reference count of an objects is 0 the object is automatically destroyed by the garbage collector of the Python interpreter (not necessarily immediately, so don't rely on it!). You can watch these mechanisms using the getrefcount() -function of the Python standard library module sys : >>> import sys >>> l1 = [ 'cpython' , 'does' , 'refcounting' ] # create named new list >>> sys . getrefcount ( l1 ) 2 >>> id ( l1 ) 39141600 >>> l2 = l1 # new name for existing object >>> id ( l2 ) # yes, it's the same object indeed 39141600 >>> sys . getrefcount ( l1 ) # ==> refcount increased 3 >>> sys . getrefcount ( l2 ) 3 >>> l3 = l1 # yet another new name for (=reference to) existing object >>> sys . getrefcount ( l1 ) 4 >>> del l3 # delete name l3 >>> sys . getrefcount ( l1 ) # ==> refcount of list object decreased 3 >>> l2 = object () # assign name l2 to another object >>> sys . getrefcount ( l1 ) # ==> refcount of list object decreased 2 >>> Remark: As you may have noted the reference count is higher than you might expect. This is due to the fact that the sys.getrefcount() -function call also increases the object's reference count, as it needs to hold a reference to the object, too, while it is running. Note though that a = 1.2; b = 1.2; a is b would actually yield True ! This is due to identical float constants on the same line being stored as one float constant, thus labeling the single float object with the names a and b (try compile('a = 1.2; b = 1.2; a is b', '', 'exec').co_consts ). \u21a9","title":"Chapter 2: Python Objects"},{"location":"training/main-course/objects/#python-objects-understanding-the-basics-of-the-python-object-model","text":"","title":"Python Objects: Understanding (the basics of) the Python Object Model"},{"location":"training/main-course/objects/#everything-is-an-object","text":"In Python everything is an object: Functions are objects, classes are objects, instances are objects, types are objects, modules are objects, you name it: everything's an object. Even code is an object: >>> source = \"lambda: 'Hello!'\" >>> code = compile ( source , '' , 'eval' ) >>> type ( code ) < class ' code '> >>> isinstance ( code , object ) True >>> f = eval ( code ) >>> f () 'Hello!' >>> An object is an entity encompassing the \"data\" and its acceptable operations. The Python data model documentation ( https://docs.python.org/dev/reference/datamodel.html ) describes: \"Every object has an identity , a type and a value . An object\u2019s identity never changes once it has been created; you may think of it as the object\u2019s address in memory. The \u2018is\u2019 operator compares the identity of two objects; the id() function returns an integer representing its identity.\" Often, Python objects are created and named immediately with an assignment. Assigments introduce a name to refer to the object but don't create the object: 1 >>> a = 1.2 # new name a for new float object >>> b = 1.2 # new name b for new float object >>> c = a # new name c for existing float object >>> type ( a ) < class ' float '> >>> type ( b ) < class ' float '> >>> type ( c ) < class ' float '> >>> id ( a ) # (1) 140026583519544 # (2) different identity than (1) ==> different object >>> id ( b ) 140026583519592 >>> id ( c ) # (3) same identity as (1) ==> same object 140026583519544 >>> a is b False >>> a is c True >>> But note that an object needn't have a name: >>> l = [ 1 , 2.0 , lambda x : x ] In this example while the list does have a name (\"l\") none of its items has one: Neither the 1 st integer item nor the 2 nd float item nor the 3 rd anonymous function item. Python objects can be created e.g. by instantiating built-in types instantiating user-defined types (classes) defining classes defining functions defining anonymous functions You can create an instance of the most basic type object like this: >>> object () < object object at 0x7f33e1b9b0d0 >","title":"Everything is an Object"},{"location":"training/main-course/objects/#objects-are-first-class","text":"This means that all (named) objects are equal in the sense that they can be treated equally: a function object can be an argument to another function, a module object can be a list item, a class can be a dictionary value (or even a dictionary key), ... This allows for writing powerful constructs: >> data = [ 42 , 5.0 , \"some examples are more intelligent than others\" ] >>> dispatcher = { ... str : lambda x : x . strip (), # we want strings stripped ... int : lambda x : str ( x ** 2 ), # we want ints squared ... float : lambda x : str ( - x ) # we want inverted floats ... } >>> print ( '|' . join ( ... dispatcher [ type ( d )]( d ) for d in data ) ... ) 1764 |- 5.0 | some examples are more intelligent than others >>>","title":"Objects are First-Class"},{"location":"training/main-course/objects/#more-characteristics-of-objects","text":"The identity of an object never changes after creation (see above). The type of an object never changes after creation. The type of the object defines the allowed values and the acceptable operations. An objects is mutable if its value can be changed, immutable otherwise.","title":"More characteristics of objects"},{"location":"training/main-course/objects/#immutable-and-mutable-objects","text":"The mutability/immutability of object-values is defined by its type: immutable types: str , int , float , complex , tuple , frozenset mutable types: list , dict , set , user-defined objects (classes)","title":"Immutable and Mutable Objects"},{"location":"training/main-course/objects/#examples-immutable-types","text":"Immutable type int : >>> a = 1 >>> id ( a ) 140026581642624 >>> a = 2 # assign name 'a' to a new object >>> id ( a ) 140026581642656 >>> a += 1 >>> a 3 >>> id ( a ) # a is now a name for another new object: immutable object 2 hasn't changed in-place 140357021310400 Immutable type float : >>> f1 = 1.2 >>> f2 = 1.2 >>> f3 = f1 # (1) f3 is another name for the object named f1 >>> id ( f1 ) 140026583519544 >>> id ( f2 ) 140026583519592 >>> id ( f3 ) 140026583519544 >>> f1 = 1.3 # (2) the name f1 is now given to another object >>> f1 1.3 >>> f2 1.2 >>> f3 # (3) f3 is unaffected: it is still a name for the original object (1) 1.2 >>> id ( f1 ) 140026583519352 >>> id ( f2 ) 140026583519592 >>> id ( f3 ) 140026583519544 >>>","title":"Examples: immutable types"},{"location":"training/main-course/objects/#examples-mutable-types","text":"Mutable type list : >>> l1 = [ 1 , 2 , 3 ] >>> l2 = l1 # (1) l2 is another name for the object named l1 >>> id ( l1 ) 140026582652168 >>> id ( l2 ) 140026582652168 >>> l1 [ 0 ] = 9 # (2) change a value of of l1 >>> l1 [ 9 , 2 , 3 ] >>> l2 # (3) the change (2) also effects the value of l2 [ 9 , 2 , 3 ] >>> id ( l1 ) 140026582652168 >>> id ( l2 ) 140026582652168 >>> >>> l1 = [ 1 , 2 , 3 ] >>> l2 = l1 >>> l1 += [ 4 ] # extend mutable object >>> l1 [ 1 , 2 , 3 , 4 ] >>> l2 [ 1 , 2 , 3 , 4 ] >>> l1 is l2 True >>> Mutable type dict : >>> d1 = { 1 : 'one' , 2 : 'two' } >>> d2 = d1 >>> d2 [ 1 ] = 'three' # create some confusion >>> d2 { 1 : 'three' , 2 : 'two' } >>> d1 { 1 : 'three' , 2 : 'two' } >>>","title":"Examples: mutable types"},{"location":"training/main-course/objects/#object-lifetime-and-object-reference","text":"Every object that is created must be destroyed when it is no longer needed, otherwise we run out of memory eventually. In Python objects aren't explicitly destroyed but may be garbage-collected by the interpreter when they become unreachable, i.e. they aren't referenced any more (by name or by other objects). CPython implementation detail: CPython uses reference counting . Every object carries the \"in-use\" information in a \"reference count\" which records the number of references to this object. Remember, a variable is a name referencing an object. An assignment of a name to an object establishes this reference - during this step the reference count of the object is increased. Conversely the object's reference count is decreased when the variable is deleted (explicit using del or implicit by running out of scope) or re-assigned to another object. If the reference count of an objects is 0 the object is automatically destroyed by the garbage collector of the Python interpreter (not necessarily immediately, so don't rely on it!). You can watch these mechanisms using the getrefcount() -function of the Python standard library module sys : >>> import sys >>> l1 = [ 'cpython' , 'does' , 'refcounting' ] # create named new list >>> sys . getrefcount ( l1 ) 2 >>> id ( l1 ) 39141600 >>> l2 = l1 # new name for existing object >>> id ( l2 ) # yes, it's the same object indeed 39141600 >>> sys . getrefcount ( l1 ) # ==> refcount increased 3 >>> sys . getrefcount ( l2 ) 3 >>> l3 = l1 # yet another new name for (=reference to) existing object >>> sys . getrefcount ( l1 ) 4 >>> del l3 # delete name l3 >>> sys . getrefcount ( l1 ) # ==> refcount of list object decreased 3 >>> l2 = object () # assign name l2 to another object >>> sys . getrefcount ( l1 ) # ==> refcount of list object decreased 2 >>> Remark: As you may have noted the reference count is higher than you might expect. This is due to the fact that the sys.getrefcount() -function call also increases the object's reference count, as it needs to hold a reference to the object, too, while it is running. Note though that a = 1.2; b = 1.2; a is b would actually yield True ! This is due to identical float constants on the same line being stored as one float constant, thus labeling the single float object with the names a and b (try compile('a = 1.2; b = 1.2; a is b', '', 'exec').co_consts ). \u21a9","title":"Object Lifetime and Object Reference"},{"location":"training/main-course/stdlib-tour/","text":"Guided standard library tour: A subjective selection of indispensible stdlib libraries # Caveat: This is necessarily opinionated and definitely too short Note currently under construction...","title":"Chapter 13: Python Standard Library"},{"location":"training/main-course/stdlib-tour/#guided-standard-library-tour-a-subjective-selection-of-indispensible-stdlib-libraries","text":"Caveat: This is necessarily opinionated and definitely too short Note currently under construction...","title":"Guided standard library tour: A subjective selection of indispensible stdlib libraries"},{"location":"training/main-course/venvs-packages-installation/","text":"Python Environments and (3 rd party) Package Installation # The Python's Nest # A typical system (C)Python installation will look something like this: # Linux system essential Python paths /usr/bin/python -> python3.6 /usr/bin/python3 -> python3.6 /usr/bin/python3.6 /usr/include/python3.6 -> python3.6m /usr/include/python3.6m /usr/lib/python3.6 The lib path contains the Python standard library, basically: /usr/lib/python3.6 # pure-python stdlib modules/packages /usr/lib/python3.6/lib-dynload # shared libraries (compiled C extensions) But there's also the site-packages directory for system-wide installation of 3 rd party libraries (i.e. not bundled with Pytho in its stdlib): /usr/lib/python3.6/site-packages # path for additional, non-standard packages To install anything into these paths you usually need admin privileges (on Linux, these paths are normally owned by the root user). The benefit of installing additional packages to the system-wide installation is obvious: all Python programs can then use these added functionality, and the necessary library files are installed only once. Most of the time, it is however less desirable to install your dependencies (the 3 rd party packages your program depends on) to the system Python installation: you might not even have admin privileges so you can't properly install your dependencies (the usual cas in corporate environments) another program might require the same dependency albeit in a different, potentially conflicting version it is harder to create portable programs as the next machine might not have the same packages installed, so your program won't run there Installing Python Packages # Python packages can be installed using the Python package installer pip . Usually such packages are retrieved from the official Python Package Index (PyPI) . Warning To avoid unintentional installation of malicious packages always make sure you know what you're installing (ideally having reviewed the code), use a trusted packages source 1 and use the correct spelling of the package you intend to install. 2 Unfortunately this is not too easy because anybody can upload their packages to PyPI. As your dependency will probably depend on other packages itself (and so on), the dependency tree can quickly become quite large. On the plus-side well-known projects are usually developed in the open (e.g. on GitHub / GitLab / Bitbucket ) and reviewed by many eyes. So just be aware. Using the popular requests library as an example: Install the latest & greatest version: pip install \"requests\" You can explicitly select a specific version for installation: pip install \"requests==2.23.0\" It's also possible to select a version inside some version range: pip install \"requests>=1,<2\" pip also allows you to select a version that is deemed compatible to another version (according to certain criteria of compatibility): 3 pip install \"requests~=2.19.0\" If the package to install is properly set up, pip resolves its dependencies and automatically installs these \"prerequisites\", i.e. the dependencies of your dependencies. You can control the \"package index\" where the packages are retrieved from by pip , with the default being PyPI ; packages can also be installed from local filesystem paths and directly from (remote) version control repositories. See here for more detailed tutorial instructions on installing packages . Python environments # If you don't want to install to the system Python (which is probably a good idea) you can isolate your app and its dependencies in a Python \"virtual environment\" or \"venv\". Virtual environments are installation directories that basically contain a Python installation layout that links to the system installation. In effect all the system Python installation stuff (standard library etc.) is retrieved from this system installation while your application and its dependencies are installed into the site-packages directory of the virtual environment. A virtual env can simply be created with python3 -m venv /path/to/new/virtual-env To use the virtual environment you can either explitly use the executable path(s) of this virtual env: /path/to/new/virtual-env/bin/python # interpreter /path/to/new/virtual-env/bin/pip # package installer or you can activate this environment: # POSIX (Linus e.a.) source /path/to/new/virtual-env/bin/activate # bash/zsh source /path/to/new/virtual-env/bin/activate.csh # csh/tcsh # Windows C:\\> \\path\\to\\new\\virtual-env\\Scripts\\activate.bat # cmd.exe PS C:\\> \\path\\to\\new\\virtual-env\\Scripts\\Activate.ps1 # PowerShell Activation means \"sourcing\" a script that makes the necessary environment settings (e.g. the program search path ( PATH on Linux)) so that this virtual env can be used without qualified path invocation. Once activated you can simply use python3 , pip , ... and the executable files in /path/to/new/virtual-env/bin/ are invoked. That means installing packages with pip will now install these to the active virtual env. To remind you you're working within an activated virtual env, activation conveniently modifiies the command line prompt. Finally, you can leave activation using deactivate : 0 lisa@devmachine .../~ $ source ~/venvs/six-venv/bin/activate (six-venv) 0 lisa@devmachine .../~ $ (six-venv) 0 lisa@devmachine .../cpycourse $ deactivate 0 lisa@devmachine .../~ $ There are ongoing efforts to improve PyPI security and guard against evil-doers. \u21a9 There have been attempts in the past to put malicious code on PyPI; these used the typosquatting technique and mimicked popular libraries by using a similar package name. \u21a9 See https://www.python.org/dev/peps/pep-0440/ . \u21a9","title":"Chapter 12: Python Environments & Package Installation"},{"location":"training/main-course/venvs-packages-installation/#python-environments-and-3rd-party-package-installation","text":"","title":"Python Environments and (3rd party) Package Installation"},{"location":"training/main-course/venvs-packages-installation/#the-pythons-nest","text":"A typical system (C)Python installation will look something like this: # Linux system essential Python paths /usr/bin/python -> python3.6 /usr/bin/python3 -> python3.6 /usr/bin/python3.6 /usr/include/python3.6 -> python3.6m /usr/include/python3.6m /usr/lib/python3.6 The lib path contains the Python standard library, basically: /usr/lib/python3.6 # pure-python stdlib modules/packages /usr/lib/python3.6/lib-dynload # shared libraries (compiled C extensions) But there's also the site-packages directory for system-wide installation of 3 rd party libraries (i.e. not bundled with Pytho in its stdlib): /usr/lib/python3.6/site-packages # path for additional, non-standard packages To install anything into these paths you usually need admin privileges (on Linux, these paths are normally owned by the root user). The benefit of installing additional packages to the system-wide installation is obvious: all Python programs can then use these added functionality, and the necessary library files are installed only once. Most of the time, it is however less desirable to install your dependencies (the 3 rd party packages your program depends on) to the system Python installation: you might not even have admin privileges so you can't properly install your dependencies (the usual cas in corporate environments) another program might require the same dependency albeit in a different, potentially conflicting version it is harder to create portable programs as the next machine might not have the same packages installed, so your program won't run there","title":"The Python's Nest"},{"location":"training/main-course/venvs-packages-installation/#installing-python-packages","text":"Python packages can be installed using the Python package installer pip . Usually such packages are retrieved from the official Python Package Index (PyPI) . Warning To avoid unintentional installation of malicious packages always make sure you know what you're installing (ideally having reviewed the code), use a trusted packages source 1 and use the correct spelling of the package you intend to install. 2 Unfortunately this is not too easy because anybody can upload their packages to PyPI. As your dependency will probably depend on other packages itself (and so on), the dependency tree can quickly become quite large. On the plus-side well-known projects are usually developed in the open (e.g. on GitHub / GitLab / Bitbucket ) and reviewed by many eyes. So just be aware. Using the popular requests library as an example: Install the latest & greatest version: pip install \"requests\" You can explicitly select a specific version for installation: pip install \"requests==2.23.0\" It's also possible to select a version inside some version range: pip install \"requests>=1,<2\" pip also allows you to select a version that is deemed compatible to another version (according to certain criteria of compatibility): 3 pip install \"requests~=2.19.0\" If the package to install is properly set up, pip resolves its dependencies and automatically installs these \"prerequisites\", i.e. the dependencies of your dependencies. You can control the \"package index\" where the packages are retrieved from by pip , with the default being PyPI ; packages can also be installed from local filesystem paths and directly from (remote) version control repositories. See here for more detailed tutorial instructions on installing packages .","title":"Installing Python Packages"},{"location":"training/main-course/venvs-packages-installation/#python-environments","text":"If you don't want to install to the system Python (which is probably a good idea) you can isolate your app and its dependencies in a Python \"virtual environment\" or \"venv\". Virtual environments are installation directories that basically contain a Python installation layout that links to the system installation. In effect all the system Python installation stuff (standard library etc.) is retrieved from this system installation while your application and its dependencies are installed into the site-packages directory of the virtual environment. A virtual env can simply be created with python3 -m venv /path/to/new/virtual-env To use the virtual environment you can either explitly use the executable path(s) of this virtual env: /path/to/new/virtual-env/bin/python # interpreter /path/to/new/virtual-env/bin/pip # package installer or you can activate this environment: # POSIX (Linus e.a.) source /path/to/new/virtual-env/bin/activate # bash/zsh source /path/to/new/virtual-env/bin/activate.csh # csh/tcsh # Windows C:\\> \\path\\to\\new\\virtual-env\\Scripts\\activate.bat # cmd.exe PS C:\\> \\path\\to\\new\\virtual-env\\Scripts\\Activate.ps1 # PowerShell Activation means \"sourcing\" a script that makes the necessary environment settings (e.g. the program search path ( PATH on Linux)) so that this virtual env can be used without qualified path invocation. Once activated you can simply use python3 , pip , ... and the executable files in /path/to/new/virtual-env/bin/ are invoked. That means installing packages with pip will now install these to the active virtual env. To remind you you're working within an activated virtual env, activation conveniently modifiies the command line prompt. Finally, you can leave activation using deactivate : 0 lisa@devmachine .../~ $ source ~/venvs/six-venv/bin/activate (six-venv) 0 lisa@devmachine .../~ $ (six-venv) 0 lisa@devmachine .../cpycourse $ deactivate 0 lisa@devmachine .../~ $ There are ongoing efforts to improve PyPI security and guard against evil-doers. \u21a9 There have been attempts in the past to put malicious code on PyPI; these used the typosquatting technique and mimicked popular libraries by using a similar package name. \u21a9 See https://www.python.org/dev/peps/pep-0440/ . \u21a9","title":"Python environments"}]}